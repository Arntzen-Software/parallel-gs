From 1e2942304dd3570cfb88cfbdf4e96d623aa39737 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Fri, 12 Jul 2024 23:01:39 +0200
Subject: [PATCH 2/3] Early integration of parallel-GS.

---
 .gitignore                                    |   2 +
 pcsx2-gsrunner/Main.cpp                       |   4 +
 pcsx2-qt/MainWindow.cpp                       |   3 +
 pcsx2-qt/Settings/GraphicsSettingsWidget.cpp  |  41 +-
 pcsx2-qt/Settings/GraphicsSettingsWidget.ui   |  53 ++
 pcsx2-qt/pcsx2-qt.vcxproj                     |   2 +-
 pcsx2/CMakeLists.txt                          |  20 +
 pcsx2/Config.h                                |   2 +
 pcsx2/GS/GS.cpp                               | 340 ++++++--
 pcsx2/GS/GS.h                                 |   3 +
 pcsx2/GS/GSState.cpp                          |   2 +-
 pcsx2/GS/GSState.h                            |   2 +-
 pcsx2/GS/GSUtil.cpp                           |   4 +-
 pcsx2/GS/Renderers/Common/GSRenderer.cpp      |   2 +-
 pcsx2/GS/Renderers/Vulkan/VKLoader.cpp        |  18 +-
 pcsx2/GS/Renderers/Vulkan/VKLoader.h          |  19 +-
 .../Vulkan/VKLoaderPlatformDefines.h          |  23 +
 .../Renderers/parallel-gs/GSRendererPGS.cpp   | 760 ++++++++++++++++++
 .../GS/Renderers/parallel-gs/GSRendererPGS.h  |  84 ++
 pcsx2/ImGui/ImGuiFullscreen.cpp               |   2 +
 pcsx2/Pcsx2Config.cpp                         |  23 +-
 pcsx2/pcsx2.vcxproj                           |  51 +-
 22 files changed, 1360 insertions(+), 100 deletions(-)
 create mode 100644 pcsx2/GS/Renderers/Vulkan/VKLoaderPlatformDefines.h
 create mode 100644 pcsx2/GS/Renderers/parallel-gs/GSRendererPGS.cpp
 create mode 100644 pcsx2/GS/Renderers/parallel-gs/GSRendererPGS.h

diff --git a/.gitignore b/.gitignore
index b59e873da..aac77d348 100644
--- a/.gitignore
+++ b/.gitignore
@@ -120,3 +120,5 @@ CMakeSettings.json
 /ci-artifacts/
 /out/
 /.cache/
+
+/pcsx2/GS/parallel-gs
diff --git a/pcsx2-gsrunner/Main.cpp b/pcsx2-gsrunner/Main.cpp
index d3ad1e818..0f4120573 100644
--- a/pcsx2-gsrunner/Main.cpp
+++ b/pcsx2-gsrunner/Main.cpp
@@ -519,6 +519,10 @@ bool GSRunner::ParseCommandLineArgs(int argc, char* argv[], VMBootParameters& pa
 				else if (StringUtil::Strcasecmp(rname, "dx12") == 0)
 					type = GSRendererType::DX12;
 #endif
+#ifdef HAVE_PARALLEL_GS
+				else if (StringUtil::Strcasecmp(rname, "parallel-gs") == 0)
+					type = GSRendererType::ParallelGS;
+#endif
 #ifdef ENABLE_OPENGL
 				else if (StringUtil::Strcasecmp(rname, "gl") == 0)
 					type = GSRendererType::OGL;
diff --git a/pcsx2-qt/MainWindow.cpp b/pcsx2-qt/MainWindow.cpp
index b0c60588d..3d93053e5 100644
--- a/pcsx2-qt/MainWindow.cpp
+++ b/pcsx2-qt/MainWindow.cpp
@@ -458,6 +458,9 @@ void MainWindow::createRendererSwitchMenu()
 {
 	static constexpr const GSRendererType renderers[] = {
 		GSRendererType::Auto,
+#if defined(HAVE_PARALLEL_GS)
+		GSRendererType::ParallelGS,
+#endif
 #if defined(_WIN32)
 		GSRendererType::DX11,
 		GSRendererType::DX12,
diff --git a/pcsx2-qt/Settings/GraphicsSettingsWidget.cpp b/pcsx2-qt/Settings/GraphicsSettingsWidget.cpp
index 5873377d8..3a844dbaa 100644
--- a/pcsx2-qt/Settings/GraphicsSettingsWidget.cpp
+++ b/pcsx2-qt/Settings/GraphicsSettingsWidget.cpp
@@ -20,6 +20,9 @@ struct RendererInfo
 
 static constexpr RendererInfo s_renderer_info[] = {
 	{QT_TRANSLATE_NOOP("GraphicsSettingsWidget", "Automatic (Default)"), GSRendererType::Auto},
+#ifdef HAVE_PARALLEL_GS
+	{QT_TRANSLATE_NOOP("GraphicsSettingsWidget", "paraLLEl-GS"), GSRendererType::ParallelGS},
+#endif
 #ifdef _WIN32
 	//: Graphics backend/engine type. Leave as-is.
 	{QT_TRANSLATE_NOOP("GraphicsSettingsWidget", "Direct3D 11"), GSRendererType::DX11},
@@ -263,6 +266,11 @@ GraphicsSettingsWidget::GraphicsSettingsWidget(SettingsWindow* dialog, QWidget*
 	SettingWidgetBinder::BindWidgetToBoolSetting(sif, m_ui.swAutoFlush, "EmuCore/GS", "autoflush_sw", true);
 	SettingWidgetBinder::BindWidgetToBoolSetting(sif, m_ui.swMipmap, "EmuCore/GS", "mipmap", true);
 
+	//////////////////////////////////////////////////////////////////////////
+	// PGS Settings
+	//////////////////////////////////////////////////////////////////////////
+	SettingWidgetBinder::BindWidgetToIntSetting(sif, m_ui.pgsSuperSampling, "EmuCore/GS", "pgsSuperSampling", 0);
+
 	//////////////////////////////////////////////////////////////////////////
 	// Non-trivial settings
 	//////////////////////////////////////////////////////////////////////////
@@ -297,6 +305,7 @@ GraphicsSettingsWidget::GraphicsSettingsWidget(SettingsWindow* dialog, QWidget*
 	connect(m_ui.extendedUpscales, &QCheckBox::checkStateChanged, this, &GraphicsSettingsWidget::updateRendererDependentOptions);
 	connect(m_ui.textureFiltering, &QComboBox::currentIndexChanged, this, &GraphicsSettingsWidget::onTextureFilteringChange);
 	connect(m_ui.swTextureFiltering, &QComboBox::currentIndexChanged, this, &GraphicsSettingsWidget::onSWTextureFilteringChange);
+
 	updateRendererDependentOptions();
 
 #ifndef _WIN32
@@ -570,6 +579,11 @@ GraphicsSettingsWidget::GraphicsSettingsWidget(SettingsWindow* dialog, QWidget*
 
 		dialog->registerWidgetHelp(
 			m_ui.swMipmap, tr("Mipmapping"), tr("Checked"), tr("Enables mipmapping, which some games require to render correctly."));
+
+		dialog->registerWidgetHelp(m_ui.pgsSuperSampling, tr("paraLLEl-GS Super Sampling"), tr("1x (native)"),
+		                           tr("Number of super samples used by paraLLEl-GS before down-sampling to native resolution. "
+		                              "More than 8x SSAA is not recommended as there is no obvious visual difference in output. "
+		                              "8x SSAA yields a very nice result, but requires reasonably powerful hardware in some games."));
 	}
 
 	// Hardware Fixes tab
@@ -1078,6 +1092,7 @@ void GraphicsSettingsWidget::updateRendererDependentOptions()
 	const bool is_hardware = (type == GSRendererType::DX11 || type == GSRendererType::DX12 || type == GSRendererType::OGL ||
 							  type == GSRendererType::VK || type == GSRendererType::Metal);
 	const bool is_software = (type == GSRendererType::SW);
+	const bool is_pgs = (type == GSRendererType::ParallelGS);
 	const bool is_auto = (type == GSRendererType::Auto);
 	const bool is_vk = (type == GSRendererType::VK);
 	const bool is_disable_barriers = (type == GSRendererType::DX11 || type == GSRendererType::DX12 || type == GSRendererType::Metal || type == GSRendererType::SW);
@@ -1092,22 +1107,32 @@ void GraphicsSettingsWidget::updateRendererDependentOptions()
 	m_ui.tabs->setTabEnabled(2, is_software);
 	m_ui.tabs->setTabVisible(2, is_software);
 
-	// hardware fixes
-	m_ui.tabs->setTabEnabled(3, hw_fixes);
-	m_ui.tabs->setTabVisible(3, hw_fixes);
+	// pgs rendering
+	m_ui.tabs->setTabEnabled(3, is_pgs);
+	m_ui.tabs->setTabVisible(3, is_pgs);
 
-	// upscaling fixes
+	// hardware fixes
 	m_ui.tabs->setTabEnabled(4, hw_fixes);
 	m_ui.tabs->setTabVisible(4, hw_fixes);
 
+	// upscaling fixes
+	m_ui.tabs->setTabEnabled(5, hw_fixes);
+	m_ui.tabs->setTabVisible(5, hw_fixes);
+
 	// texture replacement
-	m_ui.tabs->setTabEnabled(5, is_hardware);
-	m_ui.tabs->setTabVisible(5, is_hardware);
+	m_ui.tabs->setTabEnabled(6, is_hardware);
+	m_ui.tabs->setTabVisible(6, is_hardware);
+
+	// Post-processing
+	m_ui.tabs->setTabEnabled(7, !is_pgs);
+	m_ui.tabs->setTabVisible(7, !is_pgs);
 
 	// move back to the renderer if we're on one of the now-hidden tabs
-	if (is_software && (prev_tab == 1 || (prev_tab >= 2 && prev_tab <= 5)))
+	if (is_software && (prev_tab == 1 || (prev_tab >= 2 && prev_tab <= 6)))
 		m_ui.tabs->setCurrentIndex(2);
-	else if (is_hardware && prev_tab == 2)
+	else if (is_pgs)
+		m_ui.tabs->setCurrentIndex(3);
+	else if (is_hardware && (prev_tab == 2 || prev_tab == 3))
 		m_ui.tabs->setCurrentIndex(1);
 
 	if (m_ui.useBlitSwapChain)
diff --git a/pcsx2-qt/Settings/GraphicsSettingsWidget.ui b/pcsx2-qt/Settings/GraphicsSettingsWidget.ui
index de1240e5f..8f8326676 100644
--- a/pcsx2-qt/Settings/GraphicsSettingsWidget.ui
+++ b/pcsx2-qt/Settings/GraphicsSettingsWidget.ui
@@ -751,6 +751,59 @@
        </item>
       </layout>
      </widget>
+     <widget class="QWidget" name="pgsRenderingTab">
+      <attribute name="title"><string>Rendering</string></attribute>
+      <layout class="QFormLayout" name="formLayout_11">
+       <item row="0" column="0">
+        <widget class="QLabel" name="pgsSuperSamplingLabel">
+         <property name="text">
+          <string>Super Sampling:</string>
+         </property>
+        </widget>
+       </item>
+       <item row="0" column="1">
+        <widget class="QComboBox" name="pgsSuperSampling">
+         <property name="enabled">
+          <bool>true</bool>
+         </property>
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+         <property name="layoutDirection">
+          <enum>Qt::LayoutDirection::LeftToRight</enum>
+         </property>
+         <item>
+          <property name="text">
+           <string>1x (native)</string>
+          </property>
+         </item>
+         <item>
+          <property name="text">
+           <string>2x SSAA (2x2 checkerboard)</string>
+          </property>
+         </item>
+         <item>
+          <property name="text">
+           <string>4x SSAA (2x2 ordered grid)</string>
+          </property>
+         </item>
+         <item>
+          <property name="text">
+           <string>8x SSAA (4x4 checkerboard)</string>
+          </property>
+         </item>
+         <item>
+          <property name="text">
+           <string>16x SSAA (4x4 ordered grid)</string>
+          </property>
+         </item>
+        </widget>
+       </item>
+      </layout>
+     </widget>
      <widget class="QGroupBox" name="hardwareFixesTab">
       <attribute name="title">
        <string>Hardware Fixes</string>
diff --git a/pcsx2-qt/pcsx2-qt.vcxproj b/pcsx2-qt/pcsx2-qt.vcxproj
index 4f444793c..8f9c57fdc 100644
--- a/pcsx2-qt/pcsx2-qt.vcxproj
+++ b/pcsx2-qt/pcsx2-qt.vcxproj
@@ -53,7 +53,7 @@
       <ForcedIncludeFiles>PrecompiledHeader.h;%(ForcedIncludeFiles)</ForcedIncludeFiles>
       <PreprocessorDefinitions Condition="'$(Platform)'!='ARM64'">ENABLE_RAINTEGRATION;ENABLE_OPENGL;ENABLE_VULKAN;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <PreprocessorDefinitions>LZMA_API_STATIC;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <PreprocessorDefinitions>QT_NO_EXCEPTIONS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <PreprocessorDefinitions>HAVE_PARALLEL_GS;QT_NO_EXCEPTIONS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <!-- Current Qt debug builds assert on RTTI. Remove this once we next build Qt. -->
       <RuntimeTypeInfo Condition="$(Configuration.Contains(Debug))">true</RuntimeTypeInfo>
     </ClCompile>
diff --git a/pcsx2/CMakeLists.txt b/pcsx2/CMakeLists.txt
index 1f2bfd9e9..c96c9ec15 100644
--- a/pcsx2/CMakeLists.txt
+++ b/pcsx2/CMakeLists.txt
@@ -636,6 +636,7 @@ if(USE_VULKAN)
 		GS/Renderers/Vulkan/VKEntryPoints.h
 		GS/Renderers/Vulkan/VKEntryPoints.inl
 		GS/Renderers/Vulkan/VKLoader.h
+		GS/Renderers/Vulkan/VKLoaderPlatformDefines.h
 		GS/Renderers/Vulkan/VKShaderCache.h
 		GS/Renderers/Vulkan/VKStreamBuffer.h
 		GS/Renderers/Vulkan/VKSwapChain.h
@@ -644,6 +645,25 @@ if(USE_VULKAN)
 	target_include_directories(PCSX2_FLAGS INTERFACE ${SHADERC_INCLUDE_DIR})
 endif()
 
+if (IS_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/GS/parallel-gs)
+	set(PARALLEL_GS_STANDALONE ON CACHE BOOL "" FORCE)
+	message("Adding support for paraLLEl-GS")
+	add_subdirectory(GS/parallel-gs EXCLUDE_FROM_ALL)
+	target_link_libraries(PCSX2_FLAGS INTERFACE parallel-gs)
+	target_compile_definitions(PCSX2_FLAGS INTERFACE HAVE_PARALLEL_GS)
+	list(APPEND pcsx2GSSources GS/Renderers/parallel-gs/GSRendererPGS.cpp)
+	list(APPEND pcsx2GSHeaders GS/Renderers/parallel-gs/GSRendererPGS.h)
+	if (X11_API)
+		target_compile_definitions(granite-volk PUBLIC VK_USE_PLATFORM_XLIB_KHR)
+	endif()
+	if (WAYLAND_API)
+		target_compile_definitions(granite-volk PUBLIC VK_USE_PLATFORM_WAYLAND_KHR)
+	endif()
+	if (WIN32)
+		target_compile_definitions(granite-volk PUBLIC VK_USE_PLATFORM_WIN32_KHR)
+	endif()
+endif()
+
 set(pcsx2GSMetalShaders
 	GS/Renderers/Metal/cas.metal
 	GS/Renderers/Metal/convert.metal
diff --git a/pcsx2/Config.h b/pcsx2/Config.h
index 3b12a9694..4237d88ec 100644
--- a/pcsx2/Config.h
+++ b/pcsx2/Config.h
@@ -245,6 +245,7 @@ enum class GSRendererType : s8
 	VK = 14,
 	Metal = 17,
 	DX12 = 15,
+	ParallelGS = 18
 };
 
 enum class GSVSyncMode : u8
@@ -728,6 +729,7 @@ struct Pcsx2Config
 		u8 ShadeBoost_Contrast = 50;
 		u8 ShadeBoost_Saturation = 50;
 		u8 PNGCompressionLevel = 1;
+		u8 PGSSuperSampling = 0;
 
 		u16 SWExtraThreads = 2;
 		u16 SWExtraThreadsHeight = 4;
diff --git a/pcsx2/GS/GS.cpp b/pcsx2/GS/GS.cpp
index 8e42ebd46..7e348caca 100644
--- a/pcsx2/GS/GS.cpp
+++ b/pcsx2/GS/GS.cpp
@@ -22,6 +22,11 @@
 #include "GS/Renderers/HW/GSTextureReplacements.h"
 #include "VMManager.h"
 
+#ifdef HAVE_PARALLEL_GS
+#include "GS/Renderers/parallel-gs/GSRendererPGS.h"
+std::unique_ptr<GSRendererPGS> g_pgs_renderer;
+#endif
+
 #ifdef ENABLE_OPENGL
 #include "GS/Renderers/OpenGL/GSDeviceOGL.h"
 #endif
@@ -82,6 +87,11 @@ static RenderAPI GetAPIForRenderer(GSRendererType renderer)
 		case GSRendererType::VK:
 			return RenderAPI::Vulkan;
 
+#ifdef HAVE_PARALLEL_GS
+		case GSRendererType::ParallelGS:
+			return RenderAPI::Granite;
+#endif
+
 #ifdef _WIN32
 		case GSRendererType::DX11:
 			return RenderAPI::D3D11;
@@ -95,6 +105,10 @@ static RenderAPI GetAPIForRenderer(GSRendererType renderer)
 			return RenderAPI::Metal;
 #endif
 
+		case GSRendererType::SW:
+			// Hack.
+			return RenderAPI::Vulkan;
+
 			// We could end up here if we ever removed a renderer.
 		default:
 			return GetAPIForRenderer(GSUtil::GetPreferredRenderer());
@@ -132,6 +146,12 @@ static bool OpenGSDevice(GSRendererType renderer, bool clear_state_on_fail, bool
 			break;
 #endif
 
+#ifdef HAVE_PARALLEL_GS
+		case RenderAPI::Granite:
+			// The renderer owns its own device for now.
+			return true;
+#endif
+
 		default:
 			Console.Error("Unsupported render API %s", GSDevice::RenderAPIToString(new_api));
 			return false;
@@ -152,16 +172,20 @@ static bool OpenGSDevice(GSRendererType renderer, bool clear_state_on_fail, bool
 	if (!okay)
 	{
 		ImGuiManager::Shutdown(clear_state_on_fail);
-		g_gs_device->Destroy();
-		g_gs_device.reset();
+		if (g_gs_device)
+		{
+			g_gs_device->Destroy();
+			g_gs_device.reset();
+		}
 		Host::ReleaseRenderWindow();
 		return false;
 	}
 
-	GSConfig.OsdShowGPU = GSConfig.OsdShowGPU && g_gs_device->SetGPUTimingEnabled(true);
+	GSConfig.OsdShowGPU = g_gs_device && GSConfig.OsdShowGPU && g_gs_device->SetGPUTimingEnabled(true);
 
 	Console.WriteLn(Color_StrongGreen, "%s Graphics Driver Info:", GSDevice::RenderAPIToString(new_api));
-	Console.WriteLn(g_gs_device->GetDriverInfo());
+	if (g_gs_device)
+		Console.WriteLn(g_gs_device->GetDriverInfo());
 
 	return true;
 }
@@ -205,6 +229,17 @@ static bool OpenGSRenderer(GSRendererType renderer, u8* basemem)
 	{
 		g_gs_renderer = std::make_unique<GSRendererNull>();
 	}
+#ifdef HAVE_PARALLEL_GS
+	else if (renderer == GSRendererType::ParallelGS)
+	{
+		g_pgs_renderer = std::make_unique<GSRendererPGS>(basemem);
+		if (!g_pgs_renderer->Init())
+		{
+			g_pgs_renderer.reset();
+			return false;
+		}
+	}
+#endif
 	else if (renderer != GSRendererType::SW)
 	{
 		GSClampUpscaleMultiplier(GSConfig);
@@ -215,9 +250,12 @@ static bool OpenGSRenderer(GSRendererType renderer, u8* basemem)
 		g_gs_renderer = std::unique_ptr<GSRenderer>(MULTI_ISA_SELECT(makeGSRendererSW)(GSConfig.SWExtraThreads));
 	}
 
-	g_gs_renderer->SetRegsMem(basemem);
-	g_gs_renderer->ResetPCRTC();
-	g_gs_renderer->UpdateRenderFixes();
+	if (g_gs_renderer)
+	{
+		g_gs_renderer->SetRegsMem(basemem);
+		g_gs_renderer->ResetPCRTC();
+		g_gs_renderer->UpdateRenderFixes();
+	}
 	g_perfmon.Reset();
 
 	const char *env = getenv("GS_STREAM");
@@ -231,6 +269,10 @@ static void CloseGSRenderer()
 {
 	GSTextureReplacements::Shutdown();
 
+#ifdef HAVE_PARALLEL_GS
+	g_pgs_renderer.reset();
+#endif
+
 	if (g_gs_renderer)
 	{
 		g_gs_renderer->Destroy();
@@ -245,18 +287,21 @@ bool GSreopen(bool recreate_device, bool recreate_renderer, GSRendererType new_r
 {
 	Console.WriteLn("Reopening GS with %s device", recreate_device ? "new" : "existing");
 
-	g_gs_renderer->Flush(GSState::GSFlushReason::GSREOPEN);
-
-	if (recreate_device && !recreate_renderer)
-	{
-		// Keeping the renderer around, this probably means we lost the device, so toss everything.
-		g_gs_renderer->PurgeTextureCache(true, true, true);
-		g_gs_device->ClearCurrent();
-		g_gs_device->PurgePool();
-	}
-	else if (GSConfig.UserHacks_ReadTCOnClose)
+	if (g_gs_renderer)
 	{
-		g_gs_renderer->ReadbackTextureCache();
+		g_gs_renderer->Flush(GSState::GSFlushReason::GSREOPEN);
+
+		if (recreate_device && !recreate_renderer)
+		{
+			// Keeping the renderer around, this probably means we lost the device, so toss everything.
+			g_gs_renderer->PurgeTextureCache(true, true, true);
+			g_gs_device->ClearCurrent();
+			g_gs_device->PurgePool();
+		}
+		else if (GSConfig.UserHacks_ReadTCOnClose)
+		{
+			g_gs_renderer->ReadbackTextureCache();
+		}
 	}
 
 	std::string capture_filename;
@@ -266,27 +311,65 @@ bool GSreopen(bool recreate_device, bool recreate_renderer, GSRendererType new_r
 		capture_filename = GSCapture::GetNextCaptureFileName();
 		capture_size = GSCapture::GetSize();
 		Console.Warning(fmt::format("Restarting video capture to {}.", capture_filename));
-		g_gs_renderer->EndCapture();
+		if (g_gs_renderer)
+			g_gs_renderer->EndCapture();
 	}
 
-	u8* basemem = g_gs_renderer->GetRegsMem();
+	u8* basemem;
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+	{
+		basemem = g_pgs_renderer->GetRegsMem();
+	}
+	else
+#endif
+	{
+		basemem = g_gs_renderer->GetRegsMem();
+	}
 
 	freezeData fd = {};
 	std::unique_ptr<u8[]> fd_data;
 	if (recreate_renderer)
 	{
-		if (g_gs_renderer->Freeze(&fd, true) != 0)
+#ifdef HAVE_PARALLEL_GS
+		if (g_pgs_renderer)
 		{
-			Console.Error("(GSreopen) Failed to get GS freeze size");
-			return false;
+			if (g_pgs_renderer->Freeze(&fd, true) != 0)
+			{
+				Console.Error("(GSreopen) Failed to get GS freeze size");
+				return false;
+			}
+		}
+		else
+#endif
+		{
+			if (g_gs_renderer->Freeze(&fd, true) != 0)
+			{
+				Console.Error("(GSreopen) Failed to get GS freeze size");
+				return false;
+			}
 		}
 
 		fd_data = std::make_unique<u8[]>(fd.size);
 		fd.data = fd_data.get();
-		if (g_gs_renderer->Freeze(&fd, false) != 0)
+
+#ifdef HAVE_PARALLEL_GS
+		if (g_pgs_renderer)
 		{
-			Console.Error("(GSreopen) Failed to freeze GS");
-			return false;
+			if (g_pgs_renderer->Freeze(&fd, false) != 0)
+			{
+				Console.Error("(GSreopen) Failed to freeze GS");
+				return false;
+			}
+		}
+		else
+#endif
+		{
+			if (g_gs_renderer->Freeze(&fd, false) != 0)
+			{
+				Console.Error("(GSreopen) Failed to freeze GS");
+				return false;
+			}
 		}
 
 		CloseGSRenderer();
@@ -295,9 +378,10 @@ bool GSreopen(bool recreate_device, bool recreate_renderer, GSRendererType new_r
 	if (recreate_device)
 	{
 		// We need a new render window when changing APIs.
-		const bool recreate_window = (g_gs_device->GetRenderAPI() != GetAPIForRenderer(GSConfig.Renderer));
-		const GSVSyncMode vsync_mode = g_gs_device->GetVSyncMode();
-		const bool allow_present_throttle = g_gs_device->IsPresentThrottleAllowed();
+		const bool recreate_window = !g_gs_device || (g_gs_device->GetRenderAPI() != GetAPIForRenderer(GSConfig.Renderer));
+		// TODO: Pass these through.
+		const GSVSyncMode vsync_mode = g_gs_device ? g_gs_device->GetVSyncMode() : GSVSyncMode::FIFO;
+		const bool allow_present_throttle = !g_gs_device || g_gs_device->IsPresentThrottleAllowed();
 		CloseGSDevice(false);
 
 		if (!OpenGSDevice(new_renderer, false, recreate_window, vsync_mode, allow_present_throttle))
@@ -328,14 +412,27 @@ bool GSreopen(bool recreate_device, bool recreate_renderer, GSRendererType new_r
 			return false;
 		}
 
-		if (g_gs_renderer->Defrost(&fd) != 0)
+#ifdef HAVE_PARALLEL_GS
+		if (g_pgs_renderer)
 		{
-			Console.Error("(GSreopen) Failed to defrost");
-			return false;
+			if (g_pgs_renderer->Defrost(&fd) != 0)
+			{
+				Console.Error("(GSreopen) Failed to defrost");
+				return false;
+			}
+		}
+		else
+#endif
+		{
+			if (g_gs_renderer->Defrost(&fd) != 0)
+			{
+				Console.Error("(GSreopen) Failed to defrost");
+				return false;
+			}
 		}
 	}
 
-	if (!capture_filename.empty())
+	if (g_gs_renderer && !capture_filename.empty())
 		g_gs_renderer->BeginCapture(std::move(capture_filename), capture_size);
 
 	return true;
@@ -381,6 +478,9 @@ void GSclose()
 
 void GSreset(bool hardware_reset)
 {
+	if (!g_gs_renderer)
+		return;
+
 	g_gs_renderer->Reset(hardware_reset);
 
 	// Restart video capture if it's been started.
@@ -397,29 +497,48 @@ void GSreset(bool hardware_reset)
 
 void GSgifSoftReset(u32 mask)
 {
-	g_gs_renderer->SoftReset(mask);
+	if (g_gs_renderer)
+		g_gs_renderer->SoftReset(mask);
 }
 
 void GSwriteCSR(u32 csr)
 {
-	g_gs_renderer->WriteCSR(csr);
+	// TODO: Do we need to care about CSR in parallel-GS?
+	if (g_gs_renderer)
+		g_gs_renderer->WriteCSR(csr);
 }
 
 void GSInitAndReadFIFO(u8* mem, u32 size)
 {
-	GL_PERF("Init and read FIFO %u qwc", size);
-	g_gs_renderer->InitReadFIFO(mem, size);
-	g_gs_renderer->ReadFIFO(mem, size);
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		g_pgs_renderer->ReadFIFO(mem, size);
+#endif
+
+	if (g_gs_renderer)
+	{
+		GL_PERF("Init and read FIFO %u qwc", size);
+		g_gs_renderer->InitReadFIFO(mem, size);
+		g_gs_renderer->ReadFIFO(mem, size);
+	}
 }
 
 void GSReadLocalMemoryUnsync(u8* mem, u32 qwc, u64 BITBLITBUF, u64 TRXPOS, u64 TRXREG)
 {
-	g_gs_renderer->ReadLocalMemoryUnsync(mem, qwc, GIFRegBITBLTBUF{BITBLITBUF}, GIFRegTRXPOS{TRXPOS}, GIFRegTRXREG{TRXREG});
+	// TODO: What is this?
+	if (g_gs_renderer)
+		g_gs_renderer->ReadLocalMemoryUnsync(mem, qwc, GIFRegBITBLTBUF{BITBLITBUF}, GIFRegTRXPOS{TRXPOS}, GIFRegTRXREG{TRXREG});
 }
 
 void GSgifTransfer(const u8* mem, u32 size)
 {
-	g_gs_renderer->Transfer<3>(mem, size);
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		g_pgs_renderer->Transfer(mem, size);
+#endif
+
+	if (g_gs_renderer)
+		g_gs_renderer->Transfer<3>(mem, size);
 
 	if (g_gs_stream)
 	{
@@ -436,17 +555,23 @@ void GSgifTransfer(const u8* mem, u32 size)
 
 void GSgifTransfer1(u8* mem, u32 addr)
 {
-	g_gs_renderer->Transfer<0>(const_cast<u8*>(mem) + addr, (0x4000 - addr) / 16);
+	// TODO: These seem to be completely unused.
+	if (g_gs_renderer)
+		g_gs_renderer->Transfer<0>(const_cast<u8*>(mem) + addr, (0x4000 - addr) / 16);
 }
 
 void GSgifTransfer2(u8* mem, u32 size)
 {
-	g_gs_renderer->Transfer<1>(const_cast<u8*>(mem), size);
+	// TODO: These seem to be completely unused.
+	if (g_gs_renderer)
+		g_gs_renderer->Transfer<1>(const_cast<u8*>(mem), size);
 }
 
 void GSgifTransfer3(u8* mem, u32 size)
 {
-	g_gs_renderer->Transfer<2>(const_cast<u8*>(mem), size);
+	// TODO: These seem to be completely unused.
+	if (g_gs_renderer)
+		g_gs_renderer->Transfer<2>(const_cast<u8*>(mem), size);
 }
 
 void GSvsync(u32 field, bool registers_written)
@@ -457,7 +582,15 @@ void GSvsync(u32 field, bool registers_written)
 
 		const uint8_t priv_type = 3;
 		fwrite(&priv_type, sizeof(priv_type), 1, f);
-		fwrite(g_gs_renderer->GetRegsMem(), sizeof(GSPrivRegSet), 1, f);
+
+#ifdef HAVE_PARALLEL_GS
+		if (g_pgs_renderer)
+			fwrite(g_pgs_renderer->GetRegsMem(), sizeof(GSPrivRegSet), 1, f);
+		else
+#endif
+		{
+			fwrite(g_gs_renderer->GetRegsMem(), sizeof(GSPrivRegSet), 1, f);
+		}
 
 		const uint8_t type = 1;
 		fwrite(&type, sizeof(type), 1, f);
@@ -465,14 +598,37 @@ void GSvsync(u32 field, bool registers_written)
 		fwrite(&u8_field, sizeof(u8_field), 1, f);
 	}
 
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		g_pgs_renderer->VSync(field, registers_written);
+#endif
+
 	// Do not move the flush into the VSync() method. It's here because EE transfers
 	// get cleared in HW VSync, and may be needed for a buffered draw (FFX FMVs).
-	g_gs_renderer->Flush(GSState::VSYNC);
-	g_gs_renderer->VSync(field, registers_written, g_gs_renderer->IsIdleFrame());
+	if (g_gs_renderer)
+	{
+		g_gs_renderer->Flush(GSState::VSYNC);
+		g_gs_renderer->VSync(field, registers_written, g_gs_renderer->IsIdleFrame());
+	}
 }
 
 int GSfreeze(FreezeAction mode, freezeData* data)
 {
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+	{
+		if (mode == FreezeAction::Save)
+			return g_pgs_renderer->Freeze(data, false);
+		else if (mode == FreezeAction::Size)
+			return g_pgs_renderer->Freeze(data, true);
+		else // if (mode == FreezeAction::Load)
+			return g_pgs_renderer->Defrost(data);
+	}
+#endif
+
+	if (!g_gs_renderer)
+		return -1;
+
 	if (mode == FreezeAction::Save)
 	{
 		return g_gs_renderer->Freeze(data, false);
@@ -499,6 +655,10 @@ int GSfreeze(FreezeAction mode, freezeData* data)
 
 void GSQueueSnapshot(const std::string& path, u32 gsdump_frames)
 {
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		g_pgs_renderer->QueueSnapshot(GSGetBaseSnapshotFilename(), gsdump_frames);
+#endif
 	if (g_gs_renderer)
 		g_gs_renderer->QueueSnapshot(path, gsdump_frames);
 }
@@ -525,11 +685,15 @@ void GSEndCapture()
 
 void GSPresentCurrentFrame()
 {
-	g_gs_renderer->PresentCurrentFrame();
+	if (g_gs_renderer)
+		g_gs_renderer->PresentCurrentFrame();
 }
 
 void GSThrottlePresentation()
 {
+	if (!g_gs_device)
+		return;
+
 	if (g_gs_device->GetVSyncMode() == GSVSyncMode::FIFO)
 	{
 		// Let vsync take care of throttling.
@@ -550,25 +714,49 @@ void GSGameChanged()
 
 bool GSHasDisplayWindow()
 {
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		return g_pgs_renderer->GetWindowInfo().type != WindowInfo::Type::Surfaceless;
+#else
 	pxAssert(g_gs_device);
-	return (g_gs_device->GetWindowInfo().type != WindowInfo::Type::Surfaceless);
+#endif
+
+	if (g_gs_device)
+		return (g_gs_device->GetWindowInfo().type != WindowInfo::Type::Surfaceless);
+	else
+		return false;
 }
 
 void GSResizeDisplayWindow(int width, int height, float scale)
 {
-	g_gs_device->ResizeWindow(width, height, scale);
-	ImGuiManager::WindowResized();
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		g_pgs_renderer->ResizeWindow(width, height, scale);
+#endif
+	if (g_gs_device)
+	{
+		g_gs_device->ResizeWindow(width, height, scale);
+		ImGuiManager::WindowResized();
+	}
 }
 
 void GSUpdateDisplayWindow()
 {
-	if (!g_gs_device->UpdateWindow())
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+	{
+		g_pgs_renderer->UpdateWindow();
+	}
+#endif
+
+	if (g_gs_device && !g_gs_device->UpdateWindow())
 	{
 		Host::ReportErrorAsync("Error", "Failed to change window after update. The log may contain more information.");
 		return;
 	}
 
-	ImGuiManager::WindowResized();
+	if (g_gs_device)
+		ImGuiManager::WindowResized();
 }
 
 void GSSetVSyncMode(GSVSyncMode mode, bool allow_present_throttle)
@@ -580,7 +768,12 @@ void GSSetVSyncMode(GSVSyncMode mode, bool allow_present_throttle)
 	}};
 	Console.WriteLnFmt(Color_StrongCyan, "Setting vsync mode: {}{}", modes[static_cast<size_t>(mode)],
 		allow_present_throttle ? " (throttle allowed)" : "");
-	g_gs_device->SetVSyncMode(mode, allow_present_throttle);
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		g_pgs_renderer->SetVSyncMode(mode, allow_present_throttle);
+#endif
+	if (g_gs_device)
+		g_gs_device->SetVSyncMode(mode, allow_present_throttle);
 }
 
 bool GSWantsExclusiveFullscreen()
@@ -629,6 +822,19 @@ std::vector<GSAdapterInfo> GSGetAdapterInfo(GSRendererType renderer)
 		break;
 #endif
 
+#ifdef HAVE_PARALLEL_GS
+		case GSRendererType::ParallelGS:
+		{
+			// Dummy info.
+			GSAdapterInfo adapter = {};
+			adapter.name = "default";
+			adapter.fullscreen_modes = { "fullscreen" };
+			adapter.max_texture_size = 4096;
+			adapter.max_upscale_multiplier = 4;
+			return { adapter };
+		}
+#endif
+
 #ifdef __APPLE__
 		case GSRendererType::Metal:
 		{
@@ -652,13 +858,29 @@ u32 GSGetMaxUpscaleMultiplier(u32 max_texture_size)
 
 GSVideoMode GSgetDisplayMode()
 {
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		return GSVideoMode{};
+#endif
+
 	GSRenderer* gs = g_gs_renderer.get();
 
-	return gs->GetVideoMode();
+	if (gs)
+		return gs->GetVideoMode();
+	else
+		return GSVideoMode{};
 }
 
 void GSgetInternalResolution(int* width, int* height)
 {
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+	{
+		g_pgs_renderer->GetInternalResolution(width, height);
+		return;
+	}
+#endif
+
 	GSRenderer* gs = g_gs_renderer.get();
 	if (!gs)
 	{
@@ -756,8 +978,11 @@ void GSUpdateConfig(const Pcsx2Config::GSOptions& new_config)
 {
 	Pcsx2Config::GSOptions old_config(std::move(GSConfig));
 	GSConfig = new_config;
-	if (!g_gs_renderer)
-		return;
+
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		g_pgs_renderer->UpdateConfig();
+#endif
 
 	// Handle OSD scale changes by pushing a window resize through.
 	if (new_config.OsdScale != old_config.OsdScale)
@@ -771,6 +996,9 @@ void GSUpdateConfig(const Pcsx2Config::GSOptions& new_config)
 		return;
 	}
 
+	if (!g_gs_renderer)
+		return;
+
 	// Ensure upscale multiplier is in range.
 	GSClampUpscaleMultiplier(GSConfig);
 
diff --git a/pcsx2/GS/GS.h b/pcsx2/GS/GS.h
index 0ab827f0a..1bf01d984 100644
--- a/pcsx2/GS/GS.h
+++ b/pcsx2/GS/GS.h
@@ -20,6 +20,7 @@ enum class RenderAPI
 	Metal,
 	D3D12,
 	Vulkan,
+	Granite,
 	OpenGL
 };
 
@@ -109,6 +110,8 @@ bool GSSaveSnapshotToMemory(u32 window_width, u32 window_height, bool apply_aspe
 	u32* width, u32* height, std::vector<u32>* pixels);
 void GSJoinSnapshotThreads();
 
+float GetCurrentAspectRatioFloat(bool is_progressive);
+
 namespace Host
 {
 	/// Called when the GS is creating a render device.
diff --git a/pcsx2/GS/GSState.cpp b/pcsx2/GS/GSState.cpp
index 83068f15d..045201926 100644
--- a/pcsx2/GS/GSState.cpp
+++ b/pcsx2/GS/GSState.cpp
@@ -32,7 +32,7 @@ static __fi bool IsFirstProvokingVertex()
 	return (GSIsHardwareRenderer() && !g_gs_device->Features().provoking_vertex_last);
 }
 
-constexpr int GSState::GetSaveStateSize()
+int GSState::GetSaveStateSize()
 {
 	int size = 0;
 
diff --git a/pcsx2/GS/GSState.h b/pcsx2/GS/GSState.h
index 94f9a5442..5128a0043 100644
--- a/pcsx2/GS/GSState.h
+++ b/pcsx2/GS/GSState.h
@@ -21,7 +21,7 @@ public:
 	GSState();
 	virtual ~GSState();
 
-	static constexpr int GetSaveStateSize();
+	static int GetSaveStateSize();
 
 private:
 	// RESTRICT prevents multiple loads of the same part of the register when accessing its bitfields (the compiler is happy to know that memory writes in-between will not go there)
diff --git a/pcsx2/GS/GSUtil.cpp b/pcsx2/GS/GSUtil.cpp
index 63ae1db03..fdea62b2d 100644
--- a/pcsx2/GS/GSUtil.cpp
+++ b/pcsx2/GS/GSUtil.cpp
@@ -204,7 +204,9 @@ GSRendererType GSUtil::GetPreferredRenderer()
 	static GSRendererType preferred_renderer = GSRendererType::Auto;
 	if (preferred_renderer == GSRendererType::Auto)
 	{
-#if defined(__APPLE__)
+#if defined(HAVE_PARALLEL_GS)
+		preferred_renderer = GSRendererType::ParallelGS;
+#elif defined(__APPLE__)
 		// Mac: Prefer Metal hardware.
 		preferred_renderer = GSRendererType::Metal;
 #elif defined(_WIN32) && defined(_M_ARM64)
diff --git a/pcsx2/GS/Renderers/Common/GSRenderer.cpp b/pcsx2/GS/Renderers/Common/GSRenderer.cpp
index 2ac36da07..f373dc998 100644
--- a/pcsx2/GS/Renderers/Common/GSRenderer.cpp
+++ b/pcsx2/GS/Renderers/Common/GSRenderer.cpp
@@ -275,7 +275,7 @@ float GSRenderer::GetModXYOffset()
 	return 0.0f;
 }
 
-static float GetCurrentAspectRatioFloat(bool is_progressive)
+float GetCurrentAspectRatioFloat(bool is_progressive)
 {
 	static constexpr std::array<float, static_cast<size_t>(AspectRatioType::MaxCount) + 1> ars = {{4.0f / 3.0f, 4.0f / 3.0f, 4.0f / 3.0f, 16.0f / 9.0f, 3.0f / 2.0f}};
 	return ars[static_cast<u32>(GSConfig.AspectRatio) + (3u * (is_progressive && GSConfig.AspectRatio == AspectRatioType::RAuto4_3_3_2))];
diff --git a/pcsx2/GS/Renderers/Vulkan/VKLoader.cpp b/pcsx2/GS/Renderers/Vulkan/VKLoader.cpp
index e386e6fe5..c7d538135 100644
--- a/pcsx2/GS/Renderers/Vulkan/VKLoader.cpp
+++ b/pcsx2/GS/Renderers/Vulkan/VKLoader.cpp
@@ -16,6 +16,8 @@
 
 extern "C" {
 
+#ifndef HAVE_PARALLEL_GS
+// Crude hack, but this conflicts with volk.
 #define VULKAN_MODULE_ENTRY_POINT(name, required) PFN_##name name;
 #define VULKAN_INSTANCE_ENTRY_POINT(name, required) PFN_##name name;
 #define VULKAN_DEVICE_ENTRY_POINT(name, required) PFN_##name name;
@@ -23,6 +25,7 @@ extern "C" {
 #undef VULKAN_DEVICE_ENTRY_POINT
 #undef VULKAN_INSTANCE_ENTRY_POINT
 #undef VULKAN_MODULE_ENTRY_POINT
+#endif
 }
 
 void Vulkan::ResetVulkanLibraryFunctionPointers()
@@ -79,7 +82,10 @@ bool Vulkan::LoadVulkanLibrary(Error* error)
 
 	if (required_functions_missing)
 	{
+#ifndef HAVE_PARALLEL_GS
+		// FIXME: parallel-gs share volk global pointers.
 		ResetVulkanLibraryFunctionPointers();
+#endif
 		s_vulkan_library.Close();
 		return false;
 	}
@@ -89,7 +95,10 @@ bool Vulkan::LoadVulkanLibrary(Error* error)
 
 void Vulkan::UnloadVulkanLibrary()
 {
+#ifndef HAVE_PARALLEL_GS
+	// FIXME: parallel-gs share volk global pointers.
 	ResetVulkanLibraryFunctionPointers();
+#endif
 	s_vulkan_library.Close();
 }
 
@@ -97,8 +106,13 @@ bool Vulkan::LoadVulkanInstanceFunctions(VkInstance instance)
 {
 	bool required_functions_missing = false;
 	auto LoadFunction = [&required_functions_missing, instance](PFN_vkVoidFunction* func_ptr, const char* name, bool is_required) {
-		*func_ptr = vkGetInstanceProcAddr(instance, name);
-		if (!(*func_ptr) && is_required)
+		auto proc = vkGetInstanceProcAddr(instance, name);
+		// Only override the global pointer if the pointer is non-null. This avoids a problem where GetAdapters()
+		// tries to load KHR_surface functions but fails since VK_KHR_surface is not enabled.
+		// Temporary hack for parallel-gs interoperability since they share volk implementation.
+		if (proc)
+			*func_ptr = proc;
+		if (!proc && is_required)
 		{
 			std::fprintf(stderr, "Vulkan: Failed to load required instance function %s\n", name);
 			required_functions_missing = true;
diff --git a/pcsx2/GS/Renderers/Vulkan/VKLoader.h b/pcsx2/GS/Renderers/Vulkan/VKLoader.h
index 736723fca..cfba3a7c9 100644
--- a/pcsx2/GS/Renderers/Vulkan/VKLoader.h
+++ b/pcsx2/GS/Renderers/Vulkan/VKLoader.h
@@ -7,24 +7,7 @@ class Error;
 
 #define VK_NO_PROTOTYPES
 
-#ifdef _WIN32
-#define VK_USE_PLATFORM_WIN32_KHR
-
-// vulkan.h pulls in windows.h on Windows, so we need to include our replacement header first
-#include "common/RedtapeWindows.h"
-#endif
-
-#if defined(X11_API)
-#define VK_USE_PLATFORM_XLIB_KHR
-#endif
-
-#if defined(WAYLAND_API)
-#define VK_USE_PLATFORM_WAYLAND_KHR
-#endif
-
-#if defined(__APPLE__)
-#define VK_USE_PLATFORM_METAL_EXT
-#endif
+#include "VKLoaderPlatformDefines.h"
 
 #include "vulkan/vulkan.h"
 
diff --git a/pcsx2/GS/Renderers/Vulkan/VKLoaderPlatformDefines.h b/pcsx2/GS/Renderers/Vulkan/VKLoaderPlatformDefines.h
new file mode 100644
index 000000000..d3447f6f7
--- /dev/null
+++ b/pcsx2/GS/Renderers/Vulkan/VKLoaderPlatformDefines.h
@@ -0,0 +1,23 @@
+// SPDX-FileCopyrightText: 2002-2024 PCSX2 Dev Team
+// SPDX-License-Identifier: LGPL-3.0+
+#pragma once
+
+#ifdef _WIN32
+#define VK_USE_PLATFORM_WIN32_KHR
+
+// vulkan.h pulls in windows.h on Windows, so we need to include our replacement header first
+#include "common/RedtapeWindows.h"
+#endif
+
+#if defined(X11_API)
+#define VK_USE_PLATFORM_XLIB_KHR
+#endif
+
+#if defined(WAYLAND_API)
+#define VK_USE_PLATFORM_WAYLAND_KHR
+#endif
+
+#if defined(__APPLE__)
+#define VK_USE_PLATFORM_METAL_EXT
+#endif
+
diff --git a/pcsx2/GS/Renderers/parallel-gs/GSRendererPGS.cpp b/pcsx2/GS/Renderers/parallel-gs/GSRendererPGS.cpp
new file mode 100644
index 000000000..63072d6f5
--- /dev/null
+++ b/pcsx2/GS/Renderers/parallel-gs/GSRendererPGS.cpp
@@ -0,0 +1,760 @@
+// SPDX-FileCopyrightText: 2024 Hans-Kristian Arntzen
+// SPDX-License-Identifier: LGPL-3.0+
+
+#include "GSRendererPGS.h"
+#include "GS/GSState.h"
+#include "GS.h"
+#include "math.hpp"
+#include "muglm/muglm_impl.hpp"
+#include "shaders/slangmosh.hpp"
+#include "PerformanceMetrics.h"
+#include "VMManager.h"
+
+// Workaround because msbuild is broken when mixing C and C++ it seems ...
+#ifdef _MSC_VER
+extern "C" {
+#include "volk.c"
+}
+#endif
+
+using namespace Vulkan;
+using namespace ParallelGS;
+using namespace Granite;
+
+static void FsrEasuCon(
+	float *con0,
+	float *con1,
+	float *con2,
+	float *con3,
+	float inputViewportInPixelsX,
+	float inputViewportInPixelsY,
+	float inputSizeInPixelsX,
+	float inputSizeInPixelsY,
+	float outputSizeInPixelsX,
+	float outputSizeInPixelsY)
+{
+	// Output integer position to a pixel position in viewport.
+	con0[0] = inputViewportInPixelsX / outputSizeInPixelsX;
+	con0[1] = inputViewportInPixelsY / outputSizeInPixelsY;
+	con0[2] = 0.5f * inputViewportInPixelsX / outputSizeInPixelsX - 0.5f;
+	con0[3] = 0.5f * inputViewportInPixelsY / outputSizeInPixelsY - 0.5f;
+	con1[0] = 1.0f / inputSizeInPixelsX;
+	con1[1] = 1.0f / inputSizeInPixelsY;
+	con1[2] = 1.0f / inputSizeInPixelsX;
+	con1[3] = -1.0f / inputSizeInPixelsY;
+	con2[0] = -1.0f / inputSizeInPixelsX;
+	con2[1] = 2.0f / inputSizeInPixelsY;
+	con2[2] = 1.0f / inputSizeInPixelsX;
+	con2[3] = 2.0f / inputSizeInPixelsY;
+	con3[0] = 0.0f / inputSizeInPixelsX;
+	con3[1] = 4.0f / inputSizeInPixelsY;
+	con3[2] = con3[3] = 0.0f;
+}
+
+static void FsrRcasCon(float *con, float sharpness)
+{
+	sharpness = muglm::exp2(-sharpness);
+	uint32_t half = floatToHalf(sharpness);
+	con[0] = sharpness;
+	uint32_t halves = half | (half << 16);
+	memcpy(&con[1], &halves, sizeof(halves));
+	con[2] = 0.0f;
+	con[3] = 0.0f;
+}
+
+void GSRendererPGS::render_fsr(CommandBuffer &cmd, const ImageView &view)
+{
+	cmd.image_barrier(*fsr_render_target,
+		VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,
+		VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, 0,
+		VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT);
+
+	RenderPassInfo rp = {};
+	rp.num_color_attachments = 1;
+	rp.color_attachments[0] = &fsr_render_target->get_view();
+	rp.store_attachments = 1u << 0;
+
+	cmd.begin_render_pass(rp);
+	{
+		struct Constants
+		{
+			float params[4][4];
+		} constants;
+
+		struct Push
+		{
+			float width, height;
+		} push;
+
+		auto width = float(view.get_image().get_width());
+		auto height = float(view.get_image().get_height());
+		auto *params = cmd.allocate_typed_constant_data<Constants>(1, 0, 1);
+		FsrEasuCon(constants.params[0], constants.params[1], constants.params[2], constants.params[3],
+			width, height, width, height, cmd.get_viewport().width, cmd.get_viewport().height);
+		*params = constants;
+
+		push.width = cmd.get_viewport().width;
+		push.height = cmd.get_viewport().height;
+		cmd.push_constants(&push, 0, sizeof(push));
+
+		const vec2 vertex_data[] = { vec2(-1.0f, -1.0f), vec2(-1.0f, 3.0f), vec2(3.0f, -1.0f) };
+		memcpy(cmd.allocate_vertex_data(0, sizeof(vertex_data), sizeof(vec2)), vertex_data, sizeof(vertex_data));
+		cmd.set_vertex_attrib(0, 0, VK_FORMAT_R32G32_SFLOAT, 0);
+
+		cmd.set_texture(0, 0, view, StockSampler::NearestClamp);
+
+		cmd.set_program(upscale_program);
+		cmd.set_opaque_state();
+		cmd.set_depth_test(false, false);
+		cmd.draw(3);
+	}
+	cmd.end_render_pass();
+
+	cmd.image_barrier(*fsr_render_target,
+		VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
+		VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,
+		VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, VK_ACCESS_2_SHADER_SAMPLED_READ_BIT);
+}
+
+void GSRendererPGS::render_rcas(CommandBuffer &cmd, const ImageView &view,
+                                float offset_x, float offset_y,
+                                float width, float height)
+{
+	struct Constants
+	{
+		float params[4];
+		int32_t range[4];
+	} constants;
+
+	FsrRcasCon(constants.params, 0.5f);
+	constants.range[0] = 0;
+	constants.range[1] = 0;
+	constants.range[2] = int(view.get_view_width()) - 1;
+	constants.range[3] = int(view.get_view_height()) - 1;
+	auto *params = cmd.allocate_typed_constant_data<Constants>(1, 0, 1);
+	*params = constants;
+
+	const vec2 vertex_data[] = { vec2(-1.0f, -1.0f), vec2(-1.0f, 3.0f), vec2(3.0f, -1.0f) };
+	memcpy(cmd.allocate_vertex_data(0, sizeof(vertex_data), sizeof(vec2)), vertex_data, sizeof(vertex_data));
+	cmd.set_vertex_attrib(0, 0, VK_FORMAT_R32G32_SFLOAT, 0);
+	cmd.set_srgb_texture(0, 0, view);
+	cmd.set_sampler(0, 0, Vulkan::StockSampler::NearestClamp);
+	cmd.set_opaque_state();
+	cmd.set_depth_test(false, false);
+	cmd.set_program(sharpen_program);
+
+	cmd.set_viewport({ offset_x, offset_y, width, height, 0.0f, 1.0f });
+	cmd.draw(3);
+}
+
+void GSRendererPGS::render_blit(CommandBuffer &cmd, const ImageView &view,
+                                float offset_x, float offset_y,
+                                float width, float height)
+{
+	cmd.set_srgb_texture(0, 0, view);
+	cmd.set_sampler(0, 0, GSConfig.LinearPresent != GSPostBilinearMode::Off ?
+	                      Vulkan::StockSampler::LinearClamp : Vulkan::StockSampler::NearestClamp);
+	cmd.set_opaque_state();
+	cmd.set_depth_test(false, false);
+	cmd.set_program(blit_program);
+
+	cmd.set_viewport({ offset_x, offset_y, width, height, 0.0f, 1.0f });
+	cmd.draw(3);
+}
+
+GSRendererPGS::GSRendererPGS(u8 *basemem)
+	: priv(reinterpret_cast<PrivRegisterState *>(basemem))
+{
+	wsi.set_backbuffer_format(BackbufferFormat::sRGB);
+}
+
+u8 *GSRendererPGS::GetRegsMem()
+{
+	return reinterpret_cast<u8 *>(priv);
+}
+
+bool GSRendererPGS::Init()
+{
+	// Always force the reload, since the other backends may clobber the volk pointers.
+	if (!Context::init_loader(nullptr, true))
+		return false;
+
+	wsi.set_platform(this);
+	bool ret = wsi.init_simple(1, {});
+	if (!ret)
+		return false;
+
+	// We will cycle through many memory contexts per frame most likely.
+	wsi.get_device().init_frame_contexts(12);
+
+	ResourceLayout layout;
+	Shaders<> suite(wsi.get_device(), layout, 0);
+	upscale_program = wsi.get_device().request_program(suite.upscale_vert, suite.upscale_frag);
+	sharpen_program = wsi.get_device().request_program(suite.sharpen_vert, suite.sharpen_frag);
+	blit_program = wsi.get_device().request_program(suite.quad, suite.blit);
+
+	GSOptions opts = {};
+	opts.vram_size = GSLocalMemory::m_vmsize;
+
+	u8 super_sampling = GSConfig.PGSSuperSampling;
+	if (super_sampling > 4)
+		super_sampling = 4;
+	opts.super_sampling = SuperSampling(1u << super_sampling);
+	opts.dynamic_super_sampling = true;
+	if (!iface.init(&wsi.get_device(), opts))
+		return false;
+
+	current_super_sampling = opts.super_sampling;
+
+	return true;
+}
+
+void GSRendererPGS::UpdateConfig()
+{
+	u8 super_sampling = GSConfig.PGSSuperSampling;
+	if (super_sampling > 4)
+		super_sampling = 4;
+	auto new_super_sampling = SuperSampling(1u << super_sampling);
+
+	if (new_super_sampling != current_super_sampling)
+	{
+		iface.set_super_sampling_rate(new_super_sampling);
+		current_super_sampling = new_super_sampling;
+	}
+}
+
+int GSRendererPGS::GetSaveStateSize()
+{
+	return GSState::GetSaveStateSize();
+}
+
+static void write_data(u8*& dst, const void* src, size_t size)
+{
+	memcpy(dst, src, size);
+	dst += size;
+}
+
+template <typename T>
+static void write_reg(u8*& data, T t)
+{
+	write_data(data, &t, sizeof(t));
+}
+
+static void read_data(const u8*& src, void* dst, size_t size)
+{
+	memcpy(dst, src, size);
+	src += size;
+}
+
+template <typename T>
+static void read_reg(const u8*& src, T &t)
+{
+	read_data(src, &t, sizeof(t));
+}
+
+int GSRendererPGS::Freeze(freezeData* data, bool sizeonly)
+{
+	if (sizeonly)
+	{
+		data->size = GetSaveStateSize();
+		return 0;
+	}
+
+	if (!data->data || data->size < GetSaveStateSize())
+		return -1;
+
+	const void *vram = iface.map_vram_read(0, GSLocalMemory::m_vmsize);
+	auto &regs = iface.get_register_state();
+
+	u8 *ptr = data->data;
+
+	write_reg(ptr, GSState::STATE_VERSION);
+	write_reg(ptr, regs.prim);
+	write_reg(ptr, regs.prmodecont);
+	write_reg(ptr, regs.texclut);
+	write_reg(ptr, regs.scanmsk);
+	write_reg(ptr, regs.texa);
+	write_reg(ptr, regs.fogcol);
+	write_reg(ptr, regs.dimx);
+	write_reg(ptr, regs.dthe);
+	write_reg(ptr, regs.colclamp);
+	write_reg(ptr, regs.pabe);
+	write_reg(ptr, regs.bitbltbuf);
+	write_reg(ptr, regs.trxdir);
+	write_reg(ptr, regs.trxpos);
+	write_reg(ptr, regs.trxreg);
+	write_reg(ptr, regs.trxreg); // Dummy value
+
+	for (const auto &ctx : regs.ctx)
+	{
+		write_reg(ptr, ctx.xyoffset);
+		write_reg(ptr, ctx.tex0);
+		write_reg(ptr, ctx.tex1);
+		write_reg(ptr, ctx.clamp);
+		write_reg(ptr, ctx.miptbl_1_3);
+		write_reg(ptr, ctx.miptbl_4_6);
+		write_reg(ptr, ctx.scissor);
+		write_reg(ptr, ctx.alpha);
+		write_reg(ptr, ctx.test);
+		write_reg(ptr, ctx.fba);
+		write_reg(ptr, ctx.frame);
+		write_reg(ptr, ctx.zbuf);
+	}
+
+	write_reg(ptr, regs.rgbaq);
+	write_reg(ptr, regs.st);
+	write_reg(ptr, regs.uv.words[0]);
+	write_reg(ptr, regs.fog.words[0]);
+	// XYZ register, fill with dummy.
+	write_reg(ptr, Reg64<XYZBits>{0});
+
+	write_reg(ptr, UINT32_MAX); // Dummy GIFReg
+	write_reg(ptr, UINT32_MAX);
+
+	// Dummy transfer X/Y
+	write_reg(ptr, uint32_t(0));
+	write_reg(ptr, uint32_t(0));
+
+	write_data(ptr, vram, GSLocalMemory::m_vmsize);
+
+	// 4 GIF paths
+	for (int i = 0; i < 4; i++)
+	{
+		auto gif_path = iface.get_gif_path(i);
+		gif_path.tag.NLOOP -= gif_path.loop;
+		write_data(ptr, &gif_path.tag, sizeof(gif_path.tag));
+		write_reg(ptr, gif_path.reg);
+	}
+
+	// internal_Q
+	write_reg(ptr, regs.internal_q);
+	return 0;
+}
+
+int GSRendererPGS::Defrost(freezeData* data)
+{
+	if (!data || !data->data || data->size == 0)
+		return -1;
+
+	if (data->size < GetSaveStateSize())
+		return -1;
+
+	const u8* ptr = data->data;
+	auto &regs = iface.get_register_state();
+
+	u32 version;
+	read_reg(ptr, version);
+
+	if (version != GSState::STATE_VERSION)
+	{
+		Console.Error("GS: Savestate version is incompatible.  Load aborted.");
+		return -1;
+	}
+
+	read_reg(ptr, regs.prim);
+	read_reg(ptr, regs.prmodecont);
+	read_reg(ptr, regs.texclut);
+	read_reg(ptr, regs.scanmsk);
+	read_reg(ptr, regs.texa);
+	read_reg(ptr, regs.fogcol);
+	read_reg(ptr, regs.dimx);
+	read_reg(ptr, regs.dthe);
+	read_reg(ptr, regs.colclamp);
+	read_reg(ptr, regs.pabe);
+	read_reg(ptr, regs.bitbltbuf);
+	read_reg(ptr, regs.trxdir);
+	read_reg(ptr, regs.trxpos);
+	read_reg(ptr, regs.trxreg);
+	// Dummy value
+	ptr += sizeof(uint64_t);
+
+	for (auto &ctx : regs.ctx)
+	{
+		read_reg(ptr, ctx.xyoffset);
+		read_reg(ptr, ctx.tex0);
+		read_reg(ptr, ctx.tex1);
+		read_reg(ptr, ctx.clamp);
+		read_reg(ptr, ctx.miptbl_1_3);
+		read_reg(ptr, ctx.miptbl_4_6);
+		read_reg(ptr, ctx.scissor);
+		read_reg(ptr, ctx.alpha);
+		read_reg(ptr, ctx.test);
+		read_reg(ptr, ctx.fba);
+		read_reg(ptr, ctx.frame);
+		read_reg(ptr, ctx.zbuf);
+	}
+
+	read_reg(ptr, regs.rgbaq);
+	read_reg(ptr, regs.st);
+	read_reg(ptr, regs.uv.words[0]);
+	read_reg(ptr, regs.fog.words[0]);
+	// XYZ register, fill with dummy.
+	ptr += sizeof(uint64_t);
+
+	// Dummy GIFReg
+	ptr += 2 * sizeof(uint32_t);
+
+	// Dummy transfer X/Y
+	ptr += 2 * sizeof(uint32_t);
+
+	void *vram = iface.map_vram_write(0, GSLocalMemory::m_vmsize);
+	read_data(ptr, vram, GSLocalMemory::m_vmsize);
+	iface.end_vram_write(0, GSLocalMemory::m_vmsize);
+
+	// 4 GIF paths
+	for (int i = 0; i < 4; i++)
+	{
+		auto gif_path = iface.get_gif_path(i);
+		gif_path.tag.NLOOP -= gif_path.loop;
+		read_data(ptr, &gif_path.tag, sizeof(gif_path.tag));
+		gif_path.loop = 0;
+		read_reg(ptr, gif_path.reg);
+	}
+
+	// internal_Q
+	read_reg(ptr, iface.get_register_state().internal_q);
+
+	iface.clobber_register_state();
+	return 0;
+}
+
+void GSRendererPGS::VSync(u32 field, bool registers_written)
+{
+	if (dump)
+	{
+		if (dump->VSync(field, dump_frames == 0, reinterpret_cast<GSPrivRegSet *>(priv)))
+			dump.reset();
+		else if (dump_frames != 0)
+			dump_frames--;
+	}
+
+	iface.flush();
+	iface.get_priv_register_state() = *priv;
+
+	VSyncInfo info = {};
+
+	info.phase = field;
+	info.anti_blur = GSConfig.PCRTCAntiBlur;
+	info.force_progressive = true;
+	info.overscan = GSConfig.PCRTCOverscan;
+	info.crtc_offsets = GSConfig.PCRTCOffsets;
+	info.dst_access = VK_ACCESS_2_SHADER_SAMPLED_READ_BIT;
+	info.dst_stage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;
+	info.dst_layout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
+	// The scaling blur is technically a blur ...
+	info.adapt_to_internal_horizontal_resolution = GSConfig.PCRTCAntiBlur;
+	info.raw_circuit_scanout = true;
+	auto vsync = iface.vsync(info);
+
+	auto stats = iface.consume_flush_stats();
+	if (GSConfig.SkipDuplicateFrames && has_presented_in_current_swapchain &&
+	    !registers_written && stats.num_render_passes == 0 && stats.num_copies == 0)
+	{
+		PerformanceMetrics::Update(false, false, true);
+		return;
+	}
+
+	if (vsync.image)
+	{
+		last_internal_width = vsync.internal_width;
+		last_internal_height = vsync.internal_height;
+	}
+
+	if (!has_wsi_begin_frame)
+		has_wsi_begin_frame = wsi.begin_frame();
+
+	if (!has_wsi_begin_frame)
+		return;
+
+	auto &dev = wsi.get_device();
+
+	float vp_offset_x = 0.0f;
+	float vp_offset_y = 0.0f;
+	float vp_width = 0.0f;
+	float vp_height = 0.0f;
+
+	if (GSConfig.LinearPresent != GSPostBilinearMode::BilinearSharp)
+		fsr_render_target.reset();
+
+	if (vsync.image)
+	{
+		uint32_t fsr_width = dev.get_swapchain_view().get_view_width();
+		uint32_t fsr_height = dev.get_swapchain_view().get_view_height();
+		uint32_t new_width = fsr_width;
+		uint32_t new_height = fsr_height;
+
+		float display_aspect = float(fsr_width) / float(fsr_height);
+		float game_aspect = GetCurrentAspectRatioFloat(priv->smode1.CMOD == 0);
+
+		float horizontal_scanout_ratio = float(vsync.internal_width) / float(vsync.mode_width);
+		float vertical_scanout_ratio = float(vsync.internal_height) / float(vsync.mode_height);
+		game_aspect *= horizontal_scanout_ratio / vertical_scanout_ratio;
+
+		if (display_aspect > game_aspect)
+			new_width = uint32_t(std::round(float(fsr_height) * game_aspect));
+		else
+			new_height = uint32_t(std::round(float(fsr_width) / game_aspect));
+
+		// This won't preserve the aspect ratio necessarily, but eh.
+		if (GSConfig.IntegerScaling)
+		{
+			new_width -= new_width % vsync.image->get_width();
+			new_height -= new_height % vsync.image->get_height();
+			if (new_width == 0)
+				new_width = fsr_width;
+			if (new_height == 0)
+				new_height = fsr_height;
+		}
+
+		vp_offset_x = std::round(0.5f * float(fsr_width - new_width));
+		fsr_width = new_width;
+		vp_offset_y = std::round(0.5f * float(fsr_height - new_height));
+		fsr_height = new_height;
+
+		// Safeguard against ridiculous situations.
+		if (!fsr_width)
+			fsr_width = 1;
+		if (!fsr_height)
+			fsr_height = 1;
+
+		vp_width = float(fsr_width);
+		vp_height = float(fsr_height);
+
+		if (GSConfig.LinearPresent == GSPostBilinearMode::BilinearSharp)
+		{
+			if (!fsr_render_target || fsr_render_target->get_width() != fsr_width || fsr_render_target->get_height() != fsr_height)
+			{
+				auto fsr_info = ImageCreateInfo::render_target(fsr_width, fsr_height, VK_FORMAT_R8G8B8A8_UNORM);
+				fsr_info.initial_layout = VK_IMAGE_LAYOUT_UNDEFINED;
+				fsr_info.usage |= VK_IMAGE_USAGE_SAMPLED_BIT;
+				fsr_info.misc |= IMAGE_MISC_MUTABLE_SRGB_BIT;
+				fsr_render_target = dev.create_image(fsr_info);
+			}
+		}
+	}
+
+	auto cmd = dev.request_command_buffer();
+	if (vsync.image && fsr_render_target)
+		render_fsr(*cmd, vsync.image->get_view());
+	cmd->begin_render_pass(dev.get_swapchain_render_pass(SwapchainRenderPass::ColorOnly));
+	if (vsync.image)
+	{
+		if (fsr_render_target)
+			render_rcas(*cmd, fsr_render_target->get_view(), vp_offset_x, vp_offset_y, vp_width, vp_height);
+		else
+			render_blit(*cmd, vsync.image->get_view(), vp_offset_x, vp_offset_y, vp_width, vp_height);
+	}
+	cmd->end_render_pass();
+	dev.submit(cmd);
+
+	wsi.end_frame();
+	has_wsi_begin_frame = false;
+	// For pacing purposes.
+	has_wsi_begin_frame = wsi.begin_frame();
+	has_presented_in_current_swapchain = true;
+
+	PerformanceMetrics::Update(registers_written, stats.num_render_passes != 0, false);
+}
+
+void GSRendererPGS::Transfer(const u8* mem, u32 size)
+{
+	size *= 16;
+	iface.gif_transfer(3, mem, size);
+	if (dump)
+		dump->Transfer(3, mem, size);
+}
+
+void GSRendererPGS::ReadFIFO(u8 *mem, u32 size)
+{
+	iface.read_transfer_fifo(mem, size);
+	if (dump)
+		dump->ReadFIFO(size);
+}
+
+void GSRendererPGS::GetInternalResolution(int *width, int *height)
+{
+	*width = int(last_internal_width);
+	*height = int(last_internal_height);
+}
+
+bool GSRendererPGS::UpdateWindow()
+{
+	iface.flush();
+
+	std::optional<WindowInfo> window = Host::AcquireRenderWindow(true);
+	if (window.has_value())
+	{
+		window_info = window.value();
+		wsi.deinit_surface_and_swapchain();
+		return wsi.init_surface_swapchain();
+	}
+	else
+		return false;
+}
+
+void GSRendererPGS::ResizeWindow(int width, int height, float /*scale*/)
+{
+	resize = true;
+	window_info.surface_width = width;
+	window_info.surface_height = height;
+	// TODO: No idea what to do about scale.
+}
+
+const WindowInfo &GSRendererPGS::GetWindowInfo() const
+{
+	return window_info;
+}
+
+void GSRendererPGS::SetVSyncMode(GSVSyncMode mode, bool /*allow_present_throttle*/)
+{
+	if (mode == GSVSyncMode::FIFO)
+		wsi.set_present_mode(PresentMode::SyncToVBlank);
+	else if (mode == GSVSyncMode::Mailbox)
+		wsi.set_present_mode(PresentMode::UnlockedNoTearing);
+	else
+		wsi.set_present_mode(PresentMode::UnlockedMaybeTear);
+	// Unknown what allow_present_throttle means.
+}
+
+VkSurfaceKHR GSRendererPGS::create_surface(VkInstance instance, VkPhysicalDevice gpu)
+{
+	if (window_info.type == WindowInfo::Type::Surfaceless)
+	{
+		std::optional<WindowInfo> window = Host::AcquireRenderWindow(true);
+		if (window.has_value())
+			window_info = window.value();
+	}
+
+	if (window_info.type == WindowInfo::Type::Surfaceless)
+		return VK_NULL_HANDLE;
+
+#if defined(X11_API)
+	if (window_info.type == WindowInfo::Type::X11)
+	{
+		VkXlibSurfaceCreateInfoKHR info = { VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR };
+		info.dpy = static_cast<Display *>(window_info.display_connection);
+		info.window = reinterpret_cast<Window>(window_info.window_handle);
+		VkSurfaceKHR surface;
+		if (vkCreateXlibSurfaceKHR(instance, &info, nullptr, &surface) == VK_SUCCESS)
+			return surface;
+	}
+#endif
+#if defined(WAYLAND_API)
+	if (window_info.type == WindowInfo::Type::Wayland)
+	{
+		VkWaylandSurfaceCreateInfoKHR info = { VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR };
+		info.display = static_cast<wl_display *>(window_info.display_connection);
+		info.surface = static_cast<wl_surface *>(window_info.window_handle);
+		VkSurfaceKHR surface;
+		if (vkCreateWaylandSurfaceKHR(instance, &info, nullptr, &surface) == VK_SUCCESS)
+			return surface;
+	}
+#endif
+#if defined(_WIN32)
+	if (window_info.type == WindowInfo::Type::Win32)
+	{
+		VkWin32SurfaceCreateInfoKHR info = { VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR };
+		info.hwnd = static_cast<HWND>(window_info.window_handle);
+		VkSurfaceKHR surface;
+		if (vkCreateWin32SurfaceKHR(instance, &info, nullptr, &surface) == VK_SUCCESS)
+			return surface;
+	}
+#endif
+
+	return VK_NULL_HANDLE;
+}
+
+void GSRendererPGS::destroy_surface(VkInstance instance, VkSurfaceKHR surface)
+{
+	WSIPlatform::destroy_surface(instance, surface);
+}
+
+std::vector<const char *> GSRendererPGS::get_instance_extensions()
+{
+	return {
+		VK_KHR_SURFACE_EXTENSION_NAME,
+#if defined(X11_API)
+		VK_KHR_XLIB_SURFACE_EXTENSION_NAME,
+#endif
+#if defined(WAYLAND_API)
+		VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME,
+#endif
+#if defined(_WIN32)
+		VK_KHR_WIN32_SURFACE_EXTENSION_NAME,
+#endif
+	};
+}
+
+std::vector<const char *> GSRendererPGS::get_device_extensions()
+{
+	return { VK_KHR_SWAPCHAIN_EXTENSION_NAME };
+}
+
+bool GSRendererPGS::alive(WSI &)
+{
+	return true;
+}
+
+uint32_t GSRendererPGS::get_surface_width()
+{
+	return window_info.surface_width;
+}
+
+uint32_t GSRendererPGS::get_surface_height()
+{
+	return window_info.surface_height;
+}
+
+void GSRendererPGS::poll_input()
+{
+	// Dummy, we don't care about input here.
+}
+
+void GSRendererPGS::poll_input_async(Granite::InputTrackerHandler *)
+{
+	// Dummy, we don't care about input here.
+}
+
+void GSRendererPGS::event_swapchain_destroyed()
+{
+	WSIPlatform::event_swapchain_destroyed();
+	has_wsi_begin_frame = false;
+	has_presented_in_current_swapchain = false;
+}
+
+void GSRendererPGS::QueueSnapshot(const std::string &path, u32 gsdump_frames)
+{
+	freezeData fd = {0, nullptr};
+	Freeze(&fd, true);
+	fd.data = new u8[fd.size];
+	Freeze(&fd, false);
+
+	if (GSConfig.GSDumpCompression == GSDumpCompressionMethod::Uncompressed)
+	{
+		dump = GSDumpBase::CreateUncompressedDump(path, VMManager::GetDiscSerial(),
+		                                          VMManager::GetDiscCRC(), 0, 0,
+		                                          nullptr, fd, reinterpret_cast<GSPrivRegSet *>(priv));
+	}
+	else if (GSConfig.GSDumpCompression == GSDumpCompressionMethod::LZMA)
+	{
+		dump = GSDumpBase::CreateXzDump(path, VMManager::GetDiscSerial(),
+		                                VMManager::GetDiscCRC(), 0, 0,
+		                                nullptr, fd, reinterpret_cast<GSPrivRegSet *>(priv));
+	}
+	else
+	{
+		dump = GSDumpBase::CreateZstDump(path, VMManager::GetDiscSerial(),
+		                                 VMManager::GetDiscCRC(), 0, 0,
+		                                 nullptr, fd, reinterpret_cast<GSPrivRegSet *>(priv));
+	}
+
+	dump_frames = gsdump_frames;
+	delete[] fd.data;
+}
+
+const VkApplicationInfo *GSRendererPGS::get_application_info()
+{
+	static const VkApplicationInfo app = { VK_STRUCTURE_TYPE_APPLICATION_INFO, nullptr,
+	                                       "pcsx2", 0, "Granite", 0, VK_API_VERSION_1_3 };
+	return &app;
+}
diff --git a/pcsx2/GS/Renderers/parallel-gs/GSRendererPGS.h b/pcsx2/GS/Renderers/parallel-gs/GSRendererPGS.h
new file mode 100644
index 000000000..289b97483
--- /dev/null
+++ b/pcsx2/GS/Renderers/parallel-gs/GSRendererPGS.h
@@ -0,0 +1,84 @@
+// SPDX-FileCopyrightText: 2024 Hans-Kristian Arntzen
+// SPDX-License-Identifier: LGPL-3.0+
+
+#pragma once
+
+#include "../Vulkan/VKLoaderPlatformDefines.h"
+#include "SaveState.h"
+#include "GS/GSDump.h"
+#include "Config.h"
+#include "common/WindowInfo.h"
+#include "gs_interface.hpp"
+#include "device.hpp"
+#include "context.hpp"
+#include "wsi.hpp"
+
+class GSRendererPGS final : private Vulkan::WSIPlatform
+{
+public:
+	explicit GSRendererPGS(u8 *basemem);
+
+	bool Init();
+	bool UpdateWindow();
+	void ResizeWindow(int width, int height, float scale);
+	const WindowInfo &GetWindowInfo() const;
+	void SetVSyncMode(GSVSyncMode mode, bool allow_present_throttle);
+
+	void Transfer(const u8 *mem, u32 size);
+
+	void VSync(u32 field, bool registers_written);
+	inline ParallelGS::GSInterface &get_interface() { return iface; };
+	void ReadFIFO(u8 *mem, u32 size);
+
+	void UpdateConfig();
+
+	void GetInternalResolution(int *width, int *height);
+
+	int Freeze(freezeData *data, bool sizeonly);
+	int Defrost(freezeData *data);
+
+	u8 *GetRegsMem();
+
+	void QueueSnapshot(const std::string &path, u32 gsdump_frames);
+
+private:
+	VkSurfaceKHR create_surface(VkInstance instance, VkPhysicalDevice gpu) override;
+	void destroy_surface(VkInstance instance, VkSurfaceKHR surface) override;
+	std::vector<const char *> get_instance_extensions() override;
+	std::vector<const char *> get_device_extensions() override;
+	bool alive(Vulkan::WSI &wsi) override;
+	uint32_t get_surface_width() override;
+	uint32_t get_surface_height() override;
+	void poll_input() override;
+	void poll_input_async(Granite::InputTrackerHandler *) override;
+
+	ParallelGS::PrivRegisterState *priv;
+	Vulkan::WSI wsi;
+	ParallelGS::GSInterface iface;
+	WindowInfo window_info = {};
+	bool has_wsi_begin_frame = false;
+
+	Vulkan::Program *upscale_program = nullptr;
+	Vulkan::Program *sharpen_program = nullptr;
+	Vulkan::Program *blit_program = nullptr;
+	void render_fsr(Vulkan::CommandBuffer &cmd, const Vulkan::ImageView &view);
+	void render_rcas(Vulkan::CommandBuffer &cmd, const Vulkan::ImageView &view,
+	                 float offset_x, float offset_y,
+	                 float width, float height);
+	void render_blit(Vulkan::CommandBuffer &cmd, const Vulkan::ImageView &view,
+	                 float offset_x, float offset_y,
+	                 float width, float height);
+	void event_swapchain_destroyed() override;
+	Vulkan::ImageHandle fsr_render_target;
+
+	ParallelGS::SuperSampling current_super_sampling = ParallelGS::SuperSampling::X1;
+	bool has_presented_in_current_swapchain = false;
+	uint32_t last_internal_width = 0;
+	uint32_t last_internal_height = 0;
+
+	static int GetSaveStateSize();
+	const VkApplicationInfo* get_application_info() override;
+
+	std::unique_ptr<GSDumpBase> dump;
+	uint32_t dump_frames = 0;
+};
diff --git a/pcsx2/ImGui/ImGuiFullscreen.cpp b/pcsx2/ImGui/ImGuiFullscreen.cpp
index d3f92d26d..f9f906ab7 100644
--- a/pcsx2/ImGui/ImGuiFullscreen.cpp
+++ b/pcsx2/ImGui/ImGuiFullscreen.cpp
@@ -586,6 +586,8 @@ ImGuiFullscreen::FocusResetType ImGuiFullscreen::GetQueuedFocusResetType()
 
 void ImGuiFullscreen::ForceKeyNavEnabled()
 {
+	if (!ImGui::GetCurrentContext())
+		return;
 	ImGuiContext& g = *ImGui::GetCurrentContext();
 	g.ActiveIdSource = (g.ActiveIdSource == ImGuiInputSource_Mouse) ? ImGuiInputSource_Keyboard : g.ActiveIdSource;
 	g.NavInputSource = (g.NavInputSource == ImGuiInputSource_Mouse) ? ImGuiInputSource_Keyboard : g.ActiveIdSource;
diff --git a/pcsx2/Pcsx2Config.cpp b/pcsx2/Pcsx2Config.cpp
index fc87c91c9..f949738ae 100644
--- a/pcsx2/Pcsx2Config.cpp
+++ b/pcsx2/Pcsx2Config.cpp
@@ -586,15 +586,16 @@ const char* Pcsx2Config::GSOptions::GetRendererName(GSRendererType type)
 	switch (type)
 	{
 		// clang-format off
-		case GSRendererType::Auto:  return "Auto";
-		case GSRendererType::DX11:  return "Direct3D 11";
-		case GSRendererType::DX12:  return "Direct3D 12";
-		case GSRendererType::Metal: return "Metal";
-		case GSRendererType::OGL:   return "OpenGL";
-		case GSRendererType::VK:    return "Vulkan";
-		case GSRendererType::SW:    return "Software";
-		case GSRendererType::Null:  return "Null";
-		default:                    return "";
+		case GSRendererType::Auto:       return "Auto";
+		case GSRendererType::DX11:       return "Direct3D 11";
+		case GSRendererType::DX12:       return "Direct3D 12";
+		case GSRendererType::Metal:      return "Metal";
+		case GSRendererType::OGL:        return "OpenGL";
+		case GSRendererType::VK:         return "Vulkan";
+		case GSRendererType::SW:         return "Software";
+		case GSRendererType::Null:       return "Null";
+		case GSRendererType::ParallelGS: return "paraLLEl";
+		default:                         return "";
 			// clang-format on
 	}
 }
@@ -770,7 +771,8 @@ bool Pcsx2Config::GSOptions::OptionsAreEqual(const GSOptions& right) const
 		OpEqu(Adapter) &&
 
 		OpEqu(HWDumpDirectory) &&
-		OpEqu(SWDumpDirectory));
+		OpEqu(SWDumpDirectory)) &&
+		OpEqu(PGSSuperSampling);
 }
 
 bool Pcsx2Config::GSOptions::operator!=(const GSOptions& right) const
@@ -851,6 +853,7 @@ void Pcsx2Config::GSOptions::LoadSave(SettingsWrapper& wrap)
 	SettingsWrapBitBool(HWSpinCPUForReadbacks);
 	SettingsWrapBitBoolEx(GPUPaletteConversion, "paltex");
 	SettingsWrapBitBoolEx(AutoFlushSW, "autoflush_sw");
+	SettingsWrapIntEnumEx(PGSSuperSampling, "pgsSuperSampling");
 	SettingsWrapBitBoolEx(PreloadFrameWithGSData, "preload_frame_with_gs_data");
 	SettingsWrapBitBoolEx(Mipmap, "mipmap");
 	SettingsWrapBitBoolEx(ManualUserHacks, "UserHacks");
diff --git a/pcsx2/pcsx2.vcxproj b/pcsx2/pcsx2.vcxproj
index aeeb1a853..71b3182ea 100644
--- a/pcsx2/pcsx2.vcxproj
+++ b/pcsx2/pcsx2.vcxproj
@@ -53,13 +53,22 @@
       <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)3rdparty\d3d12memalloc\include</AdditionalIncludeDirectories>
       <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)3rdparty\lzma\include</AdditionalIncludeDirectories>
       <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)3rdparty\freesurround\include</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)pcsx2\GS\parallel-gs\gs</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)pcsx2\GS\parallel-gs\Granite\vulkan</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)pcsx2\GS\parallel-gs\Granite\util</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)pcsx2\GS\parallel-gs\Granite\math</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)pcsx2\GS\parallel-gs\Granite\filesystem</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)pcsx2\GS\parallel-gs\Granite\application\global</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)pcsx2\GS\parallel-gs\Granite\third_party\volk</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)pcsx2\GS\parallel-gs\Granite\third_party\renderdoc</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)pcsx2\GS\parallel-gs\Granite\third_party\stb\stb</AdditionalIncludeDirectories>
       <AdditionalIncludeDirectories Condition="'$(Platform)'=='x64'">%(AdditionalIncludeDirectories);$(SolutionDir)3rdparty\xbyak</AdditionalIncludeDirectories>
       <AdditionalIncludeDirectories Condition="'$(Platform)'=='x64'">%(AdditionalIncludeDirectories);$(SolutionDir)3rdparty\zydis\include;$(SolutionDir)3rdparty\zydis\dependencies\zycore\include</AdditionalIncludeDirectories>
       <AdditionalIncludeDirectories Condition="'$(Platform)'=='ARM64'">%(AdditionalIncludeDirectories);$(SolutionDir)3rdparty\vixl\include</AdditionalIncludeDirectories>
       <PrecompiledHeader>Use</PrecompiledHeader>
       <PrecompiledHeaderFile>PrecompiledHeader.h</PrecompiledHeaderFile>
       <ForcedIncludeFiles>PrecompiledHeader.h;%(ForcedIncludeFiles)</ForcedIncludeFiles>
-      <PreprocessorDefinitions>C4_NO_DEBUG_BREAK;ST_NO_EXCEPTION_HANDLING;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <PreprocessorDefinitions>HAVE_PARALLEL_GS;C4_NO_DEBUG_BREAK;ST_NO_EXCEPTION_HANDLING;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <PreprocessorDefinitions Condition="'$(Platform)'!='ARM64'">ENABLE_RAINTEGRATION;ENABLE_OPENGL;ENABLE_VULKAN;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <PreprocessorDefinitions Condition="'$(Platform)'=='x64'">XBYAK_NO_EXCEPTION;ZYCORE_STATIC_DEFINE;ZYDIS_STATIC_DEFINE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <PreprocessorDefinitions Condition="'$(Platform)'=='ARM64'">VIXL_INCLUDE_TARGET_AARCH64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
@@ -256,6 +265,46 @@
     <ClCompile Include="Gif_Logger.cpp" />
     <ClCompile Include="Gif_Unit.cpp" />
     <ClCompile Include="GSDumpReplayer.cpp" />
+    <ClCompile Include="GS\Renderers\parallel-gs\GSRendererPGS.cpp" />
+    <ClCompile Include="GS\parallel-gs\gs\gs_interface.cpp" />
+    <ClCompile Include="GS\parallel-gs\gs\gs_renderer.cpp" />
+    <ClCompile Include="GS\parallel-gs\gs\gs_util.cpp" />
+    <ClCompile Include="GS\parallel-gs\gs\page_tracker.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\buffer.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\buffer_pool.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\command_buffer.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\command_pool.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\context.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\cookie.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\descriptor_set.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\device.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\event_manager.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\fence.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\fence_manager.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\image.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\indirect_layout.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\memory_allocator.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\pipeline_event.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\query_pool.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\render_pass.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\renderdoc_capture.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\sampler.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\semaphore.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\semaphore_manager.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\shader.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\wsi.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\texture\memory_mapped_texture.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\texture\texture_files.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\texture\texture_format.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\util\aligned_alloc.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\util\arena_allocator.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\util\logging.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\util\timer.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\util\environment.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\util\timeline_trace_file.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\util\thread_id.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\util\thread_name.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\util\thread_priority.cpp" />
     <ClCompile Include="GS\Renderers\DX11\D3D.cpp" />
     <ClCompile Include="GS\Renderers\DX12\GSDevice12.cpp" />
     <ClCompile Include="GS\Renderers\DX12\GSTexture12.cpp" />
-- 
2.46.0

