From 385ae2635e2edb4833bcd37169569b9252dccc9b Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Sun, 23 Jun 2024 14:54:43 +0200
Subject: [PATCH] Early integration of parallel-GS.

---
 .gitignore                                    |   2 +
 CMakeLists.txt                                |   8 +
 pcsx2-gsrunner/Main.cpp                       |   4 +
 pcsx2-qt/MainWindow.cpp                       |   3 +
 pcsx2-qt/Settings/GraphicsSettingsWidget.cpp  |  78 +-
 pcsx2-qt/Settings/GraphicsSettingsWidget.ui   | 100 ++
 pcsx2-qt/pcsx2-qt.vcxproj                     |   1 +
 pcsx2/CMakeLists.txt                          |  18 +
 pcsx2/Config.h                                |   8 +
 pcsx2/GS/GS.cpp                               | 399 ++++++--
 pcsx2/GS/GS.h                                 |   3 +
 pcsx2/GS/GSState.cpp                          |   2 +-
 pcsx2/GS/GSState.h                            |   2 +-
 pcsx2/GS/GSUtil.cpp                           |   4 +-
 pcsx2/GS/Renderers/Common/GSRenderer.cpp      |   2 +-
 pcsx2/GS/Renderers/Vulkan/VKLoader.cpp        |  18 +-
 pcsx2/GS/Renderers/Vulkan/VKLoader.h          |  19 +-
 .../Vulkan/VKLoaderPlatformDefines.h          |  23 +
 .../Renderers/parallel-gs/GSRendererPGS.cpp   | 856 ++++++++++++++++++
 .../GS/Renderers/parallel-gs/GSRendererPGS.h  |  88 ++
 pcsx2/ImGui/ImGuiFullscreen.cpp               |   2 +
 pcsx2/Pcsx2Config.cpp                         |  17 +-
 pcsx2/pcsx2.vcxproj                           |  53 +-
 23 files changed, 1613 insertions(+), 97 deletions(-)
 create mode 100644 pcsx2/GS/Renderers/Vulkan/VKLoaderPlatformDefines.h
 create mode 100644 pcsx2/GS/Renderers/parallel-gs/GSRendererPGS.cpp
 create mode 100644 pcsx2/GS/Renderers/parallel-gs/GSRendererPGS.h

diff --git a/.gitignore b/.gitignore
index 9305218258..2304f4356b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -122,3 +122,5 @@ CMakeSettings.json
 /ci-artifacts/
 /out/
 /.cache/
+
+/pcsx2/GS/parallel-gs
diff --git a/CMakeLists.txt b/CMakeLists.txt
index d18b7d12a9..aafffd9b1f 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -33,6 +33,14 @@ check_no_parenthesis_in_path()
 detect_operating_system()
 detect_compiler()
 
+# Need to make sure this is included early, so we can make sure we use our own Vulkan headers,
+# which are more recent than system headers.
+# Otherwise, Qt6 includes system Vulkan headers in SearchForStuff.
+if (IS_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/pcsx2/GS/parallel-gs)
+	set(PARALLEL_GS_STANDALONE ON CACHE BOOL "" FORCE)
+	add_subdirectory(pcsx2/GS/parallel-gs EXCLUDE_FROM_ALL)
+endif()
+
 #-------------------------------------------------------------------------------
 # Include specific module
 include(BuildParameters)
diff --git a/pcsx2-gsrunner/Main.cpp b/pcsx2-gsrunner/Main.cpp
index f1ecaffb24..5e43d8faef 100644
--- a/pcsx2-gsrunner/Main.cpp
+++ b/pcsx2-gsrunner/Main.cpp
@@ -639,6 +639,10 @@ bool GSRunner::ParseCommandLineArgs(int argc, char* argv[], VMBootParameters& pa
 				else if (StringUtil::Strcasecmp(rname, "dx12") == 0)
 					type = GSRendererType::DX12;
 #endif
+#ifdef HAVE_PARALLEL_GS
+				else if (StringUtil::Strcasecmp(rname, "parallel-gs") == 0)
+					type = GSRendererType::ParallelGS;
+#endif
 #ifdef ENABLE_OPENGL
 				else if (StringUtil::Strcasecmp(rname, "gl") == 0)
 					type = GSRendererType::OGL;
diff --git a/pcsx2-qt/MainWindow.cpp b/pcsx2-qt/MainWindow.cpp
index 3f3739e76d..0d73a4d5af 100644
--- a/pcsx2-qt/MainWindow.cpp
+++ b/pcsx2-qt/MainWindow.cpp
@@ -491,6 +491,9 @@ void MainWindow::createRendererSwitchMenu()
 {
 	static constexpr const GSRendererType renderers[] = {
 		GSRendererType::Auto,
+#if defined(HAVE_PARALLEL_GS)
+		GSRendererType::ParallelGS,
+#endif
 #if defined(_WIN32)
 		GSRendererType::DX11,
 		GSRendererType::DX12,
diff --git a/pcsx2-qt/Settings/GraphicsSettingsWidget.cpp b/pcsx2-qt/Settings/GraphicsSettingsWidget.cpp
index f8dd68f4c6..1c937fd6e9 100644
--- a/pcsx2-qt/Settings/GraphicsSettingsWidget.cpp
+++ b/pcsx2-qt/Settings/GraphicsSettingsWidget.cpp
@@ -21,6 +21,9 @@ struct RendererInfo
 
 static constexpr RendererInfo s_renderer_info[] = {
 	{QT_TRANSLATE_NOOP("GraphicsSettingsWidget", "Automatic (Default)"), GSRendererType::Auto},
+#ifdef HAVE_PARALLEL_GS
+	{QT_TRANSLATE_NOOP("GraphicsSettingsWidget", "paraLLEl-GS"), GSRendererType::ParallelGS},
+#endif
 #ifdef _WIN32
 	//: Graphics backend/engine type. Leave as-is.
 	{QT_TRANSLATE_NOOP("GraphicsSettingsWidget", "Direct3D 11"), GSRendererType::DX11},
@@ -270,6 +273,17 @@ GraphicsSettingsWidget::GraphicsSettingsWidget(SettingsWindow* dialog, QWidget*
 	SettingWidgetBinder::BindWidgetToBoolSetting(sif, m_ui.swAutoFlush, "EmuCore/GS", "autoflush_sw", true);
 	SettingWidgetBinder::BindWidgetToBoolSetting(sif, m_ui.swMipmap, "EmuCore/GS", "mipmap", true);
 
+	//////////////////////////////////////////////////////////////////////////
+	// PGS Settings
+	//////////////////////////////////////////////////////////////////////////
+	SettingWidgetBinder::BindWidgetToIntSetting(sif, m_ui.pgsSuperSampling, "EmuCore/GS", "pgsSuperSampling", 0);
+	SettingWidgetBinder::BindWidgetToIntSetting(sif, m_ui.pgsHighResScanout, "EmuCore/GS", "pgsHighResScanout", 0);
+	SettingWidgetBinder::BindWidgetToIntSetting(sif, m_ui.pgsSuperSampleTextures, "EmuCore/GS", "pgsSuperSampleTextures", 0);
+	SettingWidgetBinder::BindWidgetToIntSetting(sif, m_ui.pgsDisableMipmaps, "EmuCore/GS", "pgsDisableMipmaps", 0);
+	SettingWidgetBinder::BindWidgetToIntSetting(sif, m_ui.pgsDisableReadbackSync, "EmuCore/GS", "pgsDisableReadbackSync", 0);
+	SettingWidgetBinder::BindWidgetToIntSetting(sif, m_ui.pgsSharpBackbuffer, "EmuCore/GS", "pgsSharpBackbuffer", 0);
+	SettingWidgetBinder::BindWidgetToIntSetting(sif, m_ui.pgsBlendDemotion, "EmuCore/GS", "pgsBlendDemotion", 0);
+
 	//////////////////////////////////////////////////////////////////////////
 	// Non-trivial settings
 	//////////////////////////////////////////////////////////////////////////
@@ -305,6 +319,7 @@ GraphicsSettingsWidget::GraphicsSettingsWidget(SettingsWindow* dialog, QWidget*
 	connect(m_ui.extendedUpscales, &QCheckBox::checkStateChanged, this, &GraphicsSettingsWidget::updateRendererDependentOptions);
 	connect(m_ui.textureFiltering, &QComboBox::currentIndexChanged, this, &GraphicsSettingsWidget::onTextureFilteringChange);
 	connect(m_ui.swTextureFiltering, &QComboBox::currentIndexChanged, this, &GraphicsSettingsWidget::onSWTextureFilteringChange);
+
 	updateRendererDependentOptions();
 
 #ifndef _WIN32
@@ -603,6 +618,42 @@ GraphicsSettingsWidget::GraphicsSettingsWidget(SettingsWindow* dialog, QWidget*
 
 		dialog->registerWidgetHelp(
 			m_ui.swMipmap, tr("Mipmapping"), tr("Checked"), tr("Enables mipmapping, which some games require to render correctly."));
+
+		dialog->registerWidgetHelp(m_ui.pgsSuperSampling, tr("paraLLEl-GS Super Sampling"), tr("1x (native)"),
+		                           tr("Number of super samples used by paraLLEl-GS before down-sampling to native resolution. "
+		                              "More than 4x SSAA is not recommended as there is diminishing returns in output quality. "
+		                              "16x SSAA yields a very nice result, but requires reasonably powerful hardware in some games."));
+
+		dialog->registerWidgetHelp(m_ui.pgsSharpBackbuffer, tr("Sharp backbuffer hacks (experimental)"), tr("Unchecked"),
+		                           tr("Some games perform a blit to the backbuffer. "
+		                              "This can significantly reduce image quality, since games tend to either scale the image, or convert the image to 16-bit colors. "
+		                              "This hack attempts to present the original image instead. This option may help alleviate that in lieu of a more proper game patch."));
+
+		dialog->registerWidgetHelp(m_ui.pgsBlendDemotion, tr("Blend demotion speed-hack (experimental)"), tr("Unchecked"),
+		                           tr("When super-sampling, some effect passes may become extremely expensive due to ridiculous overdraw. "
+									  "Most of these passes don't really need super-sampling to achieve its effect. "
+									  "Enabling this option tries to detect common cases and demotes those passes to single sampled. "
+									  "This may dramatically improve performance for certain effects at cost of some image quality, especially around geometry edges. "
+									  "Should not be used along high-res scanout or super-sampled textures since pixellation will be introduced."));
+
+		dialog->registerWidgetHelp(m_ui.pgsSuperSampleTextures, tr("Super-sample Textures (experimental)"), tr("Unchecked"),
+		                           tr("Ensures that frame buffer effects are sampled with all super-samples intact. "
+		                              "Costs some GPU performance and VRAM, but may significantly improve image quality, especially when enabling high-res scanout. "
+									  "This option is highly experimental and may show many rendering artifacts."));
+
+		dialog->registerWidgetHelp(m_ui.pgsHighResScanout, tr("High-res Scanout (experimental)"), tr("Unchecked"),
+		                           tr("When using SSAA, attempts to scan-out a higher resolution result based on stored super-samples. "
+		                              "Requires at least 4x SSAA (ordered) to work. Can benefit from 16x SSAA, at a steep GPU processing cost. "
+									  "Highly game dependent if it works well. Common issues include pixellated output, or lack of sharpness. "
+									  "When playing field rendered games, may eliminate most de-interlacing artifacts. "
+									  "May need super-sampled texture option to be enabled for good results."));
+
+		dialog->registerWidgetHelp(m_ui.pgsDisableMipmaps, tr("Disable mip-mapping"), tr("Unchecked"),
+		                           tr("Disables mip-mapping. May give a sharper image in games using mip-mapping intended for native resolution. "
+		                              "May also break games which rely on mipmaps being used in esoteric ways."));
+
+		dialog->registerWidgetHelp(m_ui.pgsDisableReadbackSync, tr("Disable readback sync"), tr("Unchecked"),
+		                           tr("Disables sync for readbacks. Eliminates stalls, but will probably break things. Used for perf debug."));
 	}
 
 	// Hardware Fixes tab
@@ -1119,6 +1170,7 @@ void GraphicsSettingsWidget::updateRendererDependentOptions()
 	const bool is_hardware = (type == GSRendererType::DX11 || type == GSRendererType::DX12 || type == GSRendererType::OGL ||
 							  type == GSRendererType::VK || type == GSRendererType::Metal);
 	const bool is_software = (type == GSRendererType::SW);
+	const bool is_pgs = (type == GSRendererType::ParallelGS);
 	const bool is_auto = (type == GSRendererType::Auto);
 	const bool is_vk = (type == GSRendererType::VK);
 	const bool is_disable_barriers = (type == GSRendererType::DX11 || type == GSRendererType::DX12 || type == GSRendererType::Metal || type == GSRendererType::SW);
@@ -1133,22 +1185,32 @@ void GraphicsSettingsWidget::updateRendererDependentOptions()
 	m_ui.tabs->setTabEnabled(2, is_software);
 	m_ui.tabs->setTabVisible(2, is_software);
 
-	// hardware fixes
-	m_ui.tabs->setTabEnabled(3, hw_fixes);
-	m_ui.tabs->setTabVisible(3, hw_fixes);
+	// pgs rendering
+	m_ui.tabs->setTabEnabled(3, is_pgs);
+	m_ui.tabs->setTabVisible(3, is_pgs);
 
-	// upscaling fixes
+	// hardware fixes
 	m_ui.tabs->setTabEnabled(4, hw_fixes);
 	m_ui.tabs->setTabVisible(4, hw_fixes);
 
+	// upscaling fixes
+	m_ui.tabs->setTabEnabled(5, hw_fixes);
+	m_ui.tabs->setTabVisible(5, hw_fixes);
+
 	// texture replacement
-	m_ui.tabs->setTabEnabled(5, is_hardware);
-	m_ui.tabs->setTabVisible(5, is_hardware);
+	m_ui.tabs->setTabEnabled(6, is_hardware);
+	m_ui.tabs->setTabVisible(6, is_hardware);
+
+	// Post-processing
+	m_ui.tabs->setTabEnabled(7, !is_pgs);
+	m_ui.tabs->setTabVisible(7, !is_pgs);
 
 	// move back to the renderer if we're on one of the now-hidden tabs
-	if (is_software && (prev_tab == 1 || (prev_tab >= 2 && prev_tab <= 5)))
+	if (is_software && (prev_tab == 1 || (prev_tab >= 2 && prev_tab <= 6)))
 		m_ui.tabs->setCurrentIndex(2);
-	else if (is_hardware && prev_tab == 2)
+	else if (is_pgs)
+		m_ui.tabs->setCurrentIndex(3);
+	else if (is_hardware && (prev_tab == 2 || prev_tab == 3))
 		m_ui.tabs->setCurrentIndex(1);
 
 	if (m_ui.useBlitSwapChain)
diff --git a/pcsx2-qt/Settings/GraphicsSettingsWidget.ui b/pcsx2-qt/Settings/GraphicsSettingsWidget.ui
index b6f421e90f..73ba763e23 100644
--- a/pcsx2-qt/Settings/GraphicsSettingsWidget.ui
+++ b/pcsx2-qt/Settings/GraphicsSettingsWidget.ui
@@ -652,6 +652,106 @@
        </item>
       </layout>
      </widget>
+     <widget class="QWidget" name="pgsRenderingTab">
+      <attribute name="title"><string>Rendering</string></attribute>
+      <layout class="QFormLayout" name="formLayout_11">
+       <item row="0" column="0">
+        <widget class="QLabel" name="pgsSuperSamplingLabel">
+         <property name="text">
+          <string>Super Sampling:</string>
+         </property>
+        </widget>
+       </item>
+       <item row="0" column="1">
+        <widget class="QComboBox" name="pgsSuperSampling">
+         <property name="enabled">
+          <bool>true</bool>
+         </property>
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+         <property name="layoutDirection">
+          <enum>Qt::LayoutDirection::LeftToRight</enum>
+         </property>
+         <item>
+          <property name="text">
+           <string>1x (native)</string>
+          </property>
+         </item>
+         <item>
+          <property name="text">
+           <string>2x SSAA (checkerboard)</string>
+          </property>
+         </item>
+         <item>
+          <property name="text">
+           <string>4x SSAA (sparse grid)</string>
+          </property>
+         </item>
+         <item>
+          <property name="text">
+           <string>4x SSAA (ordered grid, high-res output capable)</string>
+          </property>
+         </item>
+         <item>
+          <property name="text">
+           <string>8x SSAA (checkerboard, high-res output capable)</string>
+          </property>
+         </item>
+         <item>
+          <property name="text">
+           <string>16x SSAA (sparse grid, high-res output capable)</string>
+          </property>
+         </item>
+        </widget>
+       </item>
+       <item row="1" column="0">
+          <widget class="QCheckBox" name="pgsHighResScanout">
+           <property name="text">
+            <string>High-resolution scanout</string>
+           </property>
+          </widget>
+       </item>
+       <item row="1" column="1">
+          <widget class="QCheckBox" name="pgsSuperSampleTextures">
+           <property name="text">
+            <string>Super-sample textures</string>
+           </property>
+          </widget>
+       </item>
+       <item row="2" column="0">
+          <widget class="QCheckBox" name="pgsDisableMipmaps">
+           <property name="text">
+            <string>Disable mip-mapping</string>
+           </property>
+          </widget>
+       </item>
+       <item row="2" column="1">
+          <widget class="QCheckBox" name="pgsDisableReadbackSync">
+           <property name="text">
+            <string>Disable readback sync</string>
+           </property>
+          </widget>
+       </item>
+       <item row="3" column="0">
+          <widget class="QCheckBox" name="pgsSharpBackbuffer">
+           <property name="text">
+            <string>Sharp backbuffer hack</string>
+           </property>
+          </widget>
+       </item>
+       <item row="3" column="1">
+          <widget class="QCheckBox" name="pgsBlendDemotion">
+           <property name="text">
+            <string>Blend demotion hack</string>
+           </property>
+          </widget>
+       </item>
+      </layout>
+     </widget>
      <widget class="QWidget" name="hardwareFixesTab">
       <attribute name="title">
        <string>Hardware Fixes</string>
diff --git a/pcsx2-qt/pcsx2-qt.vcxproj b/pcsx2-qt/pcsx2-qt.vcxproj
index b2344f8be0..1c452b0a6b 100644
--- a/pcsx2-qt/pcsx2-qt.vcxproj
+++ b/pcsx2-qt/pcsx2-qt.vcxproj
@@ -60,6 +60,7 @@
       <PreprocessorDefinitions>KDDW_FRONTEND_QT;KDDW_FRONTEND_QTWIDGETS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <!-- Needed for KDDockWidgets. -->
       <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <PreprocessorDefinitions>HAVE_PARALLEL_GS;QT_NO_EXCEPTIONS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
     </ClCompile>
     <Link>
       <AdditionalDependencies>$(QtEntryPointLib);%(AdditionalDependencies)</AdditionalDependencies>
diff --git a/pcsx2/CMakeLists.txt b/pcsx2/CMakeLists.txt
index 111c20e08f..6129d32403 100644
--- a/pcsx2/CMakeLists.txt
+++ b/pcsx2/CMakeLists.txt
@@ -642,6 +642,7 @@ if(USE_VULKAN)
 		GS/Renderers/Vulkan/VKEntryPoints.h
 		GS/Renderers/Vulkan/VKEntryPoints.inl
 		GS/Renderers/Vulkan/VKLoader.h
+		GS/Renderers/Vulkan/VKLoaderPlatformDefines.h
 		GS/Renderers/Vulkan/VKShaderCache.h
 		GS/Renderers/Vulkan/VKStreamBuffer.h
 		GS/Renderers/Vulkan/VKSwapChain.h
@@ -650,6 +651,23 @@ if(USE_VULKAN)
 	target_include_directories(PCSX2_FLAGS INTERFACE ${SHADERC_INCLUDE_DIR})
 endif()
 
+if (TARGET parallel-gs)
+	message("Adding support for paraLLEl-GS")
+	target_link_libraries(PCSX2_FLAGS INTERFACE parallel-gs)
+	target_compile_definitions(PCSX2_FLAGS INTERFACE HAVE_PARALLEL_GS)
+	list(APPEND pcsx2GSSources GS/Renderers/parallel-gs/GSRendererPGS.cpp)
+	list(APPEND pcsx2GSHeaders GS/Renderers/parallel-gs/GSRendererPGS.h)
+	if (X11_API)
+		target_compile_definitions(granite-volk PUBLIC VK_USE_PLATFORM_XLIB_KHR)
+	endif()
+	if (WAYLAND_API)
+		target_compile_definitions(granite-volk PUBLIC VK_USE_PLATFORM_WAYLAND_KHR)
+	endif()
+	if (WIN32)
+		target_compile_definitions(granite-volk PUBLIC VK_USE_PLATFORM_WIN32_KHR)
+	endif()
+endif()
+
 set(pcsx2GSMetalShaders
 	GS/Renderers/Metal/cas.metal
 	GS/Renderers/Metal/convert.metal
diff --git a/pcsx2/Config.h b/pcsx2/Config.h
index 84fee350ed..6234f6477d 100644
--- a/pcsx2/Config.h
+++ b/pcsx2/Config.h
@@ -278,6 +278,7 @@ enum class GSRendererType : s8
 	VK = 14,
 	Metal = 17,
 	DX12 = 15,
+	ParallelGS = 18
 };
 
 enum class GSVSyncMode : u8
@@ -847,6 +848,13 @@ struct Pcsx2Config
 		u8 ShadeBoost_Saturation = DEFAULT_SHADEBOOST_SATURATION;
 		u8 ShadeBoost_Gamma = DEFAULT_SHADEBOOST_GAMMA;
 		u8 PNGCompressionLevel = 1;
+		u8 PGSSuperSampling = 0;
+		u8 PGSHighResScanout = 0;
+		u8 PGSDisableMipmaps = 0;
+		u8 PGSDisableReadbackSync = 0;
+		u8 PGSSuperSampleTextures = 0;
+		u8 PGSSharpBackbuffer = 0;
+		u8 PGSBlendDemotion = 0;
 
 		u16 SWExtraThreads = 2;
 		u16 SWExtraThreadsHeight = 4;
diff --git a/pcsx2/GS/GS.cpp b/pcsx2/GS/GS.cpp
index cfc19d90c2..1e633d4fd3 100644
--- a/pcsx2/GS/GS.cpp
+++ b/pcsx2/GS/GS.cpp
@@ -1,5 +1,10 @@
 // SPDX-FileCopyrightText: 2002-2025 PCSX2 Dev Team
 // SPDX-License-Identifier: GPL-3.0+
+//
+#ifdef HAVE_PARALLEL_GS
+#include "GS/Renderers/parallel-gs/GSRendererPGS.h"
+std::unique_ptr<GSRendererPGS> g_pgs_renderer;
+#endif
 
 #include "Config.h"
 #include "Counters.h"
@@ -17,6 +22,7 @@
 #include "Input/InputManager.h"
 #include "MTGS.h"
 #include "pcsx2/GS.h"
+
 #include "GS/Renderers/Null/GSRendererNull.h"
 #include "GS/Renderers/HW/GSRendererHW.h"
 #include "GS/Renderers/HW/GSTextureReplacements.h"
@@ -58,6 +64,9 @@ Pcsx2Config::GSOptions GSConfig;
 
 static GSRendererType GSCurrentRenderer;
 
+struct FileDeleter { void operator()(FILE *file) { if (file) fclose(file); } };
+std::unique_ptr<FILE, FileDeleter> g_gs_stream;
+
 GSRendererType GSGetCurrentRenderer()
 {
 	return GSCurrentRenderer;
@@ -85,6 +94,11 @@ static RenderAPI GetAPIForRenderer(GSRendererType renderer)
 		case GSRendererType::VK:
 			return RenderAPI::Vulkan;
 
+#ifdef HAVE_PARALLEL_GS
+		case GSRendererType::ParallelGS:
+			return RenderAPI::Granite;
+#endif
+
 #ifdef _WIN32
 		case GSRendererType::DX11:
 			return RenderAPI::D3D11;
@@ -98,6 +112,10 @@ static RenderAPI GetAPIForRenderer(GSRendererType renderer)
 			return RenderAPI::Metal;
 #endif
 
+		case GSRendererType::SW:
+			// Hack.
+			return RenderAPI::Vulkan;
+
 			// We could end up here if we ever removed a renderer.
 		default:
 			return GetAPIForRenderer(GSUtil::GetPreferredRenderer());
@@ -135,6 +153,12 @@ static bool OpenGSDevice(GSRendererType renderer, bool clear_state_on_fail, bool
 			break;
 #endif
 
+#ifdef HAVE_PARALLEL_GS
+		case RenderAPI::Granite:
+			// The renderer owns its own device for now.
+			return true;
+#endif
+
 		default:
 			Console.Error("Unsupported render API %s", GSDevice::RenderAPIToString(new_api));
 			return false;
@@ -155,16 +179,20 @@ static bool OpenGSDevice(GSRendererType renderer, bool clear_state_on_fail, bool
 	if (!okay)
 	{
 		ImGuiManager::Shutdown(clear_state_on_fail);
-		g_gs_device->Destroy();
-		g_gs_device.reset();
+		if (g_gs_device)
+		{
+			g_gs_device->Destroy();
+			g_gs_device.reset();
+		}
 		Host::ReleaseRenderWindow();
 		return false;
 	}
 
-	GSConfig.OsdShowGPU = GSConfig.OsdShowGPU && g_gs_device->SetGPUTimingEnabled(true);
+	GSConfig.OsdShowGPU = g_gs_device && GSConfig.OsdShowGPU && g_gs_device->SetGPUTimingEnabled(true);
 
 	Console.WriteLn(Color_StrongGreen, "%s Graphics Driver Info:", GSDevice::RenderAPIToString(new_api));
-	Console.WriteLn(g_gs_device->GetDriverInfo());
+	if (g_gs_device)
+		Console.WriteLn(g_gs_device->GetDriverInfo());
 
 	return true;
 }
@@ -208,6 +236,17 @@ static bool OpenGSRenderer(GSRendererType renderer, u8* basemem)
 	{
 		g_gs_renderer = std::make_unique<GSRendererNull>();
 	}
+#ifdef HAVE_PARALLEL_GS
+	else if (renderer == GSRendererType::ParallelGS)
+	{
+		g_pgs_renderer = std::make_unique<GSRendererPGS>(basemem);
+		if (!g_pgs_renderer->Init())
+		{
+			g_pgs_renderer.reset();
+			return false;
+		}
+	}
+#endif
 	else if (renderer != GSRendererType::SW)
 	{
 		GSClampUpscaleMultiplier(GSConfig);
@@ -218,10 +257,18 @@ static bool OpenGSRenderer(GSRendererType renderer, u8* basemem)
 		g_gs_renderer = std::unique_ptr<GSRenderer>(MULTI_ISA_SELECT(makeGSRendererSW)(GSConfig.SWExtraThreads));
 	}
 
-	g_gs_renderer->SetRegsMem(basemem);
-	g_gs_renderer->ResetPCRTC();
-	g_gs_renderer->UpdateRenderFixes();
+	if (g_gs_renderer)
+	{
+		g_gs_renderer->SetRegsMem(basemem);
+		g_gs_renderer->ResetPCRTC();
+		g_gs_renderer->UpdateRenderFixes();
+	}
 	g_perfmon.Reset();
+
+	const char *env = getenv("GS_STREAM");
+	if (env)
+		g_gs_stream.reset(fopen(env, "wb"));
+
 	return true;
 }
 
@@ -229,11 +276,17 @@ static void CloseGSRenderer()
 {
 	GSTextureReplacements::Shutdown();
 
+#ifdef HAVE_PARALLEL_GS
+	g_pgs_renderer.reset();
+#endif
+
 	if (g_gs_renderer)
 	{
 		g_gs_renderer->Destroy();
 		g_gs_renderer.reset();
 	}
+
+	g_gs_stream.reset();
 }
 
 bool GSreopen(bool recreate_device, bool recreate_renderer, GSRendererType new_renderer,
@@ -241,18 +294,21 @@ bool GSreopen(bool recreate_device, bool recreate_renderer, GSRendererType new_r
 {
 	Console.WriteLn("Reopening GS with %s device", recreate_device ? "new" : "existing");
 
-	g_gs_renderer->Flush(GSState::GSFlushReason::GSREOPEN);
-
-	if (recreate_device && !recreate_renderer)
-	{
-		// Keeping the renderer around, this probably means we lost the device, so toss everything.
-		g_gs_renderer->PurgeTextureCache(true, true, true);
-		g_gs_device->ClearCurrent();
-		g_gs_device->PurgePool();
-	}
-	else if (GSConfig.UserHacks_ReadTCOnClose)
+	if (g_gs_renderer)
 	{
-		g_gs_renderer->ReadbackTextureCache();
+		g_gs_renderer->Flush(GSState::GSFlushReason::GSREOPEN);
+
+		if (recreate_device && !recreate_renderer)
+		{
+			// Keeping the renderer around, this probably means we lost the device, so toss everything.
+			g_gs_renderer->PurgeTextureCache(true, true, true);
+			g_gs_device->ClearCurrent();
+			g_gs_device->PurgePool();
+		}
+		else if (GSConfig.UserHacks_ReadTCOnClose)
+		{
+			g_gs_renderer->ReadbackTextureCache();
+		}
 	}
 
 	std::string capture_filename;
@@ -262,27 +318,65 @@ bool GSreopen(bool recreate_device, bool recreate_renderer, GSRendererType new_r
 		capture_filename = GSCapture::GetNextCaptureFileName();
 		capture_size = GSCapture::GetSize();
 		Console.Warning(fmt::format("Restarting video capture to {}.", capture_filename));
-		g_gs_renderer->EndCapture();
+		if (g_gs_renderer)
+			g_gs_renderer->EndCapture();
 	}
 
-	u8* basemem = g_gs_renderer->GetRegsMem();
+	u8* basemem;
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+	{
+		basemem = g_pgs_renderer->GetRegsMem();
+	}
+	else
+#endif
+	{
+		basemem = g_gs_renderer->GetRegsMem();
+	}
 
 	freezeData fd = {};
 	std::unique_ptr<u8[]> fd_data;
 	if (recreate_renderer)
 	{
-		if (g_gs_renderer->Freeze(&fd, true) != 0)
+#ifdef HAVE_PARALLEL_GS
+		if (g_pgs_renderer)
 		{
-			Console.Error("(GSreopen) Failed to get GS freeze size");
-			return false;
+			if (g_pgs_renderer->Freeze(&fd, true) != 0)
+			{
+				Console.Error("(GSreopen) Failed to get GS freeze size");
+				return false;
+			}
+		}
+		else
+#endif
+		{
+			if (g_gs_renderer->Freeze(&fd, true) != 0)
+			{
+				Console.Error("(GSreopen) Failed to get GS freeze size");
+				return false;
+			}
 		}
 
 		fd_data = std::make_unique<u8[]>(fd.size);
 		fd.data = fd_data.get();
-		if (g_gs_renderer->Freeze(&fd, false) != 0)
+
+#ifdef HAVE_PARALLEL_GS
+		if (g_pgs_renderer)
 		{
-			Console.Error("(GSreopen) Failed to freeze GS");
-			return false;
+			if (g_pgs_renderer->Freeze(&fd, false) != 0)
+			{
+				Console.Error("(GSreopen) Failed to freeze GS");
+				return false;
+			}
+		}
+		else
+#endif
+		{
+			if (g_gs_renderer->Freeze(&fd, false) != 0)
+			{
+				Console.Error("(GSreopen) Failed to freeze GS");
+				return false;
+			}
 		}
 
 		CloseGSRenderer();
@@ -291,9 +385,10 @@ bool GSreopen(bool recreate_device, bool recreate_renderer, GSRendererType new_r
 	if (recreate_device)
 	{
 		// We need a new render window when changing APIs.
-		const bool recreate_window = (g_gs_device->GetRenderAPI() != GetAPIForRenderer(GSConfig.Renderer));
-		const GSVSyncMode vsync_mode = g_gs_device->GetVSyncMode();
-		const bool allow_present_throttle = g_gs_device->IsPresentThrottleAllowed();
+		const bool recreate_window = !g_gs_device || (g_gs_device->GetRenderAPI() != GetAPIForRenderer(GSConfig.Renderer));
+		// TODO: Pass these through.
+		const GSVSyncMode vsync_mode = g_gs_device ? g_gs_device->GetVSyncMode() : GSVSyncMode::FIFO;
+		const bool allow_present_throttle = !g_gs_device || g_gs_device->IsPresentThrottleAllowed();
 		CloseGSDevice(false);
 
 		if (!OpenGSDevice(new_renderer, false, recreate_window, vsync_mode, allow_present_throttle))
@@ -324,14 +419,27 @@ bool GSreopen(bool recreate_device, bool recreate_renderer, GSRendererType new_r
 			return false;
 		}
 
-		if (g_gs_renderer->Defrost(&fd) != 0)
+#ifdef HAVE_PARALLEL_GS
+		if (g_pgs_renderer)
 		{
-			Console.Error("(GSreopen) Failed to defrost");
-			return false;
+			if (g_pgs_renderer->Defrost(&fd) != 0)
+			{
+				Console.Error("(GSreopen) Failed to defrost");
+				return false;
+			}
+		}
+		else
+#endif
+		{
+			if (g_gs_renderer->Defrost(&fd) != 0)
+			{
+				Console.Error("(GSreopen) Failed to defrost");
+				return false;
+			}
 		}
 	}
 
-	if (!capture_filename.empty())
+	if (g_gs_renderer && !capture_filename.empty())
 		g_gs_renderer->BeginCapture(std::move(capture_filename), capture_size);
 
 	return true;
@@ -377,6 +485,14 @@ void GSclose()
 
 void GSreset(bool hardware_reset)
 {
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		g_pgs_renderer->Reset(hardware_reset);
+#endif
+
+	if (!g_gs_renderer)
+		return;
+
 	g_gs_renderer->Reset(hardware_reset);
 
 	// Restart video capture if it's been started.
@@ -393,65 +509,150 @@ void GSreset(bool hardware_reset)
 
 void GSgifSoftReset(u32 mask)
 {
-	g_gs_renderer->SoftReset(mask);
+	if (g_gs_renderer)
+		g_gs_renderer->SoftReset(mask);
 }
 
 void GSwriteCSR(u32 csr)
 {
-	g_gs_renderer->WriteCSR(csr);
+	// TODO: Do we need to care about CSR in parallel-GS?
+	if (g_gs_renderer)
+		g_gs_renderer->WriteCSR(csr);
 }
 
 void GSInitAndReadFIFO(u8* mem, u32 size)
 {
-	GL_PERF("Init and read FIFO %u qwc", size);
-	g_gs_renderer->InitReadFIFO(mem, size);
-	g_gs_renderer->ReadFIFO(mem, size);
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		g_pgs_renderer->ReadFIFO(mem, size);
+#endif
+
+	if (g_gs_renderer)
+	{
+		GL_PERF("Init and read FIFO %u qwc", size);
+		g_gs_renderer->InitReadFIFO(mem, size);
+		g_gs_renderer->ReadFIFO(mem, size);
+	}
 }
 
 void GSReadLocalMemoryUnsync(u8* mem, u32 qwc, u64 BITBLITBUF, u64 TRXPOS, u64 TRXREG)
 {
-	g_gs_renderer->ReadLocalMemoryUnsync(mem, qwc, GIFRegBITBLTBUF{BITBLITBUF}, GIFRegTRXPOS{TRXPOS}, GIFRegTRXREG{TRXREG});
+	// TODO: What is this?
+	if (g_gs_renderer)
+		g_gs_renderer->ReadLocalMemoryUnsync(mem, qwc, GIFRegBITBLTBUF{BITBLITBUF}, GIFRegTRXPOS{TRXPOS}, GIFRegTRXREG{TRXREG});
 }
 
 void GSgifTransfer(const u8* mem, u32 size)
 {
-	g_gs_renderer->Transfer<3>(mem, size);
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		g_pgs_renderer->Transfer(mem, size);
+#endif
+
+	if (g_gs_renderer)
+		g_gs_renderer->Transfer<3>(mem, size);
+
+	if (g_gs_stream)
+	{
+		auto *f = g_gs_stream.get();
+		const uint8_t type = 0;
+		const uint8_t path = 3;
+		fwrite(&type, sizeof(type), 1, f);
+		fwrite(&path, sizeof(path), 1, f);
+		size *= 16;
+		fwrite(&size, sizeof(size), 1, f);
+		fwrite(mem, size, 1, f);
+	}
 }
 
 void GSgifTransfer1(u8* mem, u32 addr)
 {
-	g_gs_renderer->Transfer<0>(const_cast<u8*>(mem) + addr, (0x4000 - addr) / 16);
+	// TODO: These seem to be completely unused.
+	if (g_gs_renderer)
+		g_gs_renderer->Transfer<0>(const_cast<u8*>(mem) + addr, (0x4000 - addr) / 16);
 }
 
 void GSgifTransfer2(u8* mem, u32 size)
 {
-	g_gs_renderer->Transfer<1>(const_cast<u8*>(mem), size);
+	// TODO: These seem to be completely unused.
+	if (g_gs_renderer)
+		g_gs_renderer->Transfer<1>(const_cast<u8*>(mem), size);
 }
 
 void GSgifTransfer3(u8* mem, u32 size)
 {
-	g_gs_renderer->Transfer<2>(const_cast<u8*>(mem), size);
+	// TODO: These seem to be completely unused.
+	if (g_gs_renderer)
+		g_gs_renderer->Transfer<2>(const_cast<u8*>(mem), size);
 }
 
 void GSvsync(u32 field, bool registers_written)
 {
-	// Update this here because we need to check if the pending draw affects the current frame, so our regs need to be updated.
-	g_gs_renderer->PCRTCDisplays.SetVideoMode(g_gs_renderer->GetVideoMode());
-	g_gs_renderer->PCRTCDisplays.EnableDisplays(g_gs_renderer->m_regs->PMODE, g_gs_renderer->m_regs->SMODE2, g_gs_renderer->isReallyInterlaced());
-	g_gs_renderer->PCRTCDisplays.CheckSameSource();
-	g_gs_renderer->PCRTCDisplays.SetRects(0, g_gs_renderer->m_regs->DISP[0].DISPLAY, g_gs_renderer->m_regs->DISP[0].DISPFB);
-	g_gs_renderer->PCRTCDisplays.SetRects(1, g_gs_renderer->m_regs->DISP[1].DISPLAY, g_gs_renderer->m_regs->DISP[1].DISPFB);
-	g_gs_renderer->PCRTCDisplays.CalculateDisplayOffset(g_gs_renderer->m_scanmask_used);
-	g_gs_renderer->PCRTCDisplays.CalculateFramebufferOffset(g_gs_renderer->m_scanmask_used);
+	if (g_gs_renderer)
+	{
+		// Update this here because we need to check if the pending draw affects the current frame, so our regs need to be updated.
+		g_gs_renderer->PCRTCDisplays.SetVideoMode(g_gs_renderer->GetVideoMode());
+		g_gs_renderer->PCRTCDisplays.EnableDisplays(g_gs_renderer->m_regs->PMODE, g_gs_renderer->m_regs->SMODE2, g_gs_renderer->isReallyInterlaced());
+		g_gs_renderer->PCRTCDisplays.CheckSameSource();
+		g_gs_renderer->PCRTCDisplays.SetRects(0, g_gs_renderer->m_regs->DISP[0].DISPLAY, g_gs_renderer->m_regs->DISP[0].DISPFB);
+		g_gs_renderer->PCRTCDisplays.SetRects(1, g_gs_renderer->m_regs->DISP[1].DISPLAY, g_gs_renderer->m_regs->DISP[1].DISPFB);
+		g_gs_renderer->PCRTCDisplays.CalculateDisplayOffset(g_gs_renderer->m_scanmask_used);
+		g_gs_renderer->PCRTCDisplays.CalculateFramebufferOffset(g_gs_renderer->m_scanmask_used);
+	}
+
+	if (g_gs_stream)
+	{
+		auto *f = g_gs_stream.get();
+
+		const uint8_t priv_type = 3;
+		fwrite(&priv_type, sizeof(priv_type), 1, f);
+
+#ifdef HAVE_PARALLEL_GS
+		if (g_pgs_renderer)
+			fwrite(g_pgs_renderer->GetRegsMem(), sizeof(GSPrivRegSet), 1, f);
+		else
+#endif
+		{
+			fwrite(g_gs_renderer->GetRegsMem(), sizeof(GSPrivRegSet), 1, f);
+		}
+
+		const uint8_t type = 1;
+		fwrite(&type, sizeof(type), 1, f);
+		const uint8_t u8_field = field;
+		fwrite(&u8_field, sizeof(u8_field), 1, f);
+	}
+
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		g_pgs_renderer->VSync(field, registers_written);
+#endif
 
 	// Do not move the flush into the VSync() method. It's here because EE transfers
 	// get cleared in HW VSync, and may be needed for a buffered draw (FFX FMVs).
-	g_gs_renderer->Flush(GSState::VSYNC);
-	g_gs_renderer->VSync(field, registers_written, g_gs_renderer->IsIdleFrame());
+	if (g_gs_renderer)
+	{
+		g_gs_renderer->Flush(GSState::VSYNC);
+		g_gs_renderer->VSync(field, registers_written, g_gs_renderer->IsIdleFrame());
+	}
 }
 
 int GSfreeze(FreezeAction mode, freezeData* data)
 {
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+	{
+		if (mode == FreezeAction::Save)
+			return g_pgs_renderer->Freeze(data, false);
+		else if (mode == FreezeAction::Size)
+			return g_pgs_renderer->Freeze(data, true);
+		else // if (mode == FreezeAction::Load)
+			return g_pgs_renderer->Defrost(data);
+	}
+#endif
+
+	if (!g_gs_renderer)
+		return -1;
+
 	if (mode == FreezeAction::Save)
 	{
 		return g_gs_renderer->Freeze(data, false);
@@ -478,6 +679,10 @@ int GSfreeze(FreezeAction mode, freezeData* data)
 
 void GSQueueSnapshot(const std::string& path, u32 gsdump_frames)
 {
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		g_pgs_renderer->QueueSnapshot(GSGetBaseSnapshotFilename(), gsdump_frames);
+#endif
 	if (g_gs_renderer)
 		g_gs_renderer->QueueSnapshot(path, gsdump_frames);
 }
@@ -504,11 +709,15 @@ void GSEndCapture()
 
 void GSPresentCurrentFrame()
 {
-	g_gs_renderer->PresentCurrentFrame();
+	if (g_gs_renderer)
+		g_gs_renderer->PresentCurrentFrame();
 }
 
 void GSThrottlePresentation()
 {
+	if (!g_gs_device)
+		return;
+
 	if (g_gs_device->GetVSyncMode() == GSVSyncMode::FIFO)
 	{
 		// Let vsync take care of throttling.
@@ -529,25 +738,49 @@ void GSGameChanged()
 
 bool GSHasDisplayWindow()
 {
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		return g_pgs_renderer->GetWindowInfo().type != WindowInfo::Type::Surfaceless;
+#else
 	pxAssert(g_gs_device);
-	return (g_gs_device->GetWindowInfo().type != WindowInfo::Type::Surfaceless);
+#endif
+
+	if (g_gs_device)
+		return (g_gs_device->GetWindowInfo().type != WindowInfo::Type::Surfaceless);
+	else
+		return false;
 }
 
 void GSResizeDisplayWindow(int width, int height, float scale)
 {
-	g_gs_device->ResizeWindow(width, height, scale);
-	ImGuiManager::WindowResized();
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		g_pgs_renderer->ResizeWindow(width, height, scale);
+#endif
+	if (g_gs_device)
+	{
+		g_gs_device->ResizeWindow(width, height, scale);
+		ImGuiManager::WindowResized();
+	}
 }
 
 void GSUpdateDisplayWindow()
 {
-	if (!g_gs_device->UpdateWindow())
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+	{
+		g_pgs_renderer->UpdateWindow();
+	}
+#endif
+
+	if (g_gs_device && !g_gs_device->UpdateWindow())
 	{
 		Host::ReportErrorAsync("Error", TRANSLATE_SV("GS", "Failed to change window after update. The log may contain more information."));
 		return;
 	}
 
-	ImGuiManager::WindowResized();
+	if (g_gs_device)
+		ImGuiManager::WindowResized();
 }
 
 void GSSetVSyncMode(GSVSyncMode mode, bool allow_present_throttle)
@@ -559,7 +792,12 @@ void GSSetVSyncMode(GSVSyncMode mode, bool allow_present_throttle)
 	}};
 	Console.WriteLnFmt(Color_StrongCyan, "Setting vsync mode: {}{}", modes[static_cast<size_t>(mode)],
 		allow_present_throttle ? " (throttle allowed)" : "");
-	g_gs_device->SetVSyncMode(mode, allow_present_throttle);
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		g_pgs_renderer->SetVSyncMode(mode, allow_present_throttle);
+#endif
+	if (g_gs_device)
+		g_gs_device->SetVSyncMode(mode, allow_present_throttle);
 }
 
 bool GSWantsExclusiveFullscreen()
@@ -608,6 +846,19 @@ std::vector<GSAdapterInfo> GSGetAdapterInfo(GSRendererType renderer)
 		break;
 #endif
 
+#ifdef HAVE_PARALLEL_GS
+		case GSRendererType::ParallelGS:
+		{
+			// Dummy info.
+			GSAdapterInfo adapter = {};
+			adapter.name = "default";
+			adapter.fullscreen_modes = { "fullscreen" };
+			adapter.max_texture_size = 4096;
+			adapter.max_upscale_multiplier = 4;
+			return { adapter };
+		}
+#endif
+
 #ifdef __APPLE__
 		case GSRendererType::Metal:
 		{
@@ -631,13 +882,29 @@ u32 GSGetMaxUpscaleMultiplier(u32 max_texture_size)
 
 GSVideoMode GSgetDisplayMode()
 {
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		return GSVideoMode{};
+#endif
+
 	GSRenderer* gs = g_gs_renderer.get();
 
-	return gs->GetVideoMode();
+	if (gs)
+		return gs->GetVideoMode();
+	else
+		return GSVideoMode{};
 }
 
 void GSgetInternalResolution(int* width, int* height)
 {
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+	{
+		g_pgs_renderer->GetInternalResolution(width, height);
+		return;
+	}
+#endif
+
 	GSRenderer* gs = g_gs_renderer.get();
 	if (!gs)
 	{
@@ -758,8 +1025,11 @@ void GSUpdateConfig(const Pcsx2Config::GSOptions& new_config)
 {
 	Pcsx2Config::GSOptions old_config(std::move(GSConfig));
 	GSConfig = new_config;
-	if (!g_gs_renderer)
-		return;
+
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		g_pgs_renderer->UpdateConfig();
+#endif
 
 	// Handle OSD scale changes by pushing a window resize through.
 	if (new_config.OsdScale != old_config.OsdScale)
@@ -773,6 +1043,9 @@ void GSUpdateConfig(const Pcsx2Config::GSOptions& new_config)
 		return;
 	}
 
+	if (!g_gs_renderer)
+		return;
+
 	// Ensure upscale multiplier is in range.
 	GSClampUpscaleMultiplier(GSConfig);
 
diff --git a/pcsx2/GS/GS.h b/pcsx2/GS/GS.h
index 81b97650e3..93c01f526d 100644
--- a/pcsx2/GS/GS.h
+++ b/pcsx2/GS/GS.h
@@ -20,6 +20,7 @@ enum class RenderAPI
 	Metal,
 	D3D12,
 	Vulkan,
+	Granite,
 	OpenGL
 };
 
@@ -110,6 +111,8 @@ bool GSSaveSnapshotToMemory(u32 window_width, u32 window_height, bool apply_aspe
 	u32* width, u32* height, std::vector<u32>* pixels);
 void GSJoinSnapshotThreads();
 
+float GetCurrentAspectRatioFloat(bool is_progressive);
+
 namespace Host
 {
 	/// Called when the GS is creating a render device.
diff --git a/pcsx2/GS/GSState.cpp b/pcsx2/GS/GSState.cpp
index 6c500c2ab0..50e9eb12ac 100644
--- a/pcsx2/GS/GSState.cpp
+++ b/pcsx2/GS/GSState.cpp
@@ -27,7 +27,7 @@ static __fi bool IsAutoFlushEnabled()
 	return GSIsHardwareRenderer() ? (GSConfig.UserHacks_AutoFlush != GSHWAutoFlushLevel::Disabled) : GSConfig.AutoFlushSW;
 }
 
-constexpr int GSState::GetSaveStateSize(int version)
+int GSState::GetSaveStateSize(int version)
 {
 	int size = 0;
 
diff --git a/pcsx2/GS/GSState.h b/pcsx2/GS/GSState.h
index e9e6e3ffdf..bee68a77f2 100644
--- a/pcsx2/GS/GSState.h
+++ b/pcsx2/GS/GSState.h
@@ -21,7 +21,7 @@ public:
 	GSState();
 	virtual ~GSState();
 
-	static constexpr int GetSaveStateSize(int version);
+	static int GetSaveStateSize(int version);
 
 private:
 	// RESTRICT prevents multiple loads of the same part of the register when accessing its bitfields (the compiler is happy to know that memory writes in-between will not go there)
diff --git a/pcsx2/GS/GSUtil.cpp b/pcsx2/GS/GSUtil.cpp
index 17a00f4143..2171c5dcc0 100644
--- a/pcsx2/GS/GSUtil.cpp
+++ b/pcsx2/GS/GSUtil.cpp
@@ -163,7 +163,9 @@ GSRendererType GSUtil::GetPreferredRenderer()
 	static GSRendererType preferred_renderer = GSRendererType::Auto;
 	if (preferred_renderer == GSRendererType::Auto)
 	{
-#if defined(__APPLE__)
+#if defined(HAVE_PARALLEL_GS)
+		preferred_renderer = GSRendererType::ParallelGS;
+#elif defined(__APPLE__)
 		// Mac: Prefer Metal hardware.
 		preferred_renderer = GSRendererType::Metal;
 #elif defined(_WIN32) && defined(_M_ARM64)
diff --git a/pcsx2/GS/Renderers/Common/GSRenderer.cpp b/pcsx2/GS/Renderers/Common/GSRenderer.cpp
index 55bcf38889..958686a4d2 100644
--- a/pcsx2/GS/Renderers/Common/GSRenderer.cpp
+++ b/pcsx2/GS/Renderers/Common/GSRenderer.cpp
@@ -278,7 +278,7 @@ float GSRenderer::GetModXYOffset()
 	return 0.0f;
 }
 
-static float GetCurrentAspectRatioFloat(bool is_progressive)
+float GetCurrentAspectRatioFloat(bool is_progressive)
 {
 	switch (GSConfig.AspectRatio)
 	{
diff --git a/pcsx2/GS/Renderers/Vulkan/VKLoader.cpp b/pcsx2/GS/Renderers/Vulkan/VKLoader.cpp
index 164ca0f897..b6145f273e 100644
--- a/pcsx2/GS/Renderers/Vulkan/VKLoader.cpp
+++ b/pcsx2/GS/Renderers/Vulkan/VKLoader.cpp
@@ -16,6 +16,8 @@
 
 extern "C" {
 
+#ifndef HAVE_PARALLEL_GS
+// Crude hack, but this conflicts with volk.
 #define VULKAN_MODULE_ENTRY_POINT(name, required) PFN_##name name;
 #define VULKAN_INSTANCE_ENTRY_POINT(name, required) PFN_##name name;
 #define VULKAN_DEVICE_ENTRY_POINT(name, required) PFN_##name name;
@@ -23,6 +25,7 @@ extern "C" {
 #undef VULKAN_DEVICE_ENTRY_POINT
 #undef VULKAN_INSTANCE_ENTRY_POINT
 #undef VULKAN_MODULE_ENTRY_POINT
+#endif
 }
 
 void Vulkan::ResetVulkanLibraryFunctionPointers()
@@ -79,7 +82,10 @@ bool Vulkan::LoadVulkanLibrary(Error* error)
 
 	if (required_functions_missing)
 	{
+#ifndef HAVE_PARALLEL_GS
+		// FIXME: parallel-gs share volk global pointers.
 		ResetVulkanLibraryFunctionPointers();
+#endif
 		s_vulkan_library.Close();
 		return false;
 	}
@@ -89,7 +95,10 @@ bool Vulkan::LoadVulkanLibrary(Error* error)
 
 void Vulkan::UnloadVulkanLibrary()
 {
+#ifndef HAVE_PARALLEL_GS
+	// FIXME: parallel-gs share volk global pointers.
 	ResetVulkanLibraryFunctionPointers();
+#endif
 	s_vulkan_library.Close();
 }
 
@@ -97,8 +106,13 @@ bool Vulkan::LoadVulkanInstanceFunctions(VkInstance instance)
 {
 	bool required_functions_missing = false;
 	auto LoadFunction = [&required_functions_missing, instance](PFN_vkVoidFunction* func_ptr, const char* name, bool is_required) {
-		*func_ptr = vkGetInstanceProcAddr(instance, name);
-		if (!(*func_ptr) && is_required)
+		auto proc = vkGetInstanceProcAddr(instance, name);
+		// Only override the global pointer if the pointer is non-null. This avoids a problem where GetAdapters()
+		// tries to load KHR_surface functions but fails since VK_KHR_surface is not enabled.
+		// Temporary hack for parallel-gs interoperability since they share volk implementation.
+		if (proc)
+			*func_ptr = proc;
+		if (!proc && is_required)
 		{
 			std::fprintf(stderr, "Vulkan: Failed to load required instance function %s\n", name);
 			required_functions_missing = true;
diff --git a/pcsx2/GS/Renderers/Vulkan/VKLoader.h b/pcsx2/GS/Renderers/Vulkan/VKLoader.h
index d1a09d5e14..933ce5e171 100644
--- a/pcsx2/GS/Renderers/Vulkan/VKLoader.h
+++ b/pcsx2/GS/Renderers/Vulkan/VKLoader.h
@@ -7,24 +7,7 @@ class Error;
 
 #define VK_NO_PROTOTYPES
 
-#ifdef _WIN32
-#define VK_USE_PLATFORM_WIN32_KHR
-
-// vulkan.h pulls in windows.h on Windows, so we need to include our replacement header first
-#include "common/RedtapeWindows.h"
-#endif
-
-#if defined(X11_API)
-#define VK_USE_PLATFORM_XLIB_KHR
-#endif
-
-#if defined(WAYLAND_API)
-#define VK_USE_PLATFORM_WAYLAND_KHR
-#endif
-
-#if defined(__APPLE__)
-#define VK_USE_PLATFORM_METAL_EXT
-#endif
+#include "VKLoaderPlatformDefines.h"
 
 #include "vulkan/vulkan.h"
 
diff --git a/pcsx2/GS/Renderers/Vulkan/VKLoaderPlatformDefines.h b/pcsx2/GS/Renderers/Vulkan/VKLoaderPlatformDefines.h
new file mode 100644
index 0000000000..d3447f6f7d
--- /dev/null
+++ b/pcsx2/GS/Renderers/Vulkan/VKLoaderPlatformDefines.h
@@ -0,0 +1,23 @@
+// SPDX-FileCopyrightText: 2002-2024 PCSX2 Dev Team
+// SPDX-License-Identifier: LGPL-3.0+
+#pragma once
+
+#ifdef _WIN32
+#define VK_USE_PLATFORM_WIN32_KHR
+
+// vulkan.h pulls in windows.h on Windows, so we need to include our replacement header first
+#include "common/RedtapeWindows.h"
+#endif
+
+#if defined(X11_API)
+#define VK_USE_PLATFORM_XLIB_KHR
+#endif
+
+#if defined(WAYLAND_API)
+#define VK_USE_PLATFORM_WAYLAND_KHR
+#endif
+
+#if defined(__APPLE__)
+#define VK_USE_PLATFORM_METAL_EXT
+#endif
+
diff --git a/pcsx2/GS/Renderers/parallel-gs/GSRendererPGS.cpp b/pcsx2/GS/Renderers/parallel-gs/GSRendererPGS.cpp
new file mode 100644
index 0000000000..42ca38d80c
--- /dev/null
+++ b/pcsx2/GS/Renderers/parallel-gs/GSRendererPGS.cpp
@@ -0,0 +1,856 @@
+// SPDX-FileCopyrightText: 2024 Hans-Kristian Arntzen
+// SPDX-License-Identifier: LGPL-3.0+
+
+#include "GSRendererPGS.h"
+#include "GS/GSState.h"
+#include "GS.h"
+#include "math.hpp"
+#include "muglm/muglm_impl.hpp"
+#include "shaders/slangmosh.hpp"
+#include "PerformanceMetrics.h"
+#include "VMManager.h"
+
+// Workaround because msbuild is broken when mixing C and C++ it seems ...
+#ifdef _MSC_VER
+extern "C" {
+#include "volk.c"
+}
+#endif
+
+using namespace Vulkan;
+using namespace ParallelGS;
+using namespace Granite;
+
+static void FsrEasuCon(
+	float *con0,
+	float *con1,
+	float *con2,
+	float *con3,
+	float inputViewportInPixelsX,
+	float inputViewportInPixelsY,
+	float inputSizeInPixelsX,
+	float inputSizeInPixelsY,
+	float outputSizeInPixelsX,
+	float outputSizeInPixelsY)
+{
+	// Output integer position to a pixel position in viewport.
+	con0[0] = inputViewportInPixelsX / outputSizeInPixelsX;
+	con0[1] = inputViewportInPixelsY / outputSizeInPixelsY;
+	con0[2] = 0.5f * inputViewportInPixelsX / outputSizeInPixelsX - 0.5f;
+	con0[3] = 0.5f * inputViewportInPixelsY / outputSizeInPixelsY - 0.5f;
+	con1[0] = 1.0f / inputSizeInPixelsX;
+	con1[1] = 1.0f / inputSizeInPixelsY;
+	con1[2] = 1.0f / inputSizeInPixelsX;
+	con1[3] = -1.0f / inputSizeInPixelsY;
+	con2[0] = -1.0f / inputSizeInPixelsX;
+	con2[1] = 2.0f / inputSizeInPixelsY;
+	con2[2] = 1.0f / inputSizeInPixelsX;
+	con2[3] = 2.0f / inputSizeInPixelsY;
+	con3[0] = 0.0f / inputSizeInPixelsX;
+	con3[1] = 4.0f / inputSizeInPixelsY;
+	con3[2] = con3[3] = 0.0f;
+}
+
+static void FsrRcasCon(float *con, float sharpness)
+{
+	sharpness = muglm::exp2(-sharpness);
+	uint32_t half = floatToHalf(sharpness);
+	con[0] = sharpness;
+	uint32_t halves = half | (half << 16);
+	memcpy(&con[1], &halves, sizeof(halves));
+	con[2] = 0.0f;
+	con[3] = 0.0f;
+}
+
+void GSRendererPGS::render_fsr(CommandBuffer &cmd, const ImageView &view)
+{
+	cmd.image_barrier(*fsr_render_target,
+		VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,
+		VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, 0,
+		VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT);
+
+	RenderPassInfo rp = {};
+	rp.num_color_attachments = 1;
+	rp.color_attachments[0] = &fsr_render_target->get_view();
+	rp.store_attachments = 1u << 0;
+
+	cmd.begin_render_pass(rp);
+	{
+		struct Constants
+		{
+			float params[4][4];
+		} constants;
+
+
+		auto width = float(view.get_image().get_width());
+		auto height = float(view.get_image().get_height());
+		auto *params = cmd.allocate_typed_constant_data<Constants>(1, 0, 1);
+		FsrEasuCon(constants.params[0], constants.params[1], constants.params[2], constants.params[3],
+			width, height, width, height, cmd.get_viewport().width, cmd.get_viewport().height);
+		*params = constants;
+
+		struct Push
+		{
+			float width, height;
+		} push;
+
+		push.width = cmd.get_viewport().width;
+		push.height = cmd.get_viewport().height;
+		cmd.push_constants(&push, 0, sizeof(push));
+
+		const vec2 vertex_data[] = { vec2(-1.0f, -1.0f), vec2(-1.0f, 3.0f), vec2(3.0f, -1.0f) };
+		memcpy(cmd.allocate_vertex_data(0, sizeof(vertex_data), sizeof(vec2)), vertex_data, sizeof(vertex_data));
+		cmd.set_vertex_attrib(0, 0, VK_FORMAT_R32G32_SFLOAT, 0);
+
+		cmd.set_texture(0, 0, view, StockSampler::NearestClamp);
+
+		cmd.set_program(upscale_program);
+		cmd.set_opaque_state();
+		cmd.set_depth_test(false, false);
+		cmd.draw(3);
+	}
+	cmd.end_render_pass();
+
+	cmd.image_barrier(*fsr_render_target,
+		VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
+		VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,
+		VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, VK_ACCESS_2_SHADER_SAMPLED_READ_BIT);
+}
+
+void GSRendererPGS::render_rcas(CommandBuffer &cmd, const ImageView &view,
+                                float offset_x, float offset_y,
+                                float width, float height)
+{
+	struct Constants
+	{
+		float params[4];
+		int32_t range[4];
+	} constants;
+
+	FsrRcasCon(constants.params, 0.5f);
+	constants.range[0] = 0;
+	constants.range[1] = 0;
+	constants.range[2] = int(view.get_view_width()) - 1;
+	constants.range[3] = int(view.get_view_height()) - 1;
+	auto *params = cmd.allocate_typed_constant_data<Constants>(1, 0, 1);
+	*params = constants;
+
+	const vec2 vertex_data[] = { vec2(-1.0f, -1.0f), vec2(-1.0f, 3.0f), vec2(3.0f, -1.0f) };
+	memcpy(cmd.allocate_vertex_data(0, sizeof(vertex_data), sizeof(vec2)), vertex_data, sizeof(vertex_data));
+	cmd.set_vertex_attrib(0, 0, VK_FORMAT_R32G32_SFLOAT, 0);
+	cmd.set_srgb_texture(0, 0, view);
+	cmd.set_sampler(0, 0, Vulkan::StockSampler::NearestClamp);
+	cmd.set_opaque_state();
+	cmd.set_depth_test(false, false);
+	cmd.set_program(sharpen_program);
+
+	struct Push
+	{
+		float width, height;
+	} push;
+
+	push.width = width;
+	push.height = height;
+	cmd.push_constants(&push, 0, sizeof(push));
+
+	cmd.set_viewport({ offset_x, offset_y, width, height, 0.0f, 1.0f });
+	cmd.draw(3);
+}
+
+void GSRendererPGS::render_blit(CommandBuffer &cmd, const ImageView &view,
+                                float offset_x, float offset_y,
+                                float width, float height)
+{
+	cmd.set_srgb_texture(0, 0, view);
+	cmd.set_sampler(0, 0, GSConfig.LinearPresent != GSPostBilinearMode::Off ?
+	                      Vulkan::StockSampler::LinearClamp : Vulkan::StockSampler::NearestClamp);
+	cmd.set_opaque_state();
+	cmd.set_depth_test(false, false);
+	cmd.set_program(blit_program);
+
+	cmd.set_viewport({ offset_x, offset_y, width, height, 0.0f, 1.0f });
+	cmd.draw(3);
+}
+
+GSRendererPGS::GSRendererPGS(u8 *basemem)
+	: priv(reinterpret_cast<PrivRegisterState *>(basemem))
+{
+	wsi.set_backbuffer_format(BackbufferFormat::sRGB);
+}
+
+u8 *GSRendererPGS::GetRegsMem()
+{
+	return reinterpret_cast<u8 *>(priv);
+}
+
+struct ParsedSuperSampling
+{
+	SuperSampling super_sampling;
+	bool ordered;
+};
+
+static ParsedSuperSampling parse_super_sampling_options(u8 super_sampling)
+{
+	ParsedSuperSampling parsed = {};
+
+	if (super_sampling > 5)
+		super_sampling = 5;
+
+	parsed.ordered = super_sampling == 3;
+
+	if (super_sampling >= 3)
+		super_sampling--;
+	parsed.super_sampling = SuperSampling(1u << super_sampling);
+
+	return parsed;
+}
+
+bool GSRendererPGS::Init()
+{
+	// Always force the reload, since the other backends may clobber the volk pointers.
+	if (!Context::init_loader(nullptr, true))
+		return false;
+
+	wsi.set_platform(this);
+	wsi.set_frame_duplication_aware(true);
+	bool ret = wsi.init_simple(1, {});
+	if (!ret)
+		return false;
+
+	// We will cycle through many memory contexts per frame most likely.
+	wsi.get_device().init_frame_contexts(12);
+
+	ResourceLayout layout;
+	Shaders<> suite(wsi.get_device(), layout, 0);
+	upscale_program = wsi.get_device().request_program(suite.upscale_vert, suite.upscale_frag);
+	sharpen_program = wsi.get_device().request_program(suite.sharpen_vert, suite.sharpen_frag);
+	blit_program = wsi.get_device().request_program(suite.quad, suite.blit);
+
+	GSOptions opts = {};
+	opts.vram_size = GSLocalMemory::m_vmsize;
+
+	auto parsed = parse_super_sampling_options(GSConfig.PGSSuperSampling);
+	opts.super_sampling = parsed.super_sampling;
+	opts.ordered_super_sampling = parsed.ordered;
+
+	opts.dynamic_super_sampling = true;
+	opts.super_sampled_textures = GSConfig.PGSSuperSampleTextures != 0;
+	if (!iface.init(&wsi.get_device(), opts))
+		return false;
+
+	current_super_sampling = opts.super_sampling;
+	current_ordered_super_sampling = opts.ordered_super_sampling;
+	current_super_sample_textures = opts.super_sampled_textures;
+
+	Hacks hacks;
+	hacks.disable_mipmaps = GSConfig.PGSDisableMipmaps != 0;
+	hacks.unsynced_readbacks = GSConfig.PGSDisableReadbackSync != 0;
+	hacks.backbuffer_promotion = GSConfig.PGSSharpBackbuffer != 0;
+	hacks.allow_blend_demote = GSConfig.PGSBlendDemotion != 0;
+	iface.set_hacks(hacks);
+
+	return true;
+}
+
+void GSRendererPGS::Reset(bool /*hardware_reset*/)
+{
+	iface.reset_context_state();
+}
+
+void GSRendererPGS::UpdateConfig()
+{
+	auto parsed = parse_super_sampling_options(GSConfig.PGSSuperSampling);
+
+	if (parsed.super_sampling != current_super_sampling || parsed.ordered != current_ordered_super_sampling ||
+	    current_super_sample_textures != bool(GSConfig.PGSSuperSampleTextures))
+	{
+		iface.set_super_sampling_rate(parsed.super_sampling, parsed.ordered, GSConfig.PGSSuperSampleTextures != 0);
+		current_super_sampling = parsed.super_sampling;
+		current_ordered_super_sampling = parsed.ordered;
+		current_super_sample_textures = GSConfig.PGSSuperSampleTextures != 0;
+	}
+
+	Hacks hacks;
+	hacks.disable_mipmaps = GSConfig.PGSDisableMipmaps != 0;
+	hacks.unsynced_readbacks = GSConfig.PGSDisableReadbackSync != 0;
+	hacks.backbuffer_promotion = GSConfig.PGSSharpBackbuffer != 0;
+	hacks.allow_blend_demote = GSConfig.PGSBlendDemotion != 0;
+	iface.set_hacks(hacks);
+}
+
+int GSRendererPGS::GetSaveStateSize(int version)
+{
+	return GSState::GetSaveStateSize(version);
+}
+
+static void write_data(u8*& dst, const void* src, size_t size)
+{
+	memcpy(dst, src, size);
+	dst += size;
+}
+
+template <typename T>
+static void write_reg(u8*& data, T t)
+{
+	write_data(data, &t, sizeof(t));
+}
+
+static void read_data(const u8*& src, void* dst, size_t size)
+{
+	memcpy(dst, src, size);
+	src += size;
+}
+
+template <typename T>
+static void read_reg(const u8*& src, T &t)
+{
+	read_data(src, &t, sizeof(t));
+}
+
+int GSRendererPGS::Freeze(freezeData* data, bool sizeonly)
+{
+	constexpr uint32_t version = 8; // v9 doesn't add anything meaningful for us.
+	if (sizeonly)
+	{
+		data->size = GetSaveStateSize(version);
+		return 0;
+	}
+
+	if (!data->data || data->size < GetSaveStateSize(version))
+		return -1;
+
+	const void *vram = iface.map_vram_read(0, GSLocalMemory::m_vmsize);
+	auto &regs = iface.get_register_state();
+
+	u8 *ptr = data->data;
+
+	write_reg(ptr, version);
+	write_reg(ptr, regs.prim);
+	write_reg(ptr, regs.prmodecont);
+	write_reg(ptr, regs.texclut);
+	write_reg(ptr, regs.scanmsk);
+	write_reg(ptr, regs.texa);
+	write_reg(ptr, regs.fogcol);
+	write_reg(ptr, regs.dimx);
+	write_reg(ptr, regs.dthe);
+	write_reg(ptr, regs.colclamp);
+	write_reg(ptr, regs.pabe);
+	write_reg(ptr, regs.bitbltbuf);
+	write_reg(ptr, regs.trxdir);
+	write_reg(ptr, regs.trxpos);
+	write_reg(ptr, regs.trxreg);
+	write_reg(ptr, regs.trxreg); // Dummy value
+
+	for (const auto &ctx : regs.ctx)
+	{
+		write_reg(ptr, ctx.xyoffset);
+		write_reg(ptr, ctx.tex0);
+		write_reg(ptr, ctx.tex1);
+		write_reg(ptr, ctx.clamp);
+		write_reg(ptr, ctx.miptbl_1_3);
+		write_reg(ptr, ctx.miptbl_4_6);
+		write_reg(ptr, ctx.scissor);
+		write_reg(ptr, ctx.alpha);
+		write_reg(ptr, ctx.test);
+		write_reg(ptr, ctx.fba);
+		write_reg(ptr, ctx.frame);
+		write_reg(ptr, ctx.zbuf);
+	}
+
+	write_reg(ptr, regs.rgbaq);
+	write_reg(ptr, regs.st);
+	write_reg(ptr, regs.uv.words[0]);
+	write_reg(ptr, regs.fog.words[0]);
+	// XYZ register, fill with dummy.
+	write_reg(ptr, Reg64<XYZBits>{0});
+
+	write_reg(ptr, UINT32_MAX); // Dummy GIFReg
+	write_reg(ptr, UINT32_MAX);
+
+	// Dummy transfer X/Y
+	write_reg(ptr, uint32_t(0));
+	write_reg(ptr, uint32_t(0));
+
+	// v9 adds a lot more dummy stuff here which we don't care about
+
+	write_data(ptr, vram, GSLocalMemory::m_vmsize);
+
+	// 4 GIF paths
+	for (int i = 0; i < 4; i++)
+	{
+		auto gif_path = iface.get_gif_path(i);
+		gif_path.tag.NLOOP -= gif_path.loop;
+		write_data(ptr, &gif_path.tag, sizeof(gif_path.tag));
+		write_reg(ptr, gif_path.reg);
+	}
+
+	// internal_Q
+	write_reg(ptr, regs.internal_q);
+	return 0;
+}
+
+int GSRendererPGS::Defrost(freezeData* data)
+{
+	constexpr uint32_t expected_version = 8; // v9 doesn't add anything meaningful for us.
+
+	if (!data || !data->data || data->size == 0)
+		return -1;
+
+	if (data->size < GetSaveStateSize(expected_version))
+		return -1;
+
+	const u8* ptr = data->data;
+	auto &regs = iface.get_register_state();
+
+	u32 version;
+	read_reg(ptr, version);
+
+	if (version != expected_version && version != GSState::STATE_VERSION)
+	{
+		Console.Error("GS: Savestate version is incompatible.  Load aborted.");
+		return -1;
+	}
+
+	read_reg(ptr, regs.prim);
+	read_reg(ptr, regs.prmodecont);
+	read_reg(ptr, regs.texclut);
+	read_reg(ptr, regs.scanmsk);
+	read_reg(ptr, regs.texa);
+	read_reg(ptr, regs.fogcol);
+	read_reg(ptr, regs.dimx);
+	read_reg(ptr, regs.dthe);
+	read_reg(ptr, regs.colclamp);
+	read_reg(ptr, regs.pabe);
+	read_reg(ptr, regs.bitbltbuf);
+	read_reg(ptr, regs.trxdir);
+	read_reg(ptr, regs.trxpos);
+	read_reg(ptr, regs.trxreg);
+	// Dummy value
+	ptr += sizeof(uint64_t);
+
+	for (auto &ctx : regs.ctx)
+	{
+		read_reg(ptr, ctx.xyoffset);
+		read_reg(ptr, ctx.tex0);
+		read_reg(ptr, ctx.tex1);
+		read_reg(ptr, ctx.clamp);
+		read_reg(ptr, ctx.miptbl_1_3);
+		read_reg(ptr, ctx.miptbl_4_6);
+		read_reg(ptr, ctx.scissor);
+		read_reg(ptr, ctx.alpha);
+		read_reg(ptr, ctx.test);
+		read_reg(ptr, ctx.fba);
+		read_reg(ptr, ctx.frame);
+		read_reg(ptr, ctx.zbuf);
+	}
+
+	read_reg(ptr, regs.rgbaq);
+	read_reg(ptr, regs.st);
+	read_reg(ptr, regs.uv.words[0]);
+	read_reg(ptr, regs.fog.words[0]);
+	// XYZ register, fill with dummy.
+	ptr += sizeof(uint64_t);
+
+	// Dummy GIFReg
+	ptr += 2 * sizeof(uint32_t);
+
+	// Dummy transfer X/Y
+	ptr += 2 * sizeof(uint32_t);
+
+	if (version >= 9)
+	{
+		// Dummy transfer params. Just skip those until we know what to do about them.
+		ptr += GetSaveStateSize(version) - GetSaveStateSize(expected_version);
+	}
+
+	void *vram = iface.map_vram_write(0, GSLocalMemory::m_vmsize);
+	read_data(ptr, vram, GSLocalMemory::m_vmsize);
+	iface.end_vram_write(0, GSLocalMemory::m_vmsize);
+
+	// 4 GIF paths
+	for (int i = 0; i < 4; i++)
+	{
+		auto gif_path = iface.get_gif_path(i);
+		gif_path.tag.NLOOP -= gif_path.loop;
+		read_data(ptr, &gif_path.tag, sizeof(gif_path.tag));
+		gif_path.loop = 0;
+		read_reg(ptr, gif_path.reg);
+	}
+
+	// internal_Q
+	read_reg(ptr, iface.get_register_state().internal_q);
+
+	iface.clobber_register_state();
+	return 0;
+}
+
+void GSRendererPGS::VSync(u32 field, bool registers_written)
+{
+	if (dump)
+	{
+		if (dump->VSync(field, dump_frames == 0, reinterpret_cast<GSPrivRegSet *>(priv)))
+			dump.reset();
+		else if (dump_frames != 0)
+			dump_frames--;
+	}
+
+	iface.flush();
+	iface.get_priv_register_state() = *priv;
+
+	VSyncInfo info = {};
+
+	info.phase = field;
+
+	// Apparently this is needed for some games. It's set by game-fixes.
+	// I assume this problem exists at a higher level than whatever GS controls, so we'll just
+	// apply this hack too.
+	if (GSConfig.InterlaceMode != GSInterlaceMode::Automatic)
+		info.phase ^= (static_cast<int>(GSConfig.InterlaceMode) - 2) & 1;
+
+	info.anti_blur = GSConfig.PCRTCAntiBlur;
+	info.force_progressive = true;
+	info.overscan = GSConfig.PCRTCOverscan;
+	info.crtc_offsets = GSConfig.PCRTCOffsets;
+	info.dst_access = VK_ACCESS_2_SHADER_SAMPLED_READ_BIT;
+	info.dst_stage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;
+	info.dst_layout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
+	// The scaling blur is technically a blur ...
+	info.adapt_to_internal_horizontal_resolution = GSConfig.PCRTCAntiBlur;
+	info.raw_circuit_scanout = true;
+	info.high_resolution_scanout = GSConfig.PGSHighResScanout != 0;
+
+	auto stats = iface.consume_flush_stats();
+	bool frame_is_duped = !registers_written && stats.num_render_passes == 0 && stats.num_copies == 0;
+
+	// Don't waste GPU time scanning out the same thing twice.
+	if (!frame_is_duped || !vsync.image || !iface.vsync_can_skip(info))
+		vsync = iface.vsync(info);
+
+	// Experimental heuristic. If running on an iGPU / APU, we're quite wary about draining the GPU for work
+	// in GPU bound scenarios. This should keep the GPU better fed at the cost of a little more latency.
+	if (wsi.get_device().get_gpu_properties().deviceType == VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU &&
+	    frame_is_duped && !GSConfig.SkipDuplicateFrames)
+	{
+		wsi.set_next_present_is_duplicated();
+	}
+
+	if (GSConfig.SkipDuplicateFrames && has_presented_in_current_swapchain && frame_is_duped)
+	{
+		PerformanceMetrics::Update(false, false, true);
+		return;
+	}
+
+	if (vsync.image)
+	{
+		last_internal_width = vsync.internal_width;
+		last_internal_height = vsync.internal_height;
+		if (vsync.high_resolution_scanout)
+		{
+			last_internal_width *= 2;
+			last_internal_height *= 2;
+		}
+	}
+
+	if (!has_wsi_begin_frame)
+		has_wsi_begin_frame = wsi.begin_frame();
+
+	if (!has_wsi_begin_frame)
+		return;
+
+	auto &dev = wsi.get_device();
+
+	float vp_offset_x = 0.0f;
+	float vp_offset_y = 0.0f;
+	float vp_width = 0.0f;
+	float vp_height = 0.0f;
+
+	if (GSConfig.LinearPresent != GSPostBilinearMode::BilinearSharp || !vsync.image)
+		fsr_render_target.reset();
+
+	bool fsr_render_is_valid = frame_is_duped && bool(fsr_render_target);
+
+	if (vsync.image)
+	{
+		uint32_t fsr_width = dev.get_swapchain_view().get_view_width();
+		uint32_t fsr_height = dev.get_swapchain_view().get_view_height();
+		uint32_t new_width = fsr_width;
+		uint32_t new_height = fsr_height;
+
+		float display_aspect = float(fsr_width) / float(fsr_height);
+		float game_aspect = GetCurrentAspectRatioFloat(priv->smode1.CMOD == 0);
+
+		float horizontal_scanout_ratio = float(vsync.internal_width) / float(vsync.mode_width);
+		float vertical_scanout_ratio = float(vsync.internal_height) / float(vsync.mode_height);
+		game_aspect *= horizontal_scanout_ratio / vertical_scanout_ratio;
+
+		if (display_aspect > game_aspect)
+			new_width = uint32_t(std::round(float(fsr_height) * game_aspect));
+		else
+			new_height = uint32_t(std::round(float(fsr_width) / game_aspect));
+
+		// This won't preserve the aspect ratio necessarily, but eh.
+		if (GSConfig.IntegerScaling)
+		{
+			new_width -= new_width % vsync.image->get_width();
+			new_height -= new_height % vsync.image->get_height();
+			if (new_width == 0)
+				new_width = fsr_width;
+			if (new_height == 0)
+				new_height = fsr_height;
+		}
+
+		vp_offset_x = std::round(0.5f * float(fsr_width - new_width));
+		fsr_width = new_width;
+		vp_offset_y = std::round(0.5f * float(fsr_height - new_height));
+		fsr_height = new_height;
+
+		// Safeguard against ridiculous situations.
+		if (!fsr_width)
+			fsr_width = 1;
+		if (!fsr_height)
+			fsr_height = 1;
+
+		vp_width = float(fsr_width);
+		vp_height = float(fsr_height);
+
+		if (GSConfig.LinearPresent == GSPostBilinearMode::BilinearSharp)
+		{
+			if (!fsr_render_target || fsr_render_target->get_width() != fsr_width || fsr_render_target->get_height() != fsr_height)
+			{
+				auto fsr_info = ImageCreateInfo::render_target(fsr_width, fsr_height, VK_FORMAT_R8G8B8A8_UNORM);
+				fsr_info.initial_layout = VK_IMAGE_LAYOUT_UNDEFINED;
+				fsr_info.usage |= VK_IMAGE_USAGE_SAMPLED_BIT;
+				fsr_info.misc |= IMAGE_MISC_MUTABLE_SRGB_BIT;
+				fsr_render_target = dev.create_image(fsr_info);
+				fsr_render_is_valid = false;
+			}
+		}
+	}
+
+	auto cmd = dev.request_command_buffer();
+	// No need to do the upscaling twice when duping frames.
+	if (vsync.image && fsr_render_target && !fsr_render_is_valid)
+		render_fsr(*cmd, vsync.image->get_view());
+	cmd->begin_render_pass(dev.get_swapchain_render_pass(SwapchainRenderPass::ColorOnly));
+	if (vsync.image)
+	{
+		// The RCAS pass is basically free.
+		if (fsr_render_target)
+			render_rcas(*cmd, fsr_render_target->get_view(), vp_offset_x, vp_offset_y, vp_width, vp_height);
+		else
+			render_blit(*cmd, vsync.image->get_view(), vp_offset_x, vp_offset_y, vp_width, vp_height);
+	}
+	cmd->end_render_pass();
+	dev.submit(cmd);
+
+	wsi.end_frame();
+	has_wsi_begin_frame = false;
+	// For pacing purposes.
+	has_wsi_begin_frame = wsi.begin_frame();
+	has_presented_in_current_swapchain = true;
+
+	PerformanceMetrics::Update(registers_written, stats.num_render_passes != 0, false);
+}
+
+void GSRendererPGS::Transfer(const u8* mem, u32 size)
+{
+	size *= 16;
+	iface.gif_transfer(3, mem, size);
+	if (dump)
+		dump->Transfer(3, mem, size);
+}
+
+void GSRendererPGS::ReadFIFO(u8 *mem, u32 size)
+{
+	iface.read_transfer_fifo(mem, size);
+	if (dump)
+		dump->ReadFIFO(size);
+}
+
+void GSRendererPGS::GetInternalResolution(int *width, int *height)
+{
+	*width = int(last_internal_width);
+	*height = int(last_internal_height);
+}
+
+bool GSRendererPGS::UpdateWindow()
+{
+	iface.flush();
+
+	std::optional<WindowInfo> window = Host::AcquireRenderWindow(true);
+	if (window.has_value())
+	{
+		window_info = window.value();
+		wsi.deinit_surface_and_swapchain();
+		return wsi.init_surface_swapchain();
+	}
+	else
+		return false;
+}
+
+void GSRendererPGS::ResizeWindow(int width, int height, float /*scale*/)
+{
+	resize = true;
+	window_info.surface_width = width;
+	window_info.surface_height = height;
+	// TODO: No idea what to do about scale.
+}
+
+const WindowInfo &GSRendererPGS::GetWindowInfo() const
+{
+	return window_info;
+}
+
+void GSRendererPGS::SetVSyncMode(GSVSyncMode mode, bool /*allow_present_throttle*/)
+{
+	if (mode == GSVSyncMode::FIFO)
+		wsi.set_present_mode(PresentMode::SyncToVBlank);
+	else if (mode == GSVSyncMode::Mailbox)
+		wsi.set_present_mode(PresentMode::UnlockedNoTearing);
+	else
+		wsi.set_present_mode(PresentMode::UnlockedMaybeTear);
+	// Unknown what allow_present_throttle means.
+}
+
+VkSurfaceKHR GSRendererPGS::create_surface(VkInstance instance, VkPhysicalDevice gpu)
+{
+	if (window_info.type == WindowInfo::Type::Surfaceless)
+	{
+		std::optional<WindowInfo> window = Host::AcquireRenderWindow(true);
+		if (window.has_value())
+			window_info = window.value();
+	}
+
+	if (window_info.type == WindowInfo::Type::Surfaceless)
+		return VK_NULL_HANDLE;
+
+#if defined(X11_API)
+	if (window_info.type == WindowInfo::Type::X11)
+	{
+		VkXlibSurfaceCreateInfoKHR info = { VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR };
+		info.dpy = static_cast<Display *>(window_info.display_connection);
+		info.window = reinterpret_cast<Window>(window_info.window_handle);
+		VkSurfaceKHR surface;
+		if (vkCreateXlibSurfaceKHR(instance, &info, nullptr, &surface) == VK_SUCCESS)
+			return surface;
+	}
+#endif
+#if defined(WAYLAND_API)
+	if (window_info.type == WindowInfo::Type::Wayland)
+	{
+		VkWaylandSurfaceCreateInfoKHR info = { VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR };
+		info.display = static_cast<wl_display *>(window_info.display_connection);
+		info.surface = static_cast<wl_surface *>(window_info.window_handle);
+		VkSurfaceKHR surface;
+		if (vkCreateWaylandSurfaceKHR(instance, &info, nullptr, &surface) == VK_SUCCESS)
+			return surface;
+	}
+#endif
+#if defined(_WIN32)
+	if (window_info.type == WindowInfo::Type::Win32)
+	{
+		VkWin32SurfaceCreateInfoKHR info = { VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR };
+		info.hwnd = static_cast<HWND>(window_info.window_handle);
+		VkSurfaceKHR surface;
+		if (vkCreateWin32SurfaceKHR(instance, &info, nullptr, &surface) == VK_SUCCESS)
+			return surface;
+	}
+#endif
+
+	return VK_NULL_HANDLE;
+}
+
+void GSRendererPGS::destroy_surface(VkInstance instance, VkSurfaceKHR surface)
+{
+	WSIPlatform::destroy_surface(instance, surface);
+}
+
+std::vector<const char *> GSRendererPGS::get_instance_extensions()
+{
+	return {
+		VK_KHR_SURFACE_EXTENSION_NAME,
+#if defined(X11_API)
+		VK_KHR_XLIB_SURFACE_EXTENSION_NAME,
+#endif
+#if defined(WAYLAND_API)
+		VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME,
+#endif
+#if defined(_WIN32)
+		VK_KHR_WIN32_SURFACE_EXTENSION_NAME,
+#endif
+	};
+}
+
+std::vector<const char *> GSRendererPGS::get_device_extensions()
+{
+	return { VK_KHR_SWAPCHAIN_EXTENSION_NAME };
+}
+
+bool GSRendererPGS::alive(WSI &)
+{
+	return true;
+}
+
+uint32_t GSRendererPGS::get_surface_width()
+{
+	return window_info.surface_width;
+}
+
+uint32_t GSRendererPGS::get_surface_height()
+{
+	return window_info.surface_height;
+}
+
+void GSRendererPGS::poll_input()
+{
+	// Dummy, we don't care about input here.
+}
+
+void GSRendererPGS::poll_input_async(Granite::InputTrackerHandler *)
+{
+	// Dummy, we don't care about input here.
+}
+
+void GSRendererPGS::event_swapchain_destroyed()
+{
+	WSIPlatform::event_swapchain_destroyed();
+	has_wsi_begin_frame = false;
+	has_presented_in_current_swapchain = false;
+}
+
+void GSRendererPGS::QueueSnapshot(const std::string &path, u32 gsdump_frames)
+{
+	freezeData fd = {0, nullptr};
+	Freeze(&fd, true);
+	fd.data = new u8[fd.size];
+	Freeze(&fd, false);
+
+	if (GSConfig.GSDumpCompression == GSDumpCompressionMethod::Uncompressed)
+	{
+		dump = GSDumpBase::CreateUncompressedDump(path, VMManager::GetDiscSerial(),
+		                                          VMManager::GetDiscCRC(), 0, 0,
+		                                          nullptr, fd, reinterpret_cast<GSPrivRegSet *>(priv));
+	}
+	else if (GSConfig.GSDumpCompression == GSDumpCompressionMethod::LZMA)
+	{
+		dump = GSDumpBase::CreateXzDump(path, VMManager::GetDiscSerial(),
+		                                VMManager::GetDiscCRC(), 0, 0,
+		                                nullptr, fd, reinterpret_cast<GSPrivRegSet *>(priv));
+	}
+	else
+	{
+		dump = GSDumpBase::CreateZstDump(path, VMManager::GetDiscSerial(),
+		                                 VMManager::GetDiscCRC(), 0, 0,
+		                                 nullptr, fd, reinterpret_cast<GSPrivRegSet *>(priv));
+	}
+
+	dump_frames = gsdump_frames;
+	delete[] fd.data;
+}
+
+const VkApplicationInfo *GSRendererPGS::get_application_info()
+{
+	static const VkApplicationInfo app = { VK_STRUCTURE_TYPE_APPLICATION_INFO, nullptr,
+	                                       "pcsx2", 0, "Granite", 0, VK_API_VERSION_1_3 };
+	return &app;
+}
diff --git a/pcsx2/GS/Renderers/parallel-gs/GSRendererPGS.h b/pcsx2/GS/Renderers/parallel-gs/GSRendererPGS.h
new file mode 100644
index 0000000000..0a4eb35588
--- /dev/null
+++ b/pcsx2/GS/Renderers/parallel-gs/GSRendererPGS.h
@@ -0,0 +1,88 @@
+// SPDX-FileCopyrightText: 2024 Hans-Kristian Arntzen
+// SPDX-License-Identifier: LGPL-3.0+
+
+#pragma once
+
+#include "../Vulkan/VKLoaderPlatformDefines.h"
+#include "SaveState.h"
+#include "GS/GSDump.h"
+#include "Config.h"
+#include "common/WindowInfo.h"
+#include "gs_interface.hpp"
+#include "device.hpp"
+#include "context.hpp"
+#include "wsi.hpp"
+
+class GSRendererPGS final : private Vulkan::WSIPlatform
+{
+public:
+	explicit GSRendererPGS(u8 *basemem);
+
+	bool Init();
+	bool UpdateWindow();
+	void ResizeWindow(int width, int height, float scale);
+	const WindowInfo &GetWindowInfo() const;
+	void SetVSyncMode(GSVSyncMode mode, bool allow_present_throttle);
+	void Reset(bool hardware_reset);
+
+	void Transfer(const u8 *mem, u32 size);
+
+	void VSync(u32 field, bool registers_written);
+	inline ParallelGS::GSInterface &get_interface() { return iface; };
+	void ReadFIFO(u8 *mem, u32 size);
+
+	void UpdateConfig();
+
+	void GetInternalResolution(int *width, int *height);
+
+	int Freeze(freezeData *data, bool sizeonly);
+	int Defrost(freezeData *data);
+
+	u8 *GetRegsMem();
+
+	void QueueSnapshot(const std::string &path, u32 gsdump_frames);
+
+private:
+	VkSurfaceKHR create_surface(VkInstance instance, VkPhysicalDevice gpu) override;
+	void destroy_surface(VkInstance instance, VkSurfaceKHR surface) override;
+	std::vector<const char *> get_instance_extensions() override;
+	std::vector<const char *> get_device_extensions() override;
+	bool alive(Vulkan::WSI &wsi) override;
+	uint32_t get_surface_width() override;
+	uint32_t get_surface_height() override;
+	void poll_input() override;
+	void poll_input_async(Granite::InputTrackerHandler *) override;
+
+	ParallelGS::PrivRegisterState *priv;
+	Vulkan::WSI wsi;
+	ParallelGS::GSInterface iface;
+	WindowInfo window_info = {};
+	bool has_wsi_begin_frame = false;
+
+	Vulkan::Program *upscale_program = nullptr;
+	Vulkan::Program *sharpen_program = nullptr;
+	Vulkan::Program *blit_program = nullptr;
+	void render_fsr(Vulkan::CommandBuffer &cmd, const Vulkan::ImageView &view);
+	void render_rcas(Vulkan::CommandBuffer &cmd, const Vulkan::ImageView &view,
+	                 float offset_x, float offset_y,
+	                 float width, float height);
+	void render_blit(Vulkan::CommandBuffer &cmd, const Vulkan::ImageView &view,
+	                 float offset_x, float offset_y,
+	                 float width, float height);
+	void event_swapchain_destroyed() override;
+	Vulkan::ImageHandle fsr_render_target;
+	ParallelGS::ScanoutResult vsync;
+
+	ParallelGS::SuperSampling current_super_sampling = ParallelGS::SuperSampling::X1;
+	bool current_ordered_super_sampling = false;
+	bool current_super_sample_textures = false;
+	bool has_presented_in_current_swapchain = false;
+	uint32_t last_internal_width = 0;
+	uint32_t last_internal_height = 0;
+
+	static int GetSaveStateSize(int version);
+	const VkApplicationInfo* get_application_info() override;
+
+	std::unique_ptr<GSDumpBase> dump;
+	uint32_t dump_frames = 0;
+};
diff --git a/pcsx2/ImGui/ImGuiFullscreen.cpp b/pcsx2/ImGui/ImGuiFullscreen.cpp
index fe73c6ed05..2be0018aef 100644
--- a/pcsx2/ImGui/ImGuiFullscreen.cpp
+++ b/pcsx2/ImGui/ImGuiFullscreen.cpp
@@ -798,6 +798,8 @@ ImGuiFullscreen::FocusResetType ImGuiFullscreen::GetQueuedFocusResetType()
 
 void ImGuiFullscreen::ForceKeyNavEnabled()
 {
+	if (!ImGui::GetCurrentContext())
+		return;
 	ImGuiContext& g = *ImGui::GetCurrentContext();
 	g.ActiveIdSource = (g.ActiveIdSource == ImGuiInputSource_Mouse) ? ImGuiInputSource_Keyboard : g.ActiveIdSource;
 	g.NavInputSource = (g.NavInputSource == ImGuiInputSource_Mouse) ? ImGuiInputSource_Keyboard : g.ActiveIdSource;
diff --git a/pcsx2/Pcsx2Config.cpp b/pcsx2/Pcsx2Config.cpp
index f10c22ba8e..a96556d05a 100644
--- a/pcsx2/Pcsx2Config.cpp
+++ b/pcsx2/Pcsx2Config.cpp
@@ -696,6 +696,7 @@ const char* Pcsx2Config::GSOptions::GetRendererName(GSRendererType type)
 		case GSRendererType::VK:    return "Vulkan";
 		case GSRendererType::SW:    return "Software";
 		case GSRendererType::Null:  return "Null";
+		case GSRendererType::ParallelGS: return "paraLLEl";
 		default:                    return "";
 			// clang-format on
 	}
@@ -878,7 +879,14 @@ bool Pcsx2Config::GSOptions::OptionsAreEqual(const GSOptions& right) const
 		OpEqu(Adapter) &&
 
 		OpEqu(HWDumpDirectory) &&
-		OpEqu(SWDumpDirectory));
+		OpEqu(SWDumpDirectory)) &&
+		OpEqu(PGSSuperSampling) &&
+		OpEqu(PGSHighResScanout) &&
+		OpEqu(PGSSuperSampleTextures) &&
+		OpEqu(PGSDisableMipmaps) &&
+		OpEqu(PGSDisableReadbackSync) &&
+		OpEqu(PGSSharpBackbuffer) &&
+		OpEqu(PGSBlendDemotion);
 }
 
 bool Pcsx2Config::GSOptions::operator!=(const GSOptions& right) const
@@ -961,6 +969,13 @@ void Pcsx2Config::GSOptions::LoadSave(SettingsWrapper& wrap)
 	SettingsWrapBitBool(HWSpinCPUForReadbacks);
 	SettingsWrapBitBoolEx(GPUPaletteConversion, "paltex");
 	SettingsWrapBitBoolEx(AutoFlushSW, "autoflush_sw");
+	SettingsWrapIntEnumEx(PGSSuperSampling, "pgsSuperSampling");
+	SettingsWrapBitBoolEx(PGSHighResScanout, "pgsHighResScanout");
+	SettingsWrapBitBoolEx(PGSSuperSampleTextures, "pgsSuperSampleTextures");
+	SettingsWrapBitBoolEx(PGSDisableMipmaps, "pgsDisableMipmaps");
+	SettingsWrapBitBoolEx(PGSDisableReadbackSync, "pgsDisableReadbackSync");
+	SettingsWrapBitBoolEx(PGSSharpBackbuffer, "pgsSharpBackbuffer");
+	SettingsWrapBitBoolEx(PGSBlendDemotion, "pgsBlendDemotion");
 	SettingsWrapBitBoolEx(PreloadFrameWithGSData, "preload_frame_with_gs_data");
 	SettingsWrapBitBoolEx(Mipmap, "mipmap");
 	SettingsWrapBitBoolEx(ManualUserHacks, "UserHacks");
diff --git a/pcsx2/pcsx2.vcxproj b/pcsx2/pcsx2.vcxproj
index 8875c8465e..e52dc1bf81 100644
--- a/pcsx2/pcsx2.vcxproj
+++ b/pcsx2/pcsx2.vcxproj
@@ -54,6 +54,15 @@
       <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)3rdparty\d3d12memalloc\include</AdditionalIncludeDirectories>
       <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)3rdparty\lzma\include</AdditionalIncludeDirectories>
       <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)3rdparty\freesurround\include</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)pcsx2\GS\parallel-gs\gs</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)pcsx2\GS\parallel-gs\Granite\vulkan</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)pcsx2\GS\parallel-gs\Granite\util</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)pcsx2\GS\parallel-gs\Granite\math</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)pcsx2\GS\parallel-gs\Granite\filesystem</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)pcsx2\GS\parallel-gs\Granite\application\global</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)pcsx2\GS\parallel-gs\Granite\third_party\volk</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)pcsx2\GS\parallel-gs\Granite\third_party\renderdoc</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)pcsx2\GS\parallel-gs\Granite\third_party\stb\stb</AdditionalIncludeDirectories>
       <AdditionalIncludeDirectories Condition="'$(Platform)'=='x64'">%(AdditionalIncludeDirectories);$(SolutionDir)3rdparty\xbyak</AdditionalIncludeDirectories>
       <AdditionalIncludeDirectories Condition="'$(Platform)'=='x64'">%(AdditionalIncludeDirectories);$(SolutionDir)3rdparty\zydis\include;$(SolutionDir)3rdparty\zydis\dependencies\zycore\include</AdditionalIncludeDirectories>
       <AdditionalIncludeDirectories Condition="'$(Platform)'=='ARM64'">%(AdditionalIncludeDirectories);$(SolutionDir)3rdparty\vixl\include</AdditionalIncludeDirectories>
@@ -62,7 +71,7 @@
       <PrecompiledHeader>Use</PrecompiledHeader>
       <PrecompiledHeaderFile>PrecompiledHeader.h</PrecompiledHeaderFile>
       <ForcedIncludeFiles>PrecompiledHeader.h;%(ForcedIncludeFiles)</ForcedIncludeFiles>
-      <PreprocessorDefinitions>C4_NO_DEBUG_BREAK;ST_NO_EXCEPTION_HANDLING;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <PreprocessorDefinitions>HAVE_PARALLEL_GS;C4_NO_DEBUG_BREAK;ST_NO_EXCEPTION_HANDLING;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <PreprocessorDefinitions Condition="'$(Platform)'!='ARM64'">ENABLE_RAINTEGRATION;ENABLE_OPENGL;ENABLE_VULKAN;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <PreprocessorDefinitions Condition="'$(Platform)'=='x64'">XBYAK_NO_EXCEPTION;ZYCORE_STATIC_BUILD;ZYDIS_STATIC_BUILD;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <PreprocessorDefinitions Condition="'$(Platform)'=='ARM64'">VIXL_INCLUDE_TARGET_AARCH64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
@@ -261,6 +270,48 @@
     <ClCompile Include="Gif_Logger.cpp" />
     <ClCompile Include="Gif_Unit.cpp" />
     <ClCompile Include="GSDumpReplayer.cpp" />
+    <ClCompile Include="GS\Renderers\parallel-gs\GSRendererPGS.cpp" />
+    <ClCompile Include="GS\parallel-gs\gs\gs_interface.cpp" />
+    <ClCompile Include="GS\parallel-gs\gs\gs_renderer.cpp" />
+    <ClCompile Include="GS\parallel-gs\gs\gs_util.cpp" />
+    <ClCompile Include="GS\parallel-gs\gs\page_tracker.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\buffer.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\buffer_pool.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\command_buffer.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\command_pool.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\context.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\cookie.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\descriptor_set.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\device.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\event_manager.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\fence.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\fence_manager.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\image.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\indirect_layout.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\memory_allocator.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\pipeline_event.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\query_pool.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\render_pass.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\renderdoc_capture.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\sampler.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\semaphore.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\semaphore_manager.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\shader.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\wsi.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\pipeline_cache.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\texture\memory_mapped_texture.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\texture\texture_files.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\texture\texture_format.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\util\aligned_alloc.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\util\arena_allocator.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\util\logging.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\util\timer.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\util\environment.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\util\timeline_trace_file.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\util\thread_id.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\util\thread_name.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\util\thread_priority.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\util\slab_allocator.cpp" />
     <ClCompile Include="GS\Renderers\DX11\D3D.cpp" />
     <ClCompile Include="GS\Renderers\DX12\GSDevice12.cpp" />
     <ClCompile Include="GS\Renderers\DX12\GSTexture12.cpp" />
-- 
2.50.1

