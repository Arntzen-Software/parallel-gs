From 9c9519d0b1042ba54d947674f2d2b279c0f2dccb Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Sun, 23 Jun 2024 14:54:43 +0200
Subject: [PATCH] Early integration of parallel-GS.

---
 .gitignore                                    |   2 +
 3rdparty/vulkan/include/vulkan/vulkan_core.h  | 219 +++--
 CMakeLists.txt                                |   8 +
 pcsx2-gsrunner/Main.cpp                       |   4 +
 pcsx2-qt/MainWindow.cpp                       |   3 +
 pcsx2-qt/Settings/GraphicsSettingsWidget.cpp  |  52 +-
 pcsx2-qt/Settings/GraphicsSettingsWidget.ui   |  72 ++
 pcsx2-qt/pcsx2-qt.vcxproj                     |   2 +-
 pcsx2/CMakeLists.txt                          |  18 +
 pcsx2/Config.h                                |   4 +
 pcsx2/GS/GS.cpp                               | 379 ++++++--
 pcsx2/GS/GS.h                                 |   3 +
 pcsx2/GS/GSState.cpp                          |   2 +-
 pcsx2/GS/GSState.h                            |   2 +-
 pcsx2/GS/GSUtil.cpp                           |   4 +-
 pcsx2/GS/Renderers/Common/GSRenderer.cpp      |   2 +-
 pcsx2/GS/Renderers/Vulkan/VKLoader.cpp        |  18 +-
 pcsx2/GS/Renderers/Vulkan/VKLoader.h          |  19 +-
 .../Vulkan/VKLoaderPlatformDefines.h          |  23 +
 .../Renderers/parallel-gs/GSRendererPGS.cpp   | 818 ++++++++++++++++++
 .../GS/Renderers/parallel-gs/GSRendererPGS.h  |  86 ++
 pcsx2/ImGui/ImGuiFullscreen.cpp               |   2 +
 pcsx2/Pcsx2Config.cpp                         |   9 +-
 pcsx2/pcsx2.vcxproj                           |  52 +-
 24 files changed, 1639 insertions(+), 164 deletions(-)
 create mode 100644 pcsx2/GS/Renderers/Vulkan/VKLoaderPlatformDefines.h
 create mode 100644 pcsx2/GS/Renderers/parallel-gs/GSRendererPGS.cpp
 create mode 100644 pcsx2/GS/Renderers/parallel-gs/GSRendererPGS.h

diff --git a/.gitignore b/.gitignore
index b59e873da..aac77d348 100644
--- a/.gitignore
+++ b/.gitignore
@@ -120,3 +120,5 @@ CMakeSettings.json
 /ci-artifacts/
 /out/
 /.cache/
+
+/pcsx2/GS/parallel-gs
diff --git a/3rdparty/vulkan/include/vulkan/vulkan_core.h b/3rdparty/vulkan/include/vulkan/vulkan_core.h
index e6c16498a..b2973ffc8 100644
--- a/3rdparty/vulkan/include/vulkan/vulkan_core.h
+++ b/3rdparty/vulkan/include/vulkan/vulkan_core.h
@@ -69,7 +69,7 @@ extern "C" {
 #define VK_API_VERSION_1_0 VK_MAKE_API_VERSION(0, 1, 0, 0)// Patch version should always be set to 0
 
 // Version of this file
-#define VK_HEADER_VERSION 296
+#define VK_HEADER_VERSION 300
 
 // Complete version of this file
 #define VK_HEADER_VERSION_COMPLETE VK_MAKE_API_VERSION(0, 1, 3, VK_HEADER_VERSION)
@@ -508,10 +508,6 @@ typedef enum VkStructureType {
     VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR = 1000040005,
     VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR = 1000040006,
     VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD = 1000041000,
-    VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 1000044006,
-    VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT = 1000044007,
-    VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD = 1000044008,
-    VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX = 1000044009,
     VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP = 1000049000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV = 1000050000,
     VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = 1000056000,
@@ -553,6 +549,7 @@ typedef enum VkStructureType {
     VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT = 1000091003,
     VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE = 1000092000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX = 1000097000,
+    VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX = 1000044009,
     VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV = 1000098000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT = 1000099000,
     VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT = 1000099001,
@@ -612,6 +609,7 @@ typedef enum VkStructureType {
 #ifdef VK_ENABLE_BETA_EXTENSIONS
     VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX = 1000134004,
 #endif
+    VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD = 1000044008,
     VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT = 1000143000,
     VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT = 1000143001,
     VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT = 1000143002,
@@ -703,6 +701,8 @@ typedef enum VkStructureType {
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV = 1000205002,
     VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV = 1000206000,
     VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV = 1000206001,
+    VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV = 1000314008,
+    VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV = 1000314009,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL = 1000209000,
     VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL = 1000210000,
     VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL = 1000210001,
@@ -718,11 +718,13 @@ typedef enum VkStructureType {
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT = 1000218000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT = 1000218001,
     VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT = 1000218002,
+    VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT = 1000044007,
     VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 1000226000,
     VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR = 1000226001,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR = 1000226002,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR = 1000226003,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR = 1000226004,
+    VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 1000044006,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD = 1000227000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD = 1000229000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES_KHR = 1000232000,
@@ -848,8 +850,6 @@ typedef enum VkStructureType {
     VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT = 1000311009,
     VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT = 1000311010,
     VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT = 1000311011,
-    VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV = 1000314008,
-    VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV = 1000314009,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT = 1000316000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT = 1000316001,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT = 1000316002,
@@ -902,6 +902,7 @@ typedef enum VkStructureType {
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT = 1000355000,
     VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT = 1000355001,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT = 1000356000,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_EXT = 1000361000,
     VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA = 1000364000,
     VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA = 1000364001,
     VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA = 1000364002,
@@ -1162,6 +1163,9 @@ typedef enum VkStructureType {
     VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA = 1000575002,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT = 1000582000,
     VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT = 1000582001,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV = 1000593000,
+    VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV = 1000593001,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV = 1000593002,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES,
   // VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT is a deprecated alias
@@ -1171,7 +1175,6 @@ typedef enum VkStructureType {
     VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES,
     VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO,
-    VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_NV = VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD,
     VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES,
@@ -1245,6 +1248,7 @@ typedef enum VkStructureType {
     VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
     VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR = VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2,
     VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
+    VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_NV = VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD,
     VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO,
     VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO,
     VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO,
@@ -2646,8 +2650,6 @@ typedef enum VkPipelineCreateFlagBits {
     VK_PIPELINE_CREATE_DISPATCH_BASE_BIT = 0x00000010,
     VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT = 0x00000100,
     VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT = 0x00000200,
-    VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00200000,
-    VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = 0x00400000,
     VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR = 0x00004000,
     VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR = 0x00008000,
     VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR = 0x00010000,
@@ -2656,6 +2658,8 @@ typedef enum VkPipelineCreateFlagBits {
     VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR = 0x00002000,
     VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR = 0x00080000,
     VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV = 0x00000020,
+    VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = 0x00400000,
+    VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00200000,
     VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR = 0x00000040,
     VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR = 0x00000080,
     VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV = 0x00040000,
@@ -2673,12 +2677,12 @@ typedef enum VkPipelineCreateFlagBits {
     VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT = 0x08000000,
     VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT = 0x40000000,
     VK_PIPELINE_CREATE_DISPATCH_BASE = VK_PIPELINE_CREATE_DISPATCH_BASE_BIT,
-  // VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR is a deprecated alias
-    VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
-  // VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT is a deprecated alias
-    VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT,
     VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR = VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT,
     VK_PIPELINE_CREATE_DISPATCH_BASE_KHR = VK_PIPELINE_CREATE_DISPATCH_BASE,
+  // VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT is a deprecated alias
+    VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT,
+  // VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR is a deprecated alias
+    VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
     VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT = VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT,
     VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT = VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT,
     VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
@@ -7633,6 +7637,7 @@ typedef enum VkPresentModeKHR {
     VK_PRESENT_MODE_FIFO_RELAXED_KHR = 3,
     VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR = 1000111000,
     VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR = 1000111001,
+    VK_PRESENT_MODE_FIFO_LATEST_READY_EXT = 1000361000,
     VK_PRESENT_MODE_MAX_ENUM_KHR = 0x7FFFFFFF
 } VkPresentModeKHR;
 
@@ -8901,38 +8906,6 @@ typedef VkPhysicalDeviceDynamicRenderingFeatures VkPhysicalDeviceDynamicRenderin
 
 typedef VkCommandBufferInheritanceRenderingInfo VkCommandBufferInheritanceRenderingInfoKHR;
 
-typedef struct VkRenderingFragmentShadingRateAttachmentInfoKHR {
-    VkStructureType    sType;
-    const void*        pNext;
-    VkImageView        imageView;
-    VkImageLayout      imageLayout;
-    VkExtent2D         shadingRateAttachmentTexelSize;
-} VkRenderingFragmentShadingRateAttachmentInfoKHR;
-
-typedef struct VkRenderingFragmentDensityMapAttachmentInfoEXT {
-    VkStructureType    sType;
-    const void*        pNext;
-    VkImageView        imageView;
-    VkImageLayout      imageLayout;
-} VkRenderingFragmentDensityMapAttachmentInfoEXT;
-
-typedef struct VkAttachmentSampleCountInfoAMD {
-    VkStructureType                 sType;
-    const void*                     pNext;
-    uint32_t                        colorAttachmentCount;
-    const VkSampleCountFlagBits*    pColorAttachmentSamples;
-    VkSampleCountFlagBits           depthStencilAttachmentSamples;
-} VkAttachmentSampleCountInfoAMD;
-
-typedef VkAttachmentSampleCountInfoAMD VkAttachmentSampleCountInfoNV;
-
-typedef struct VkMultiviewPerViewAttributesInfoNVX {
-    VkStructureType    sType;
-    const void*        pNext;
-    VkBool32           perViewAttributes;
-    VkBool32           perViewAttributesPositionXOnly;
-} VkMultiviewPerViewAttributesInfoNVX;
-
 typedef void (VKAPI_PTR *PFN_vkCmdBeginRenderingKHR)(VkCommandBuffer                   commandBuffer, const VkRenderingInfo*                              pRenderingInfo);
 typedef void (VKAPI_PTR *PFN_vkCmdEndRenderingKHR)(VkCommandBuffer                   commandBuffer);
 
@@ -10307,6 +10280,14 @@ typedef struct VkPhysicalDeviceFragmentShadingRateKHR {
     VkExtent2D            fragmentSize;
 } VkPhysicalDeviceFragmentShadingRateKHR;
 
+typedef struct VkRenderingFragmentShadingRateAttachmentInfoKHR {
+    VkStructureType    sType;
+    const void*        pNext;
+    VkImageView        imageView;
+    VkImageLayout      imageLayout;
+    VkExtent2D         shadingRateAttachmentTexelSize;
+} VkRenderingFragmentShadingRateAttachmentInfoKHR;
+
 typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR)(VkPhysicalDevice physicalDevice, uint32_t* pFragmentShadingRateCount, VkPhysicalDeviceFragmentShadingRateKHR* pFragmentShadingRates);
 typedef void (VKAPI_PTR *PFN_vkCmdSetFragmentShadingRateKHR)(VkCommandBuffer           commandBuffer, const VkExtent2D*                           pFragmentSize, const VkFragmentShadingRateCombinerOpKHR    combinerOps[2]);
 
@@ -10888,27 +10869,12 @@ typedef VkCommandBufferSubmitInfo VkCommandBufferSubmitInfoKHR;
 
 typedef VkPhysicalDeviceSynchronization2Features VkPhysicalDeviceSynchronization2FeaturesKHR;
 
-typedef struct VkQueueFamilyCheckpointProperties2NV {
-    VkStructureType          sType;
-    void*                    pNext;
-    VkPipelineStageFlags2    checkpointExecutionStageMask;
-} VkQueueFamilyCheckpointProperties2NV;
-
-typedef struct VkCheckpointData2NV {
-    VkStructureType          sType;
-    void*                    pNext;
-    VkPipelineStageFlags2    stage;
-    void*                    pCheckpointMarker;
-} VkCheckpointData2NV;
-
 typedef void (VKAPI_PTR *PFN_vkCmdSetEvent2KHR)(VkCommandBuffer                   commandBuffer, VkEvent                                             event, const VkDependencyInfo*                             pDependencyInfo);
 typedef void (VKAPI_PTR *PFN_vkCmdResetEvent2KHR)(VkCommandBuffer                   commandBuffer, VkEvent                                             event, VkPipelineStageFlags2               stageMask);
 typedef void (VKAPI_PTR *PFN_vkCmdWaitEvents2KHR)(VkCommandBuffer                   commandBuffer, uint32_t                                            eventCount, const VkEvent*                     pEvents, const VkDependencyInfo*            pDependencyInfos);
 typedef void (VKAPI_PTR *PFN_vkCmdPipelineBarrier2KHR)(VkCommandBuffer                   commandBuffer, const VkDependencyInfo*                             pDependencyInfo);
 typedef void (VKAPI_PTR *PFN_vkCmdWriteTimestamp2KHR)(VkCommandBuffer                   commandBuffer, VkPipelineStageFlags2               stage, VkQueryPool                                         queryPool, uint32_t                                            query);
 typedef VkResult (VKAPI_PTR *PFN_vkQueueSubmit2KHR)(VkQueue                           queue, uint32_t                            submitCount, const VkSubmitInfo2*              pSubmits, VkFence           fence);
-typedef void (VKAPI_PTR *PFN_vkCmdWriteBufferMarker2AMD)(VkCommandBuffer                   commandBuffer, VkPipelineStageFlags2               stage, VkBuffer                                            dstBuffer, VkDeviceSize                                        dstOffset, uint32_t                                            marker);
-typedef void (VKAPI_PTR *PFN_vkGetQueueCheckpointData2NV)(VkQueue queue, uint32_t* pCheckpointDataCount, VkCheckpointData2NV* pCheckpointData);
 
 #ifndef VK_NO_PROTOTYPES
 VKAPI_ATTR void VKAPI_CALL vkCmdSetEvent2KHR(
@@ -10942,18 +10908,6 @@ VKAPI_ATTR VkResult VKAPI_CALL vkQueueSubmit2KHR(
     uint32_t                                    submitCount,
     const VkSubmitInfo2*                        pSubmits,
     VkFence                                     fence);
-
-VKAPI_ATTR void VKAPI_CALL vkCmdWriteBufferMarker2AMD(
-    VkCommandBuffer                             commandBuffer,
-    VkPipelineStageFlags2                       stage,
-    VkBuffer                                    dstBuffer,
-    VkDeviceSize                                dstOffset,
-    uint32_t                                    marker);
-
-VKAPI_ATTR void VKAPI_CALL vkGetQueueCheckpointData2NV(
-    VkQueue                                     queue,
-    uint32_t*                                   pCheckpointDataCount,
-    VkCheckpointData2NV*                        pCheckpointData);
 #endif
 
 
@@ -11196,6 +11150,9 @@ typedef VkFlags64 VkPipelineCreateFlagBits2KHR;
 static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT_KHR = 0x00000001ULL;
 static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT_KHR = 0x00000002ULL;
 static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_DERIVATIVE_BIT_KHR = 0x00000004ULL;
+#ifdef VK_ENABLE_BETA_EXTENSIONS
+static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_EXECUTION_GRAPH_BIT_AMDX = 0x100000000ULL;
+#endif
 static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT = 0x400000000ULL;
 static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR = 0x00000008ULL;
 static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT_KHR = 0x00000010ULL;
@@ -11241,7 +11198,9 @@ static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_STORAGE_BUFFER_BIT_KHR
 static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT_KHR = 0x00000040ULL;
 static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT_KHR = 0x00000080ULL;
 static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT_KHR = 0x00000100ULL;
+#ifdef VK_ENABLE_BETA_EXTENSIONS
 static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_EXECUTION_GRAPH_SCRATCH_BIT_AMDX = 0x02000000ULL;
+#endif
 static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_CONDITIONAL_RENDERING_BIT_EXT = 0x00000200ULL;
 static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_SHADER_BINDING_TABLE_BIT_KHR = 0x00000400ULL;
 static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_RAY_TRACING_BIT_NV = 0x00000400ULL;
@@ -13006,6 +12965,13 @@ typedef struct VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
     VkBool32           perViewPositionAllComponents;
 } VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX;
 
+typedef struct VkMultiviewPerViewAttributesInfoNVX {
+    VkStructureType    sType;
+    const void*        pNext;
+    VkBool32           perViewAttributes;
+    VkBool32           perViewAttributesPositionXOnly;
+} VkMultiviewPerViewAttributesInfoNVX;
+
 
 
 // VK_NV_viewport_swizzle is a preprocessor guard. Do not pass it to API calls.
@@ -13374,6 +13340,14 @@ typedef VkPhysicalDeviceSamplerFilterMinmaxProperties VkPhysicalDeviceSamplerFil
 #define VK_AMD_mixed_attachment_samples 1
 #define VK_AMD_MIXED_ATTACHMENT_SAMPLES_SPEC_VERSION 1
 #define VK_AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME "VK_AMD_mixed_attachment_samples"
+typedef struct VkAttachmentSampleCountInfoAMD {
+    VkStructureType                 sType;
+    const void*                     pNext;
+    uint32_t                        colorAttachmentCount;
+    const VkSampleCountFlagBits*    pColorAttachmentSamples;
+    VkSampleCountFlagBits           depthStencilAttachmentSamples;
+} VkAttachmentSampleCountInfoAMD;
+
 
 
 // VK_AMD_shader_fragment_mask is a preprocessor guard. Do not pass it to API calls.
@@ -13553,6 +13527,8 @@ typedef struct VkPipelineCoverageModulationStateCreateInfoNV {
     const float*                                      pCoverageModulationTable;
 } VkPipelineCoverageModulationStateCreateInfoNV;
 
+typedef VkAttachmentSampleCountInfoAMD VkAttachmentSampleCountInfoNV;
+
 
 
 // VK_NV_fill_rectangle is a preprocessor guard. Do not pass it to API calls.
@@ -14310,6 +14286,7 @@ VKAPI_ATTR VkResult VKAPI_CALL vkGetMemoryHostPointerPropertiesEXT(
 #define VK_AMD_BUFFER_MARKER_SPEC_VERSION 1
 #define VK_AMD_BUFFER_MARKER_EXTENSION_NAME "VK_AMD_buffer_marker"
 typedef void (VKAPI_PTR *PFN_vkCmdWriteBufferMarkerAMD)(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker);
+typedef void (VKAPI_PTR *PFN_vkCmdWriteBufferMarker2AMD)(VkCommandBuffer                   commandBuffer, VkPipelineStageFlags2               stage, VkBuffer                                            dstBuffer, VkDeviceSize                                        dstOffset, uint32_t                                            marker);
 
 #ifndef VK_NO_PROTOTYPES
 VKAPI_ATTR void VKAPI_CALL vkCmdWriteBufferMarkerAMD(
@@ -14318,6 +14295,13 @@ VKAPI_ATTR void VKAPI_CALL vkCmdWriteBufferMarkerAMD(
     VkBuffer                                    dstBuffer,
     VkDeviceSize                                dstOffset,
     uint32_t                                    marker);
+
+VKAPI_ATTR void VKAPI_CALL vkCmdWriteBufferMarker2AMD(
+    VkCommandBuffer                             commandBuffer,
+    VkPipelineStageFlags2                       stage,
+    VkBuffer                                    dstBuffer,
+    VkDeviceSize                                dstOffset,
+    uint32_t                                    marker);
 #endif
 
 
@@ -14588,8 +14572,22 @@ typedef struct VkCheckpointDataNV {
     void*                      pCheckpointMarker;
 } VkCheckpointDataNV;
 
+typedef struct VkQueueFamilyCheckpointProperties2NV {
+    VkStructureType          sType;
+    void*                    pNext;
+    VkPipelineStageFlags2    checkpointExecutionStageMask;
+} VkQueueFamilyCheckpointProperties2NV;
+
+typedef struct VkCheckpointData2NV {
+    VkStructureType          sType;
+    void*                    pNext;
+    VkPipelineStageFlags2    stage;
+    void*                    pCheckpointMarker;
+} VkCheckpointData2NV;
+
 typedef void (VKAPI_PTR *PFN_vkCmdSetCheckpointNV)(VkCommandBuffer commandBuffer, const void* pCheckpointMarker);
 typedef void (VKAPI_PTR *PFN_vkGetQueueCheckpointDataNV)(VkQueue queue, uint32_t* pCheckpointDataCount, VkCheckpointDataNV* pCheckpointData);
+typedef void (VKAPI_PTR *PFN_vkGetQueueCheckpointData2NV)(VkQueue queue, uint32_t* pCheckpointDataCount, VkCheckpointData2NV* pCheckpointData);
 
 #ifndef VK_NO_PROTOTYPES
 VKAPI_ATTR void VKAPI_CALL vkCmdSetCheckpointNV(
@@ -14600,6 +14598,11 @@ VKAPI_ATTR void VKAPI_CALL vkGetQueueCheckpointDataNV(
     VkQueue                                     queue,
     uint32_t*                                   pCheckpointDataCount,
     VkCheckpointDataNV*                         pCheckpointData);
+
+VKAPI_ATTR void VKAPI_CALL vkGetQueueCheckpointData2NV(
+    VkQueue                                     queue,
+    uint32_t*                                   pCheckpointDataCount,
+    VkCheckpointData2NV*                        pCheckpointData);
 #endif
 
 
@@ -14821,6 +14824,13 @@ typedef struct VkRenderPassFragmentDensityMapCreateInfoEXT {
     VkAttachmentReference    fragmentDensityMapAttachment;
 } VkRenderPassFragmentDensityMapCreateInfoEXT;
 
+typedef struct VkRenderingFragmentDensityMapAttachmentInfoEXT {
+    VkStructureType    sType;
+    const void*        pNext;
+    VkImageView        imageView;
+    VkImageLayout      imageLayout;
+} VkRenderingFragmentDensityMapAttachmentInfoEXT;
+
 
 
 // VK_EXT_scalar_block_layout is a preprocessor guard. Do not pass it to API calls.
@@ -17097,6 +17107,18 @@ typedef struct VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT {
 
 
 
+// VK_EXT_present_mode_fifo_latest_ready is a preprocessor guard. Do not pass it to API calls.
+#define VK_EXT_present_mode_fifo_latest_ready 1
+#define VK_EXT_PRESENT_MODE_FIFO_LATEST_READY_SPEC_VERSION 1
+#define VK_EXT_PRESENT_MODE_FIFO_LATEST_READY_EXTENSION_NAME "VK_EXT_present_mode_fifo_latest_ready"
+typedef struct VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT {
+    VkStructureType    sType;
+    void*              pNext;
+    VkBool32           presentModeFifoLatestReady;
+} VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT;
+
+
+
 // VK_HUAWEI_subpass_shading is a preprocessor guard. Do not pass it to API calls.
 #define VK_HUAWEI_subpass_shading 1
 #define VK_HUAWEI_SUBPASS_SHADING_SPEC_VERSION 3
@@ -19627,7 +19649,7 @@ typedef struct VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT {
 
 typedef struct VkGeneratedCommandsMemoryRequirementsInfoEXT {
     VkStructureType                sType;
-    void*                          pNext;
+    const void*                    pNext;
     VkIndirectExecutionSetEXT      indirectExecutionSet;
     VkIndirectCommandsLayoutEXT    indirectCommandsLayout;
     uint32_t                       maxSequenceCount;
@@ -19879,6 +19901,55 @@ typedef struct VkPipelineViewportDepthClampControlCreateInfoEXT {
 
 
 
+// VK_NV_cooperative_matrix2 is a preprocessor guard. Do not pass it to API calls.
+#define VK_NV_cooperative_matrix2 1
+#define VK_NV_COOPERATIVE_MATRIX_2_SPEC_VERSION 1
+#define VK_NV_COOPERATIVE_MATRIX_2_EXTENSION_NAME "VK_NV_cooperative_matrix2"
+typedef struct VkCooperativeMatrixFlexibleDimensionsPropertiesNV {
+    VkStructureType       sType;
+    void*                 pNext;
+    uint32_t              MGranularity;
+    uint32_t              NGranularity;
+    uint32_t              KGranularity;
+    VkComponentTypeKHR    AType;
+    VkComponentTypeKHR    BType;
+    VkComponentTypeKHR    CType;
+    VkComponentTypeKHR    ResultType;
+    VkBool32              saturatingAccumulation;
+    VkScopeKHR            scope;
+    uint32_t              workgroupInvocations;
+} VkCooperativeMatrixFlexibleDimensionsPropertiesNV;
+
+typedef struct VkPhysicalDeviceCooperativeMatrix2FeaturesNV {
+    VkStructureType    sType;
+    void*              pNext;
+    VkBool32           cooperativeMatrixWorkgroupScope;
+    VkBool32           cooperativeMatrixFlexibleDimensions;
+    VkBool32           cooperativeMatrixReductions;
+    VkBool32           cooperativeMatrixConversions;
+    VkBool32           cooperativeMatrixPerElementOperations;
+    VkBool32           cooperativeMatrixTensorAddressing;
+    VkBool32           cooperativeMatrixBlockLoads;
+} VkPhysicalDeviceCooperativeMatrix2FeaturesNV;
+
+typedef struct VkPhysicalDeviceCooperativeMatrix2PropertiesNV {
+    VkStructureType    sType;
+    void*              pNext;
+    uint32_t           cooperativeMatrixWorkgroupScopeMaxWorkgroupSize;
+    uint32_t           cooperativeMatrixFlexibleDimensionsMaxDimension;
+    uint32_t           cooperativeMatrixWorkgroupScopeReservedSharedMemory;
+} VkPhysicalDeviceCooperativeMatrix2PropertiesNV;
+
+typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV)(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkCooperativeMatrixFlexibleDimensionsPropertiesNV* pProperties);
+
+#ifndef VK_NO_PROTOTYPES
+VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(
+    VkPhysicalDevice                            physicalDevice,
+    uint32_t*                                   pPropertyCount,
+    VkCooperativeMatrixFlexibleDimensionsPropertiesNV* pProperties);
+#endif
+
+
 // VK_KHR_acceleration_structure is a preprocessor guard. Do not pass it to API calls.
 #define VK_KHR_acceleration_structure 1
 #define VK_KHR_ACCELERATION_STRUCTURE_SPEC_VERSION 13
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 4036241b4..2f369adb3 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -33,6 +33,14 @@ check_no_parenthesis_in_path()
 detect_operating_system()
 detect_compiler()
 
+# Need to make sure this is included early, so we can make sure we use our own Vulkan headers,
+# which are more recent than system headers.
+# Otherwise, Qt6 includes system Vulkan headers in SearchForStuff.
+if (IS_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/pcsx2/GS/parallel-gs)
+	set(PARALLEL_GS_STANDALONE ON CACHE BOOL "" FORCE)
+	add_subdirectory(pcsx2/GS/parallel-gs EXCLUDE_FROM_ALL)
+endif()
+
 #-------------------------------------------------------------------------------
 # Include specific module
 include(BuildParameters)
diff --git a/pcsx2-gsrunner/Main.cpp b/pcsx2-gsrunner/Main.cpp
index d3ad1e818..0f4120573 100644
--- a/pcsx2-gsrunner/Main.cpp
+++ b/pcsx2-gsrunner/Main.cpp
@@ -519,6 +519,10 @@ bool GSRunner::ParseCommandLineArgs(int argc, char* argv[], VMBootParameters& pa
 				else if (StringUtil::Strcasecmp(rname, "dx12") == 0)
 					type = GSRendererType::DX12;
 #endif
+#ifdef HAVE_PARALLEL_GS
+				else if (StringUtil::Strcasecmp(rname, "parallel-gs") == 0)
+					type = GSRendererType::ParallelGS;
+#endif
 #ifdef ENABLE_OPENGL
 				else if (StringUtil::Strcasecmp(rname, "gl") == 0)
 					type = GSRendererType::OGL;
diff --git a/pcsx2-qt/MainWindow.cpp b/pcsx2-qt/MainWindow.cpp
index 616e9efa9..4fe7cfc8f 100644
--- a/pcsx2-qt/MainWindow.cpp
+++ b/pcsx2-qt/MainWindow.cpp
@@ -462,6 +462,9 @@ void MainWindow::createRendererSwitchMenu()
 {
 	static constexpr const GSRendererType renderers[] = {
 		GSRendererType::Auto,
+#if defined(HAVE_PARALLEL_GS)
+		GSRendererType::ParallelGS,
+#endif
 #if defined(_WIN32)
 		GSRendererType::DX11,
 		GSRendererType::DX12,
diff --git a/pcsx2-qt/Settings/GraphicsSettingsWidget.cpp b/pcsx2-qt/Settings/GraphicsSettingsWidget.cpp
index 311143fd4..d5e6460cd 100644
--- a/pcsx2-qt/Settings/GraphicsSettingsWidget.cpp
+++ b/pcsx2-qt/Settings/GraphicsSettingsWidget.cpp
@@ -20,6 +20,9 @@ struct RendererInfo
 
 static constexpr RendererInfo s_renderer_info[] = {
 	{QT_TRANSLATE_NOOP("GraphicsSettingsWidget", "Automatic (Default)"), GSRendererType::Auto},
+#ifdef HAVE_PARALLEL_GS
+	{QT_TRANSLATE_NOOP("GraphicsSettingsWidget", "paraLLEl-GS"), GSRendererType::ParallelGS},
+#endif
 #ifdef _WIN32
 	//: Graphics backend/engine type. Leave as-is.
 	{QT_TRANSLATE_NOOP("GraphicsSettingsWidget", "Direct3D 11"), GSRendererType::DX11},
@@ -264,6 +267,13 @@ GraphicsSettingsWidget::GraphicsSettingsWidget(SettingsWindow* dialog, QWidget*
 	SettingWidgetBinder::BindWidgetToBoolSetting(sif, m_ui.swAutoFlush, "EmuCore/GS", "autoflush_sw", true);
 	SettingWidgetBinder::BindWidgetToBoolSetting(sif, m_ui.swMipmap, "EmuCore/GS", "mipmap", true);
 
+	//////////////////////////////////////////////////////////////////////////
+	// PGS Settings
+	//////////////////////////////////////////////////////////////////////////
+	SettingWidgetBinder::BindWidgetToIntSetting(sif, m_ui.pgsSuperSampling, "EmuCore/GS", "pgsSuperSampling", 0);
+	SettingWidgetBinder::BindWidgetToIntSetting(sif, m_ui.pgsHighResScanout, "EmuCore/GS", "pgsHighResScanout", 0);
+	SettingWidgetBinder::BindWidgetToIntSetting(sif, m_ui.pgsDisableMipmaps, "EmuCore/GS", "pgsDisableMipmaps", 0);
+
 	//////////////////////////////////////////////////////////////////////////
 	// Non-trivial settings
 	//////////////////////////////////////////////////////////////////////////
@@ -298,6 +308,7 @@ GraphicsSettingsWidget::GraphicsSettingsWidget(SettingsWindow* dialog, QWidget*
 	connect(m_ui.extendedUpscales, &QCheckBox::checkStateChanged, this, &GraphicsSettingsWidget::updateRendererDependentOptions);
 	connect(m_ui.textureFiltering, &QComboBox::currentIndexChanged, this, &GraphicsSettingsWidget::onTextureFilteringChange);
 	connect(m_ui.swTextureFiltering, &QComboBox::currentIndexChanged, this, &GraphicsSettingsWidget::onSWTextureFilteringChange);
+
 	updateRendererDependentOptions();
 
 #ifndef _WIN32
@@ -571,6 +582,20 @@ GraphicsSettingsWidget::GraphicsSettingsWidget(SettingsWindow* dialog, QWidget*
 
 		dialog->registerWidgetHelp(
 			m_ui.swMipmap, tr("Mipmapping"), tr("Checked"), tr("Enables mipmapping, which some games require to render correctly."));
+
+		dialog->registerWidgetHelp(m_ui.pgsSuperSampling, tr("paraLLEl-GS Super Sampling"), tr("1x (native)"),
+		                           tr("Number of super samples used by paraLLEl-GS before down-sampling to native resolution. "
+		                              "More than 4x SSAA is not recommended as there is diminishing returns in output quality. "
+		                              "16x SSAA yields a very nice result, but requires reasonably powerful hardware in some games."));
+
+		dialog->registerWidgetHelp(m_ui.pgsHighResScanout, tr("paraLLEl-GS High-res Scanout (experimental)"), tr("Unchecked"),
+		                           tr("When using SSAA, attempts to scan-out a higher resolution result based on stored super-samples. "
+		                              "Requires at least 4x SSAA (ordered) to work. Can benefit from 16x SSAA, at a steep GPU processing cost. "
+									  "Highly game dependent if it works well. Common issues include pixellated output, or lack of sharpness."));
+
+		dialog->registerWidgetHelp(m_ui.pgsDisableMipmaps, tr("Disable mip-mapping"), tr("Unchecked"),
+		                           tr("Disables mip-mapping. May give a sharper image in games using mip-mapping intended for native resolution. "
+		                              "May also break games which rely on mipmaps being used in esoteric ways."));
 	}
 
 	// Hardware Fixes tab
@@ -1084,6 +1109,7 @@ void GraphicsSettingsWidget::updateRendererDependentOptions()
 	const bool is_hardware = (type == GSRendererType::DX11 || type == GSRendererType::DX12 || type == GSRendererType::OGL ||
 							  type == GSRendererType::VK || type == GSRendererType::Metal);
 	const bool is_software = (type == GSRendererType::SW);
+	const bool is_pgs = (type == GSRendererType::ParallelGS);
 	const bool is_auto = (type == GSRendererType::Auto);
 	const bool is_vk = (type == GSRendererType::VK);
 	const bool is_disable_barriers = (type == GSRendererType::DX11 || type == GSRendererType::DX12 || type == GSRendererType::Metal || type == GSRendererType::SW);
@@ -1098,22 +1124,32 @@ void GraphicsSettingsWidget::updateRendererDependentOptions()
 	m_ui.tabs->setTabEnabled(2, is_software);
 	m_ui.tabs->setTabVisible(2, is_software);
 
-	// hardware fixes
-	m_ui.tabs->setTabEnabled(3, hw_fixes);
-	m_ui.tabs->setTabVisible(3, hw_fixes);
+	// pgs rendering
+	m_ui.tabs->setTabEnabled(3, is_pgs);
+	m_ui.tabs->setTabVisible(3, is_pgs);
 
-	// upscaling fixes
+	// hardware fixes
 	m_ui.tabs->setTabEnabled(4, hw_fixes);
 	m_ui.tabs->setTabVisible(4, hw_fixes);
 
+	// upscaling fixes
+	m_ui.tabs->setTabEnabled(5, hw_fixes);
+	m_ui.tabs->setTabVisible(5, hw_fixes);
+
 	// texture replacement
-	m_ui.tabs->setTabEnabled(5, is_hardware);
-	m_ui.tabs->setTabVisible(5, is_hardware);
+	m_ui.tabs->setTabEnabled(6, is_hardware);
+	m_ui.tabs->setTabVisible(6, is_hardware);
+
+	// Post-processing
+	m_ui.tabs->setTabEnabled(7, !is_pgs);
+	m_ui.tabs->setTabVisible(7, !is_pgs);
 
 	// move back to the renderer if we're on one of the now-hidden tabs
-	if (is_software && (prev_tab == 1 || (prev_tab >= 2 && prev_tab <= 5)))
+	if (is_software && (prev_tab == 1 || (prev_tab >= 2 && prev_tab <= 6)))
 		m_ui.tabs->setCurrentIndex(2);
-	else if (is_hardware && prev_tab == 2)
+	else if (is_pgs)
+		m_ui.tabs->setCurrentIndex(3);
+	else if (is_hardware && (prev_tab == 2 || prev_tab == 3))
 		m_ui.tabs->setCurrentIndex(1);
 
 	if (m_ui.useBlitSwapChain)
diff --git a/pcsx2-qt/Settings/GraphicsSettingsWidget.ui b/pcsx2-qt/Settings/GraphicsSettingsWidget.ui
index d1b6a9031..f261ac0d6 100644
--- a/pcsx2-qt/Settings/GraphicsSettingsWidget.ui
+++ b/pcsx2-qt/Settings/GraphicsSettingsWidget.ui
@@ -721,6 +721,78 @@
        </item>
       </layout>
      </widget>
+     <widget class="QWidget" name="pgsRenderingTab">
+      <attribute name="title"><string>Rendering</string></attribute>
+      <layout class="QFormLayout" name="formLayout_11">
+       <item row="0" column="0">
+        <widget class="QLabel" name="pgsSuperSamplingLabel">
+         <property name="text">
+          <string>Super Sampling:</string>
+         </property>
+        </widget>
+       </item>
+       <item row="0" column="1">
+        <widget class="QComboBox" name="pgsSuperSampling">
+         <property name="enabled">
+          <bool>true</bool>
+         </property>
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+         <property name="layoutDirection">
+          <enum>Qt::LayoutDirection::LeftToRight</enum>
+         </property>
+         <item>
+          <property name="text">
+           <string>1x (native)</string>
+          </property>
+         </item>
+         <item>
+          <property name="text">
+           <string>2x SSAA (checkerboard)</string>
+          </property>
+         </item>
+         <item>
+          <property name="text">
+           <string>4x SSAA (sparse grid)</string>
+          </property>
+         </item>
+         <item>
+          <property name="text">
+           <string>4x SSAA (ordered grid, high-res output capable)</string>
+          </property>
+         </item>
+         <item>
+          <property name="text">
+           <string>8x SSAA (checkerboard, high-res output capable)</string>
+          </property>
+         </item>
+         <item>
+          <property name="text">
+           <string>16x SSAA (sparse grid, high-res output capable)</string>
+          </property>
+         </item>
+        </widget>
+       </item>
+       <item row="1" column="0">
+          <widget class="QCheckBox" name="pgsHighResScanout">
+           <property name="text">
+            <string>High-resolution scanout</string>
+           </property>
+          </widget>
+       </item>
+       <item row="1" column="1">
+          <widget class="QCheckBox" name="pgsDisableMipmaps">
+           <property name="text">
+            <string>Disable mip-mapping</string>
+           </property>
+          </widget>
+       </item>
+      </layout>
+     </widget>
      <widget class="QGroupBox" name="hardwareFixesTab">
       <attribute name="title">
        <string>Hardware Fixes</string>
diff --git a/pcsx2-qt/pcsx2-qt.vcxproj b/pcsx2-qt/pcsx2-qt.vcxproj
index f77da9595..5c3536ce9 100644
--- a/pcsx2-qt/pcsx2-qt.vcxproj
+++ b/pcsx2-qt/pcsx2-qt.vcxproj
@@ -54,7 +54,7 @@
       <ForcedIncludeFiles>PrecompiledHeader.h;%(ForcedIncludeFiles)</ForcedIncludeFiles>
       <PreprocessorDefinitions Condition="'$(Platform)'!='ARM64'">ENABLE_RAINTEGRATION;ENABLE_OPENGL;ENABLE_VULKAN;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <PreprocessorDefinitions>LZMA_API_STATIC;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <PreprocessorDefinitions>QT_NO_EXCEPTIONS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <PreprocessorDefinitions>HAVE_PARALLEL_GS;QT_NO_EXCEPTIONS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <!-- Current Qt debug builds assert on RTTI. Remove this once we next build Qt. -->
       <RuntimeTypeInfo Condition="$(Configuration.Contains(Debug))">true</RuntimeTypeInfo>
     </ClCompile>
diff --git a/pcsx2/CMakeLists.txt b/pcsx2/CMakeLists.txt
index 804ab2e40..9bb3b0af3 100644
--- a/pcsx2/CMakeLists.txt
+++ b/pcsx2/CMakeLists.txt
@@ -638,6 +638,7 @@ if(USE_VULKAN)
 		GS/Renderers/Vulkan/VKEntryPoints.h
 		GS/Renderers/Vulkan/VKEntryPoints.inl
 		GS/Renderers/Vulkan/VKLoader.h
+		GS/Renderers/Vulkan/VKLoaderPlatformDefines.h
 		GS/Renderers/Vulkan/VKShaderCache.h
 		GS/Renderers/Vulkan/VKStreamBuffer.h
 		GS/Renderers/Vulkan/VKSwapChain.h
@@ -646,6 +647,23 @@ if(USE_VULKAN)
 	target_include_directories(PCSX2_FLAGS INTERFACE ${SHADERC_INCLUDE_DIR})
 endif()
 
+if (TARGET parallel-gs)
+	message("Adding support for paraLLEl-GS")
+	target_link_libraries(PCSX2_FLAGS INTERFACE parallel-gs)
+	target_compile_definitions(PCSX2_FLAGS INTERFACE HAVE_PARALLEL_GS)
+	list(APPEND pcsx2GSSources GS/Renderers/parallel-gs/GSRendererPGS.cpp)
+	list(APPEND pcsx2GSHeaders GS/Renderers/parallel-gs/GSRendererPGS.h)
+	if (X11_API)
+		target_compile_definitions(granite-volk PUBLIC VK_USE_PLATFORM_XLIB_KHR)
+	endif()
+	if (WAYLAND_API)
+		target_compile_definitions(granite-volk PUBLIC VK_USE_PLATFORM_WAYLAND_KHR)
+	endif()
+	if (WIN32)
+		target_compile_definitions(granite-volk PUBLIC VK_USE_PLATFORM_WIN32_KHR)
+	endif()
+endif()
+
 set(pcsx2GSMetalShaders
 	GS/Renderers/Metal/cas.metal
 	GS/Renderers/Metal/convert.metal
diff --git a/pcsx2/Config.h b/pcsx2/Config.h
index 88f4da719..b41bfca20 100644
--- a/pcsx2/Config.h
+++ b/pcsx2/Config.h
@@ -276,6 +276,7 @@ enum class GSRendererType : s8
 	VK = 14,
 	Metal = 17,
 	DX12 = 15,
+	ParallelGS = 18
 };
 
 enum class GSVSyncMode : u8
@@ -814,6 +815,9 @@ struct Pcsx2Config
 		u8 ShadeBoost_Contrast = 50;
 		u8 ShadeBoost_Saturation = 50;
 		u8 PNGCompressionLevel = 1;
+		u8 PGSSuperSampling = 0;
+		u8 PGSHighResScanout = 0;
+		u8 PGSDisableMipmaps = 0;
 
 		u16 SWExtraThreads = 2;
 		u16 SWExtraThreadsHeight = 4;
diff --git a/pcsx2/GS/GS.cpp b/pcsx2/GS/GS.cpp
index 84956d86a..94af60d8a 100644
--- a/pcsx2/GS/GS.cpp
+++ b/pcsx2/GS/GS.cpp
@@ -22,6 +22,11 @@
 #include "GS/Renderers/HW/GSTextureReplacements.h"
 #include "VMManager.h"
 
+#ifdef HAVE_PARALLEL_GS
+#include "GS/Renderers/parallel-gs/GSRendererPGS.h"
+std::unique_ptr<GSRendererPGS> g_pgs_renderer;
+#endif
+
 #ifdef ENABLE_OPENGL
 #include "GS/Renderers/OpenGL/GSDeviceOGL.h"
 #endif
@@ -58,6 +63,9 @@ Pcsx2Config::GSOptions GSConfig;
 
 static GSRendererType GSCurrentRenderer;
 
+struct FileDeleter { void operator()(FILE *file) { if (file) fclose(file); } };
+std::unique_ptr<FILE, FileDeleter> g_gs_stream;
+
 GSRendererType GSGetCurrentRenderer()
 {
 	return GSCurrentRenderer;
@@ -85,6 +93,11 @@ static RenderAPI GetAPIForRenderer(GSRendererType renderer)
 		case GSRendererType::VK:
 			return RenderAPI::Vulkan;
 
+#ifdef HAVE_PARALLEL_GS
+		case GSRendererType::ParallelGS:
+			return RenderAPI::Granite;
+#endif
+
 #ifdef _WIN32
 		case GSRendererType::DX11:
 			return RenderAPI::D3D11;
@@ -98,6 +111,10 @@ static RenderAPI GetAPIForRenderer(GSRendererType renderer)
 			return RenderAPI::Metal;
 #endif
 
+		case GSRendererType::SW:
+			// Hack.
+			return RenderAPI::Vulkan;
+
 			// We could end up here if we ever removed a renderer.
 		default:
 			return GetAPIForRenderer(GSUtil::GetPreferredRenderer());
@@ -135,6 +152,12 @@ static bool OpenGSDevice(GSRendererType renderer, bool clear_state_on_fail, bool
 			break;
 #endif
 
+#ifdef HAVE_PARALLEL_GS
+		case RenderAPI::Granite:
+			// The renderer owns its own device for now.
+			return true;
+#endif
+
 		default:
 			Console.Error("Unsupported render API %s", GSDevice::RenderAPIToString(new_api));
 			return false;
@@ -155,16 +178,20 @@ static bool OpenGSDevice(GSRendererType renderer, bool clear_state_on_fail, bool
 	if (!okay)
 	{
 		ImGuiManager::Shutdown(clear_state_on_fail);
-		g_gs_device->Destroy();
-		g_gs_device.reset();
+		if (g_gs_device)
+		{
+			g_gs_device->Destroy();
+			g_gs_device.reset();
+		}
 		Host::ReleaseRenderWindow();
 		return false;
 	}
 
-	GSConfig.OsdShowGPU = GSConfig.OsdShowGPU && g_gs_device->SetGPUTimingEnabled(true);
+	GSConfig.OsdShowGPU = g_gs_device && GSConfig.OsdShowGPU && g_gs_device->SetGPUTimingEnabled(true);
 
 	Console.WriteLn(Color_StrongGreen, "%s Graphics Driver Info:", GSDevice::RenderAPIToString(new_api));
-	Console.WriteLn(g_gs_device->GetDriverInfo());
+	if (g_gs_device)
+		Console.WriteLn(g_gs_device->GetDriverInfo());
 
 	return true;
 }
@@ -208,6 +235,17 @@ static bool OpenGSRenderer(GSRendererType renderer, u8* basemem)
 	{
 		g_gs_renderer = std::make_unique<GSRendererNull>();
 	}
+#ifdef HAVE_PARALLEL_GS
+	else if (renderer == GSRendererType::ParallelGS)
+	{
+		g_pgs_renderer = std::make_unique<GSRendererPGS>(basemem);
+		if (!g_pgs_renderer->Init())
+		{
+			g_pgs_renderer.reset();
+			return false;
+		}
+	}
+#endif
 	else if (renderer != GSRendererType::SW)
 	{
 		GSClampUpscaleMultiplier(GSConfig);
@@ -218,10 +256,18 @@ static bool OpenGSRenderer(GSRendererType renderer, u8* basemem)
 		g_gs_renderer = std::unique_ptr<GSRenderer>(MULTI_ISA_SELECT(makeGSRendererSW)(GSConfig.SWExtraThreads));
 	}
 
-	g_gs_renderer->SetRegsMem(basemem);
-	g_gs_renderer->ResetPCRTC();
-	g_gs_renderer->UpdateRenderFixes();
+	if (g_gs_renderer)
+	{
+		g_gs_renderer->SetRegsMem(basemem);
+		g_gs_renderer->ResetPCRTC();
+		g_gs_renderer->UpdateRenderFixes();
+	}
 	g_perfmon.Reset();
+
+	const char *env = getenv("GS_STREAM");
+	if (env)
+		g_gs_stream.reset(fopen(env, "wb"));
+
 	return true;
 }
 
@@ -229,11 +275,17 @@ static void CloseGSRenderer()
 {
 	GSTextureReplacements::Shutdown();
 
+#ifdef HAVE_PARALLEL_GS
+	g_pgs_renderer.reset();
+#endif
+
 	if (g_gs_renderer)
 	{
 		g_gs_renderer->Destroy();
 		g_gs_renderer.reset();
 	}
+
+	g_gs_stream.reset();
 }
 
 bool GSreopen(bool recreate_device, bool recreate_renderer, GSRendererType new_renderer,
@@ -241,18 +293,21 @@ bool GSreopen(bool recreate_device, bool recreate_renderer, GSRendererType new_r
 {
 	Console.WriteLn("Reopening GS with %s device", recreate_device ? "new" : "existing");
 
-	g_gs_renderer->Flush(GSState::GSFlushReason::GSREOPEN);
-
-	if (recreate_device && !recreate_renderer)
-	{
-		// Keeping the renderer around, this probably means we lost the device, so toss everything.
-		g_gs_renderer->PurgeTextureCache(true, true, true);
-		g_gs_device->ClearCurrent();
-		g_gs_device->PurgePool();
-	}
-	else if (GSConfig.UserHacks_ReadTCOnClose)
+	if (g_gs_renderer)
 	{
-		g_gs_renderer->ReadbackTextureCache();
+		g_gs_renderer->Flush(GSState::GSFlushReason::GSREOPEN);
+
+		if (recreate_device && !recreate_renderer)
+		{
+			// Keeping the renderer around, this probably means we lost the device, so toss everything.
+			g_gs_renderer->PurgeTextureCache(true, true, true);
+			g_gs_device->ClearCurrent();
+			g_gs_device->PurgePool();
+		}
+		else if (GSConfig.UserHacks_ReadTCOnClose)
+		{
+			g_gs_renderer->ReadbackTextureCache();
+		}
 	}
 
 	std::string capture_filename;
@@ -262,27 +317,65 @@ bool GSreopen(bool recreate_device, bool recreate_renderer, GSRendererType new_r
 		capture_filename = GSCapture::GetNextCaptureFileName();
 		capture_size = GSCapture::GetSize();
 		Console.Warning(fmt::format("Restarting video capture to {}.", capture_filename));
-		g_gs_renderer->EndCapture();
+		if (g_gs_renderer)
+			g_gs_renderer->EndCapture();
 	}
 
-	u8* basemem = g_gs_renderer->GetRegsMem();
+	u8* basemem;
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+	{
+		basemem = g_pgs_renderer->GetRegsMem();
+	}
+	else
+#endif
+	{
+		basemem = g_gs_renderer->GetRegsMem();
+	}
 
 	freezeData fd = {};
 	std::unique_ptr<u8[]> fd_data;
 	if (recreate_renderer)
 	{
-		if (g_gs_renderer->Freeze(&fd, true) != 0)
+#ifdef HAVE_PARALLEL_GS
+		if (g_pgs_renderer)
 		{
-			Console.Error("(GSreopen) Failed to get GS freeze size");
-			return false;
+			if (g_pgs_renderer->Freeze(&fd, true) != 0)
+			{
+				Console.Error("(GSreopen) Failed to get GS freeze size");
+				return false;
+			}
+		}
+		else
+#endif
+		{
+			if (g_gs_renderer->Freeze(&fd, true) != 0)
+			{
+				Console.Error("(GSreopen) Failed to get GS freeze size");
+				return false;
+			}
 		}
 
 		fd_data = std::make_unique<u8[]>(fd.size);
 		fd.data = fd_data.get();
-		if (g_gs_renderer->Freeze(&fd, false) != 0)
+
+#ifdef HAVE_PARALLEL_GS
+		if (g_pgs_renderer)
 		{
-			Console.Error("(GSreopen) Failed to freeze GS");
-			return false;
+			if (g_pgs_renderer->Freeze(&fd, false) != 0)
+			{
+				Console.Error("(GSreopen) Failed to freeze GS");
+				return false;
+			}
+		}
+		else
+#endif
+		{
+			if (g_gs_renderer->Freeze(&fd, false) != 0)
+			{
+				Console.Error("(GSreopen) Failed to freeze GS");
+				return false;
+			}
 		}
 
 		CloseGSRenderer();
@@ -291,9 +384,10 @@ bool GSreopen(bool recreate_device, bool recreate_renderer, GSRendererType new_r
 	if (recreate_device)
 	{
 		// We need a new render window when changing APIs.
-		const bool recreate_window = (g_gs_device->GetRenderAPI() != GetAPIForRenderer(GSConfig.Renderer));
-		const GSVSyncMode vsync_mode = g_gs_device->GetVSyncMode();
-		const bool allow_present_throttle = g_gs_device->IsPresentThrottleAllowed();
+		const bool recreate_window = !g_gs_device || (g_gs_device->GetRenderAPI() != GetAPIForRenderer(GSConfig.Renderer));
+		// TODO: Pass these through.
+		const GSVSyncMode vsync_mode = g_gs_device ? g_gs_device->GetVSyncMode() : GSVSyncMode::FIFO;
+		const bool allow_present_throttle = !g_gs_device || g_gs_device->IsPresentThrottleAllowed();
 		CloseGSDevice(false);
 
 		if (!OpenGSDevice(new_renderer, false, recreate_window, vsync_mode, allow_present_throttle))
@@ -324,14 +418,27 @@ bool GSreopen(bool recreate_device, bool recreate_renderer, GSRendererType new_r
 			return false;
 		}
 
-		if (g_gs_renderer->Defrost(&fd) != 0)
+#ifdef HAVE_PARALLEL_GS
+		if (g_pgs_renderer)
 		{
-			Console.Error("(GSreopen) Failed to defrost");
-			return false;
+			if (g_pgs_renderer->Defrost(&fd) != 0)
+			{
+				Console.Error("(GSreopen) Failed to defrost");
+				return false;
+			}
+		}
+		else
+#endif
+		{
+			if (g_gs_renderer->Defrost(&fd) != 0)
+			{
+				Console.Error("(GSreopen) Failed to defrost");
+				return false;
+			}
 		}
 	}
 
-	if (!capture_filename.empty())
+	if (g_gs_renderer && !capture_filename.empty())
 		g_gs_renderer->BeginCapture(std::move(capture_filename), capture_size);
 
 	return true;
@@ -377,6 +484,14 @@ void GSclose()
 
 void GSreset(bool hardware_reset)
 {
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		g_pgs_renderer->Reset(hardware_reset);
+#endif
+
+	if (!g_gs_renderer)
+		return;
+
 	g_gs_renderer->Reset(hardware_reset);
 
 	// Restart video capture if it's been started.
@@ -393,56 +508,138 @@ void GSreset(bool hardware_reset)
 
 void GSgifSoftReset(u32 mask)
 {
-	g_gs_renderer->SoftReset(mask);
+	if (g_gs_renderer)
+		g_gs_renderer->SoftReset(mask);
 }
 
 void GSwriteCSR(u32 csr)
 {
-	g_gs_renderer->WriteCSR(csr);
+	// TODO: Do we need to care about CSR in parallel-GS?
+	if (g_gs_renderer)
+		g_gs_renderer->WriteCSR(csr);
 }
 
 void GSInitAndReadFIFO(u8* mem, u32 size)
 {
-	GL_PERF("Init and read FIFO %u qwc", size);
-	g_gs_renderer->InitReadFIFO(mem, size);
-	g_gs_renderer->ReadFIFO(mem, size);
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		g_pgs_renderer->ReadFIFO(mem, size);
+#endif
+
+	if (g_gs_renderer)
+	{
+		GL_PERF("Init and read FIFO %u qwc", size);
+		g_gs_renderer->InitReadFIFO(mem, size);
+		g_gs_renderer->ReadFIFO(mem, size);
+	}
 }
 
 void GSReadLocalMemoryUnsync(u8* mem, u32 qwc, u64 BITBLITBUF, u64 TRXPOS, u64 TRXREG)
 {
-	g_gs_renderer->ReadLocalMemoryUnsync(mem, qwc, GIFRegBITBLTBUF{BITBLITBUF}, GIFRegTRXPOS{TRXPOS}, GIFRegTRXREG{TRXREG});
+	// TODO: What is this?
+	if (g_gs_renderer)
+		g_gs_renderer->ReadLocalMemoryUnsync(mem, qwc, GIFRegBITBLTBUF{BITBLITBUF}, GIFRegTRXPOS{TRXPOS}, GIFRegTRXREG{TRXREG});
 }
 
 void GSgifTransfer(const u8* mem, u32 size)
 {
-	g_gs_renderer->Transfer<3>(mem, size);
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		g_pgs_renderer->Transfer(mem, size);
+#endif
+
+	if (g_gs_renderer)
+		g_gs_renderer->Transfer<3>(mem, size);
+
+	if (g_gs_stream)
+	{
+		auto *f = g_gs_stream.get();
+		const uint8_t type = 0;
+		const uint8_t path = 3;
+		fwrite(&type, sizeof(type), 1, f);
+		fwrite(&path, sizeof(path), 1, f);
+		size *= 16;
+		fwrite(&size, sizeof(size), 1, f);
+		fwrite(mem, size, 1, f);
+	}
 }
 
 void GSgifTransfer1(u8* mem, u32 addr)
 {
-	g_gs_renderer->Transfer<0>(const_cast<u8*>(mem) + addr, (0x4000 - addr) / 16);
+	// TODO: These seem to be completely unused.
+	if (g_gs_renderer)
+		g_gs_renderer->Transfer<0>(const_cast<u8*>(mem) + addr, (0x4000 - addr) / 16);
 }
 
 void GSgifTransfer2(u8* mem, u32 size)
 {
-	g_gs_renderer->Transfer<1>(const_cast<u8*>(mem), size);
+	// TODO: These seem to be completely unused.
+	if (g_gs_renderer)
+		g_gs_renderer->Transfer<1>(const_cast<u8*>(mem), size);
 }
 
 void GSgifTransfer3(u8* mem, u32 size)
 {
-	g_gs_renderer->Transfer<2>(const_cast<u8*>(mem), size);
+	// TODO: These seem to be completely unused.
+	if (g_gs_renderer)
+		g_gs_renderer->Transfer<2>(const_cast<u8*>(mem), size);
 }
 
 void GSvsync(u32 field, bool registers_written)
 {
+	if (g_gs_stream)
+	{
+		auto *f = g_gs_stream.get();
+
+		const uint8_t priv_type = 3;
+		fwrite(&priv_type, sizeof(priv_type), 1, f);
+
+#ifdef HAVE_PARALLEL_GS
+		if (g_pgs_renderer)
+			fwrite(g_pgs_renderer->GetRegsMem(), sizeof(GSPrivRegSet), 1, f);
+		else
+#endif
+		{
+			fwrite(g_gs_renderer->GetRegsMem(), sizeof(GSPrivRegSet), 1, f);
+		}
+
+		const uint8_t type = 1;
+		fwrite(&type, sizeof(type), 1, f);
+		const uint8_t u8_field = field;
+		fwrite(&u8_field, sizeof(u8_field), 1, f);
+	}
+
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		g_pgs_renderer->VSync(field, registers_written);
+#endif
+
 	// Do not move the flush into the VSync() method. It's here because EE transfers
 	// get cleared in HW VSync, and may be needed for a buffered draw (FFX FMVs).
-	g_gs_renderer->Flush(GSState::VSYNC);
-	g_gs_renderer->VSync(field, registers_written, g_gs_renderer->IsIdleFrame());
+	if (g_gs_renderer)
+	{
+		g_gs_renderer->Flush(GSState::VSYNC);
+		g_gs_renderer->VSync(field, registers_written, g_gs_renderer->IsIdleFrame());
+	}
 }
 
 int GSfreeze(FreezeAction mode, freezeData* data)
 {
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+	{
+		if (mode == FreezeAction::Save)
+			return g_pgs_renderer->Freeze(data, false);
+		else if (mode == FreezeAction::Size)
+			return g_pgs_renderer->Freeze(data, true);
+		else // if (mode == FreezeAction::Load)
+			return g_pgs_renderer->Defrost(data);
+	}
+#endif
+
+	if (!g_gs_renderer)
+		return -1;
+
 	if (mode == FreezeAction::Save)
 	{
 		return g_gs_renderer->Freeze(data, false);
@@ -469,6 +666,10 @@ int GSfreeze(FreezeAction mode, freezeData* data)
 
 void GSQueueSnapshot(const std::string& path, u32 gsdump_frames)
 {
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		g_pgs_renderer->QueueSnapshot(GSGetBaseSnapshotFilename(), gsdump_frames);
+#endif
 	if (g_gs_renderer)
 		g_gs_renderer->QueueSnapshot(path, gsdump_frames);
 }
@@ -495,11 +696,15 @@ void GSEndCapture()
 
 void GSPresentCurrentFrame()
 {
-	g_gs_renderer->PresentCurrentFrame();
+	if (g_gs_renderer)
+		g_gs_renderer->PresentCurrentFrame();
 }
 
 void GSThrottlePresentation()
 {
+	if (!g_gs_device)
+		return;
+
 	if (g_gs_device->GetVSyncMode() == GSVSyncMode::FIFO)
 	{
 		// Let vsync take care of throttling.
@@ -520,25 +725,49 @@ void GSGameChanged()
 
 bool GSHasDisplayWindow()
 {
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		return g_pgs_renderer->GetWindowInfo().type != WindowInfo::Type::Surfaceless;
+#else
 	pxAssert(g_gs_device);
-	return (g_gs_device->GetWindowInfo().type != WindowInfo::Type::Surfaceless);
+#endif
+
+	if (g_gs_device)
+		return (g_gs_device->GetWindowInfo().type != WindowInfo::Type::Surfaceless);
+	else
+		return false;
 }
 
 void GSResizeDisplayWindow(int width, int height, float scale)
 {
-	g_gs_device->ResizeWindow(width, height, scale);
-	ImGuiManager::WindowResized();
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		g_pgs_renderer->ResizeWindow(width, height, scale);
+#endif
+	if (g_gs_device)
+	{
+		g_gs_device->ResizeWindow(width, height, scale);
+		ImGuiManager::WindowResized();
+	}
 }
 
 void GSUpdateDisplayWindow()
 {
-	if (!g_gs_device->UpdateWindow())
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+	{
+		g_pgs_renderer->UpdateWindow();
+	}
+#endif
+
+	if (g_gs_device && !g_gs_device->UpdateWindow())
 	{
 		Host::ReportErrorAsync("Error", TRANSLATE_SV("GS", "Failed to change window after update. The log may contain more information."));
 		return;
 	}
 
-	ImGuiManager::WindowResized();
+	if (g_gs_device)
+		ImGuiManager::WindowResized();
 }
 
 void GSSetVSyncMode(GSVSyncMode mode, bool allow_present_throttle)
@@ -550,7 +779,12 @@ void GSSetVSyncMode(GSVSyncMode mode, bool allow_present_throttle)
 	}};
 	Console.WriteLnFmt(Color_StrongCyan, "Setting vsync mode: {}{}", modes[static_cast<size_t>(mode)],
 		allow_present_throttle ? " (throttle allowed)" : "");
-	g_gs_device->SetVSyncMode(mode, allow_present_throttle);
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		g_pgs_renderer->SetVSyncMode(mode, allow_present_throttle);
+#endif
+	if (g_gs_device)
+		g_gs_device->SetVSyncMode(mode, allow_present_throttle);
 }
 
 bool GSWantsExclusiveFullscreen()
@@ -599,6 +833,19 @@ std::vector<GSAdapterInfo> GSGetAdapterInfo(GSRendererType renderer)
 		break;
 #endif
 
+#ifdef HAVE_PARALLEL_GS
+		case GSRendererType::ParallelGS:
+		{
+			// Dummy info.
+			GSAdapterInfo adapter = {};
+			adapter.name = "default";
+			adapter.fullscreen_modes = { "fullscreen" };
+			adapter.max_texture_size = 4096;
+			adapter.max_upscale_multiplier = 4;
+			return { adapter };
+		}
+#endif
+
 #ifdef __APPLE__
 		case GSRendererType::Metal:
 		{
@@ -622,13 +869,29 @@ u32 GSGetMaxUpscaleMultiplier(u32 max_texture_size)
 
 GSVideoMode GSgetDisplayMode()
 {
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		return GSVideoMode{};
+#endif
+
 	GSRenderer* gs = g_gs_renderer.get();
 
-	return gs->GetVideoMode();
+	if (gs)
+		return gs->GetVideoMode();
+	else
+		return GSVideoMode{};
 }
 
 void GSgetInternalResolution(int* width, int* height)
 {
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+	{
+		g_pgs_renderer->GetInternalResolution(width, height);
+		return;
+	}
+#endif
+
 	GSRenderer* gs = g_gs_renderer.get();
 	if (!gs)
 	{
@@ -749,8 +1012,11 @@ void GSUpdateConfig(const Pcsx2Config::GSOptions& new_config)
 {
 	Pcsx2Config::GSOptions old_config(std::move(GSConfig));
 	GSConfig = new_config;
-	if (!g_gs_renderer)
-		return;
+
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		g_pgs_renderer->UpdateConfig();
+#endif
 
 	// Handle OSD scale changes by pushing a window resize through.
 	if (new_config.OsdScale != old_config.OsdScale)
@@ -764,6 +1030,9 @@ void GSUpdateConfig(const Pcsx2Config::GSOptions& new_config)
 		return;
 	}
 
+	if (!g_gs_renderer)
+		return;
+
 	// Ensure upscale multiplier is in range.
 	GSClampUpscaleMultiplier(GSConfig);
 
diff --git a/pcsx2/GS/GS.h b/pcsx2/GS/GS.h
index f2882c3a7..433bdfb62 100644
--- a/pcsx2/GS/GS.h
+++ b/pcsx2/GS/GS.h
@@ -20,6 +20,7 @@ enum class RenderAPI
 	Metal,
 	D3D12,
 	Vulkan,
+	Granite,
 	OpenGL
 };
 
@@ -110,6 +111,8 @@ bool GSSaveSnapshotToMemory(u32 window_width, u32 window_height, bool apply_aspe
 	u32* width, u32* height, std::vector<u32>* pixels);
 void GSJoinSnapshotThreads();
 
+float GetCurrentAspectRatioFloat(bool is_progressive);
+
 namespace Host
 {
 	/// Called when the GS is creating a render device.
diff --git a/pcsx2/GS/GSState.cpp b/pcsx2/GS/GSState.cpp
index 83068f15d..045201926 100644
--- a/pcsx2/GS/GSState.cpp
+++ b/pcsx2/GS/GSState.cpp
@@ -32,7 +32,7 @@ static __fi bool IsFirstProvokingVertex()
 	return (GSIsHardwareRenderer() && !g_gs_device->Features().provoking_vertex_last);
 }
 
-constexpr int GSState::GetSaveStateSize()
+int GSState::GetSaveStateSize()
 {
 	int size = 0;
 
diff --git a/pcsx2/GS/GSState.h b/pcsx2/GS/GSState.h
index 94f9a5442..5128a0043 100644
--- a/pcsx2/GS/GSState.h
+++ b/pcsx2/GS/GSState.h
@@ -21,7 +21,7 @@ public:
 	GSState();
 	virtual ~GSState();
 
-	static constexpr int GetSaveStateSize();
+	static int GetSaveStateSize();
 
 private:
 	// RESTRICT prevents multiple loads of the same part of the register when accessing its bitfields (the compiler is happy to know that memory writes in-between will not go there)
diff --git a/pcsx2/GS/GSUtil.cpp b/pcsx2/GS/GSUtil.cpp
index 63ae1db03..fdea62b2d 100644
--- a/pcsx2/GS/GSUtil.cpp
+++ b/pcsx2/GS/GSUtil.cpp
@@ -204,7 +204,9 @@ GSRendererType GSUtil::GetPreferredRenderer()
 	static GSRendererType preferred_renderer = GSRendererType::Auto;
 	if (preferred_renderer == GSRendererType::Auto)
 	{
-#if defined(__APPLE__)
+#if defined(HAVE_PARALLEL_GS)
+		preferred_renderer = GSRendererType::ParallelGS;
+#elif defined(__APPLE__)
 		// Mac: Prefer Metal hardware.
 		preferred_renderer = GSRendererType::Metal;
 #elif defined(_WIN32) && defined(_M_ARM64)
diff --git a/pcsx2/GS/Renderers/Common/GSRenderer.cpp b/pcsx2/GS/Renderers/Common/GSRenderer.cpp
index e564e0e6d..e29148065 100644
--- a/pcsx2/GS/Renderers/Common/GSRenderer.cpp
+++ b/pcsx2/GS/Renderers/Common/GSRenderer.cpp
@@ -275,7 +275,7 @@ float GSRenderer::GetModXYOffset()
 	return 0.0f;
 }
 
-static float GetCurrentAspectRatioFloat(bool is_progressive)
+float GetCurrentAspectRatioFloat(bool is_progressive)
 {
 	static constexpr std::array<float, static_cast<size_t>(AspectRatioType::MaxCount) + 1> ars = {{4.0f / 3.0f, 4.0f / 3.0f, 4.0f / 3.0f, 16.0f / 9.0f, 10.0f / 7.0f, 3.0f / 2.0f}};
 	return ars[static_cast<u32>(GSConfig.AspectRatio) + (3u * (is_progressive && GSConfig.AspectRatio == AspectRatioType::RAuto4_3_3_2))];
diff --git a/pcsx2/GS/Renderers/Vulkan/VKLoader.cpp b/pcsx2/GS/Renderers/Vulkan/VKLoader.cpp
index e386e6fe5..c7d538135 100644
--- a/pcsx2/GS/Renderers/Vulkan/VKLoader.cpp
+++ b/pcsx2/GS/Renderers/Vulkan/VKLoader.cpp
@@ -16,6 +16,8 @@
 
 extern "C" {
 
+#ifndef HAVE_PARALLEL_GS
+// Crude hack, but this conflicts with volk.
 #define VULKAN_MODULE_ENTRY_POINT(name, required) PFN_##name name;
 #define VULKAN_INSTANCE_ENTRY_POINT(name, required) PFN_##name name;
 #define VULKAN_DEVICE_ENTRY_POINT(name, required) PFN_##name name;
@@ -23,6 +25,7 @@ extern "C" {
 #undef VULKAN_DEVICE_ENTRY_POINT
 #undef VULKAN_INSTANCE_ENTRY_POINT
 #undef VULKAN_MODULE_ENTRY_POINT
+#endif
 }
 
 void Vulkan::ResetVulkanLibraryFunctionPointers()
@@ -79,7 +82,10 @@ bool Vulkan::LoadVulkanLibrary(Error* error)
 
 	if (required_functions_missing)
 	{
+#ifndef HAVE_PARALLEL_GS
+		// FIXME: parallel-gs share volk global pointers.
 		ResetVulkanLibraryFunctionPointers();
+#endif
 		s_vulkan_library.Close();
 		return false;
 	}
@@ -89,7 +95,10 @@ bool Vulkan::LoadVulkanLibrary(Error* error)
 
 void Vulkan::UnloadVulkanLibrary()
 {
+#ifndef HAVE_PARALLEL_GS
+	// FIXME: parallel-gs share volk global pointers.
 	ResetVulkanLibraryFunctionPointers();
+#endif
 	s_vulkan_library.Close();
 }
 
@@ -97,8 +106,13 @@ bool Vulkan::LoadVulkanInstanceFunctions(VkInstance instance)
 {
 	bool required_functions_missing = false;
 	auto LoadFunction = [&required_functions_missing, instance](PFN_vkVoidFunction* func_ptr, const char* name, bool is_required) {
-		*func_ptr = vkGetInstanceProcAddr(instance, name);
-		if (!(*func_ptr) && is_required)
+		auto proc = vkGetInstanceProcAddr(instance, name);
+		// Only override the global pointer if the pointer is non-null. This avoids a problem where GetAdapters()
+		// tries to load KHR_surface functions but fails since VK_KHR_surface is not enabled.
+		// Temporary hack for parallel-gs interoperability since they share volk implementation.
+		if (proc)
+			*func_ptr = proc;
+		if (!proc && is_required)
 		{
 			std::fprintf(stderr, "Vulkan: Failed to load required instance function %s\n", name);
 			required_functions_missing = true;
diff --git a/pcsx2/GS/Renderers/Vulkan/VKLoader.h b/pcsx2/GS/Renderers/Vulkan/VKLoader.h
index 736723fca..cfba3a7c9 100644
--- a/pcsx2/GS/Renderers/Vulkan/VKLoader.h
+++ b/pcsx2/GS/Renderers/Vulkan/VKLoader.h
@@ -7,24 +7,7 @@ class Error;
 
 #define VK_NO_PROTOTYPES
 
-#ifdef _WIN32
-#define VK_USE_PLATFORM_WIN32_KHR
-
-// vulkan.h pulls in windows.h on Windows, so we need to include our replacement header first
-#include "common/RedtapeWindows.h"
-#endif
-
-#if defined(X11_API)
-#define VK_USE_PLATFORM_XLIB_KHR
-#endif
-
-#if defined(WAYLAND_API)
-#define VK_USE_PLATFORM_WAYLAND_KHR
-#endif
-
-#if defined(__APPLE__)
-#define VK_USE_PLATFORM_METAL_EXT
-#endif
+#include "VKLoaderPlatformDefines.h"
 
 #include "vulkan/vulkan.h"
 
diff --git a/pcsx2/GS/Renderers/Vulkan/VKLoaderPlatformDefines.h b/pcsx2/GS/Renderers/Vulkan/VKLoaderPlatformDefines.h
new file mode 100644
index 000000000..d3447f6f7
--- /dev/null
+++ b/pcsx2/GS/Renderers/Vulkan/VKLoaderPlatformDefines.h
@@ -0,0 +1,23 @@
+// SPDX-FileCopyrightText: 2002-2024 PCSX2 Dev Team
+// SPDX-License-Identifier: LGPL-3.0+
+#pragma once
+
+#ifdef _WIN32
+#define VK_USE_PLATFORM_WIN32_KHR
+
+// vulkan.h pulls in windows.h on Windows, so we need to include our replacement header first
+#include "common/RedtapeWindows.h"
+#endif
+
+#if defined(X11_API)
+#define VK_USE_PLATFORM_XLIB_KHR
+#endif
+
+#if defined(WAYLAND_API)
+#define VK_USE_PLATFORM_WAYLAND_KHR
+#endif
+
+#if defined(__APPLE__)
+#define VK_USE_PLATFORM_METAL_EXT
+#endif
+
diff --git a/pcsx2/GS/Renderers/parallel-gs/GSRendererPGS.cpp b/pcsx2/GS/Renderers/parallel-gs/GSRendererPGS.cpp
new file mode 100644
index 000000000..906baf88c
--- /dev/null
+++ b/pcsx2/GS/Renderers/parallel-gs/GSRendererPGS.cpp
@@ -0,0 +1,818 @@
+// SPDX-FileCopyrightText: 2024 Hans-Kristian Arntzen
+// SPDX-License-Identifier: LGPL-3.0+
+
+#include "GSRendererPGS.h"
+#include "GS/GSState.h"
+#include "GS.h"
+#include "math.hpp"
+#include "muglm/muglm_impl.hpp"
+#include "shaders/slangmosh.hpp"
+#include "PerformanceMetrics.h"
+#include "VMManager.h"
+
+// Workaround because msbuild is broken when mixing C and C++ it seems ...
+#ifdef _MSC_VER
+extern "C" {
+#include "volk.c"
+}
+#endif
+
+using namespace Vulkan;
+using namespace ParallelGS;
+using namespace Granite;
+
+static void FsrEasuCon(
+	float *con0,
+	float *con1,
+	float *con2,
+	float *con3,
+	float inputViewportInPixelsX,
+	float inputViewportInPixelsY,
+	float inputSizeInPixelsX,
+	float inputSizeInPixelsY,
+	float outputSizeInPixelsX,
+	float outputSizeInPixelsY)
+{
+	// Output integer position to a pixel position in viewport.
+	con0[0] = inputViewportInPixelsX / outputSizeInPixelsX;
+	con0[1] = inputViewportInPixelsY / outputSizeInPixelsY;
+	con0[2] = 0.5f * inputViewportInPixelsX / outputSizeInPixelsX - 0.5f;
+	con0[3] = 0.5f * inputViewportInPixelsY / outputSizeInPixelsY - 0.5f;
+	con1[0] = 1.0f / inputSizeInPixelsX;
+	con1[1] = 1.0f / inputSizeInPixelsY;
+	con1[2] = 1.0f / inputSizeInPixelsX;
+	con1[3] = -1.0f / inputSizeInPixelsY;
+	con2[0] = -1.0f / inputSizeInPixelsX;
+	con2[1] = 2.0f / inputSizeInPixelsY;
+	con2[2] = 1.0f / inputSizeInPixelsX;
+	con2[3] = 2.0f / inputSizeInPixelsY;
+	con3[0] = 0.0f / inputSizeInPixelsX;
+	con3[1] = 4.0f / inputSizeInPixelsY;
+	con3[2] = con3[3] = 0.0f;
+}
+
+static void FsrRcasCon(float *con, float sharpness)
+{
+	sharpness = muglm::exp2(-sharpness);
+	uint32_t half = floatToHalf(sharpness);
+	con[0] = sharpness;
+	uint32_t halves = half | (half << 16);
+	memcpy(&con[1], &halves, sizeof(halves));
+	con[2] = 0.0f;
+	con[3] = 0.0f;
+}
+
+void GSRendererPGS::render_fsr(CommandBuffer &cmd, const ImageView &view)
+{
+	cmd.image_barrier(*fsr_render_target,
+		VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,
+		VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, 0,
+		VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT);
+
+	RenderPassInfo rp = {};
+	rp.num_color_attachments = 1;
+	rp.color_attachments[0] = &fsr_render_target->get_view();
+	rp.store_attachments = 1u << 0;
+
+	cmd.begin_render_pass(rp);
+	{
+		struct Constants
+		{
+			float params[4][4];
+		} constants;
+
+		struct Push
+		{
+			float width, height;
+		} push;
+
+		auto width = float(view.get_image().get_width());
+		auto height = float(view.get_image().get_height());
+		auto *params = cmd.allocate_typed_constant_data<Constants>(1, 0, 1);
+		FsrEasuCon(constants.params[0], constants.params[1], constants.params[2], constants.params[3],
+			width, height, width, height, cmd.get_viewport().width, cmd.get_viewport().height);
+		*params = constants;
+
+		push.width = cmd.get_viewport().width;
+		push.height = cmd.get_viewport().height;
+		cmd.push_constants(&push, 0, sizeof(push));
+
+		const vec2 vertex_data[] = { vec2(-1.0f, -1.0f), vec2(-1.0f, 3.0f), vec2(3.0f, -1.0f) };
+		memcpy(cmd.allocate_vertex_data(0, sizeof(vertex_data), sizeof(vec2)), vertex_data, sizeof(vertex_data));
+		cmd.set_vertex_attrib(0, 0, VK_FORMAT_R32G32_SFLOAT, 0);
+
+		cmd.set_texture(0, 0, view, StockSampler::NearestClamp);
+
+		cmd.set_program(upscale_program);
+		cmd.set_opaque_state();
+		cmd.set_depth_test(false, false);
+		cmd.draw(3);
+	}
+	cmd.end_render_pass();
+
+	cmd.image_barrier(*fsr_render_target,
+		VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
+		VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,
+		VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, VK_ACCESS_2_SHADER_SAMPLED_READ_BIT);
+}
+
+void GSRendererPGS::render_rcas(CommandBuffer &cmd, const ImageView &view,
+                                float offset_x, float offset_y,
+                                float width, float height)
+{
+	struct Constants
+	{
+		float params[4];
+		int32_t range[4];
+	} constants;
+
+	FsrRcasCon(constants.params, 0.5f);
+	constants.range[0] = 0;
+	constants.range[1] = 0;
+	constants.range[2] = int(view.get_view_width()) - 1;
+	constants.range[3] = int(view.get_view_height()) - 1;
+	auto *params = cmd.allocate_typed_constant_data<Constants>(1, 0, 1);
+	*params = constants;
+
+	const vec2 vertex_data[] = { vec2(-1.0f, -1.0f), vec2(-1.0f, 3.0f), vec2(3.0f, -1.0f) };
+	memcpy(cmd.allocate_vertex_data(0, sizeof(vertex_data), sizeof(vec2)), vertex_data, sizeof(vertex_data));
+	cmd.set_vertex_attrib(0, 0, VK_FORMAT_R32G32_SFLOAT, 0);
+	cmd.set_srgb_texture(0, 0, view);
+	cmd.set_sampler(0, 0, Vulkan::StockSampler::NearestClamp);
+	cmd.set_opaque_state();
+	cmd.set_depth_test(false, false);
+	cmd.set_program(sharpen_program);
+
+	cmd.set_viewport({ offset_x, offset_y, width, height, 0.0f, 1.0f });
+	cmd.draw(3);
+}
+
+void GSRendererPGS::render_blit(CommandBuffer &cmd, const ImageView &view,
+                                float offset_x, float offset_y,
+                                float width, float height)
+{
+	cmd.set_srgb_texture(0, 0, view);
+	cmd.set_sampler(0, 0, GSConfig.LinearPresent != GSPostBilinearMode::Off ?
+	                      Vulkan::StockSampler::LinearClamp : Vulkan::StockSampler::NearestClamp);
+	cmd.set_opaque_state();
+	cmd.set_depth_test(false, false);
+	cmd.set_program(blit_program);
+
+	cmd.set_viewport({ offset_x, offset_y, width, height, 0.0f, 1.0f });
+	cmd.draw(3);
+}
+
+GSRendererPGS::GSRendererPGS(u8 *basemem)
+	: priv(reinterpret_cast<PrivRegisterState *>(basemem))
+{
+	wsi.set_backbuffer_format(BackbufferFormat::sRGB);
+}
+
+u8 *GSRendererPGS::GetRegsMem()
+{
+	return reinterpret_cast<u8 *>(priv);
+}
+
+struct ParsedSuperSampling
+{
+	SuperSampling super_sampling;
+	bool ordered;
+};
+
+static ParsedSuperSampling parse_super_sampling_options(u8 super_sampling)
+{
+	ParsedSuperSampling parsed = {};
+
+	if (super_sampling > 5)
+		super_sampling = 5;
+
+	parsed.ordered = super_sampling == 3;
+
+	if (super_sampling >= 3)
+		super_sampling--;
+	parsed.super_sampling = SuperSampling(1u << super_sampling);
+
+	return parsed;
+}
+
+bool GSRendererPGS::Init()
+{
+	// Always force the reload, since the other backends may clobber the volk pointers.
+	if (!Context::init_loader(nullptr, true))
+		return false;
+
+	wsi.set_platform(this);
+	wsi.set_frame_duplication_aware(true);
+	bool ret = wsi.init_simple(1, {});
+	if (!ret)
+		return false;
+
+	// We will cycle through many memory contexts per frame most likely.
+	wsi.get_device().init_frame_contexts(12);
+
+	ResourceLayout layout;
+	Shaders<> suite(wsi.get_device(), layout, 0);
+	upscale_program = wsi.get_device().request_program(suite.upscale_vert, suite.upscale_frag);
+	sharpen_program = wsi.get_device().request_program(suite.sharpen_vert, suite.sharpen_frag);
+	blit_program = wsi.get_device().request_program(suite.quad, suite.blit);
+
+	GSOptions opts = {};
+	opts.vram_size = GSLocalMemory::m_vmsize;
+
+	auto parsed = parse_super_sampling_options(GSConfig.PGSSuperSampling);
+	opts.super_sampling = parsed.super_sampling;
+	opts.ordered_super_sampling = parsed.ordered;
+
+	opts.dynamic_super_sampling = true;
+	if (!iface.init(&wsi.get_device(), opts))
+		return false;
+
+	current_super_sampling = opts.super_sampling;
+	current_ordered_super_sampling = opts.ordered_super_sampling;
+
+	Hacks hacks;
+	hacks.disable_mipmaps = GSConfig.PGSDisableMipmaps != 0;
+	iface.set_hacks(hacks);
+
+	return true;
+}
+
+void GSRendererPGS::Reset(bool /*hardware_reset*/)
+{
+	iface.reset_context_state();
+}
+
+void GSRendererPGS::UpdateConfig()
+{
+	auto parsed = parse_super_sampling_options(GSConfig.PGSSuperSampling);
+
+	if (parsed.super_sampling != current_super_sampling || parsed.ordered != current_ordered_super_sampling)
+	{
+		iface.set_super_sampling_rate(parsed.super_sampling, parsed.ordered);
+		current_super_sampling = parsed.super_sampling;
+		current_ordered_super_sampling = parsed.ordered;
+	}
+
+	Hacks hacks;
+	hacks.disable_mipmaps = GSConfig.PGSDisableMipmaps != 0;
+	iface.set_hacks(hacks);
+}
+
+int GSRendererPGS::GetSaveStateSize()
+{
+	return GSState::GetSaveStateSize();
+}
+
+static void write_data(u8*& dst, const void* src, size_t size)
+{
+	memcpy(dst, src, size);
+	dst += size;
+}
+
+template <typename T>
+static void write_reg(u8*& data, T t)
+{
+	write_data(data, &t, sizeof(t));
+}
+
+static void read_data(const u8*& src, void* dst, size_t size)
+{
+	memcpy(dst, src, size);
+	src += size;
+}
+
+template <typename T>
+static void read_reg(const u8*& src, T &t)
+{
+	read_data(src, &t, sizeof(t));
+}
+
+int GSRendererPGS::Freeze(freezeData* data, bool sizeonly)
+{
+	if (sizeonly)
+	{
+		data->size = GetSaveStateSize();
+		return 0;
+	}
+
+	if (!data->data || data->size < GetSaveStateSize())
+		return -1;
+
+	const void *vram = iface.map_vram_read(0, GSLocalMemory::m_vmsize);
+	auto &regs = iface.get_register_state();
+
+	u8 *ptr = data->data;
+
+	write_reg(ptr, GSState::STATE_VERSION);
+	write_reg(ptr, regs.prim);
+	write_reg(ptr, regs.prmodecont);
+	write_reg(ptr, regs.texclut);
+	write_reg(ptr, regs.scanmsk);
+	write_reg(ptr, regs.texa);
+	write_reg(ptr, regs.fogcol);
+	write_reg(ptr, regs.dimx);
+	write_reg(ptr, regs.dthe);
+	write_reg(ptr, regs.colclamp);
+	write_reg(ptr, regs.pabe);
+	write_reg(ptr, regs.bitbltbuf);
+	write_reg(ptr, regs.trxdir);
+	write_reg(ptr, regs.trxpos);
+	write_reg(ptr, regs.trxreg);
+	write_reg(ptr, regs.trxreg); // Dummy value
+
+	for (const auto &ctx : regs.ctx)
+	{
+		write_reg(ptr, ctx.xyoffset);
+		write_reg(ptr, ctx.tex0);
+		write_reg(ptr, ctx.tex1);
+		write_reg(ptr, ctx.clamp);
+		write_reg(ptr, ctx.miptbl_1_3);
+		write_reg(ptr, ctx.miptbl_4_6);
+		write_reg(ptr, ctx.scissor);
+		write_reg(ptr, ctx.alpha);
+		write_reg(ptr, ctx.test);
+		write_reg(ptr, ctx.fba);
+		write_reg(ptr, ctx.frame);
+		write_reg(ptr, ctx.zbuf);
+	}
+
+	write_reg(ptr, regs.rgbaq);
+	write_reg(ptr, regs.st);
+	write_reg(ptr, regs.uv.words[0]);
+	write_reg(ptr, regs.fog.words[0]);
+	// XYZ register, fill with dummy.
+	write_reg(ptr, Reg64<XYZBits>{0});
+
+	write_reg(ptr, UINT32_MAX); // Dummy GIFReg
+	write_reg(ptr, UINT32_MAX);
+
+	// Dummy transfer X/Y
+	write_reg(ptr, uint32_t(0));
+	write_reg(ptr, uint32_t(0));
+
+	write_data(ptr, vram, GSLocalMemory::m_vmsize);
+
+	// 4 GIF paths
+	for (int i = 0; i < 4; i++)
+	{
+		auto gif_path = iface.get_gif_path(i);
+		gif_path.tag.NLOOP -= gif_path.loop;
+		write_data(ptr, &gif_path.tag, sizeof(gif_path.tag));
+		write_reg(ptr, gif_path.reg);
+	}
+
+	// internal_Q
+	write_reg(ptr, regs.internal_q);
+	return 0;
+}
+
+int GSRendererPGS::Defrost(freezeData* data)
+{
+	if (!data || !data->data || data->size == 0)
+		return -1;
+
+	if (data->size < GetSaveStateSize())
+		return -1;
+
+	const u8* ptr = data->data;
+	auto &regs = iface.get_register_state();
+
+	u32 version;
+	read_reg(ptr, version);
+
+	if (version != GSState::STATE_VERSION)
+	{
+		Console.Error("GS: Savestate version is incompatible.  Load aborted.");
+		return -1;
+	}
+
+	read_reg(ptr, regs.prim);
+	read_reg(ptr, regs.prmodecont);
+	read_reg(ptr, regs.texclut);
+	read_reg(ptr, regs.scanmsk);
+	read_reg(ptr, regs.texa);
+	read_reg(ptr, regs.fogcol);
+	read_reg(ptr, regs.dimx);
+	read_reg(ptr, regs.dthe);
+	read_reg(ptr, regs.colclamp);
+	read_reg(ptr, regs.pabe);
+	read_reg(ptr, regs.bitbltbuf);
+	read_reg(ptr, regs.trxdir);
+	read_reg(ptr, regs.trxpos);
+	read_reg(ptr, regs.trxreg);
+	// Dummy value
+	ptr += sizeof(uint64_t);
+
+	for (auto &ctx : regs.ctx)
+	{
+		read_reg(ptr, ctx.xyoffset);
+		read_reg(ptr, ctx.tex0);
+		read_reg(ptr, ctx.tex1);
+		read_reg(ptr, ctx.clamp);
+		read_reg(ptr, ctx.miptbl_1_3);
+		read_reg(ptr, ctx.miptbl_4_6);
+		read_reg(ptr, ctx.scissor);
+		read_reg(ptr, ctx.alpha);
+		read_reg(ptr, ctx.test);
+		read_reg(ptr, ctx.fba);
+		read_reg(ptr, ctx.frame);
+		read_reg(ptr, ctx.zbuf);
+	}
+
+	read_reg(ptr, regs.rgbaq);
+	read_reg(ptr, regs.st);
+	read_reg(ptr, regs.uv.words[0]);
+	read_reg(ptr, regs.fog.words[0]);
+	// XYZ register, fill with dummy.
+	ptr += sizeof(uint64_t);
+
+	// Dummy GIFReg
+	ptr += 2 * sizeof(uint32_t);
+
+	// Dummy transfer X/Y
+	ptr += 2 * sizeof(uint32_t);
+
+	void *vram = iface.map_vram_write(0, GSLocalMemory::m_vmsize);
+	read_data(ptr, vram, GSLocalMemory::m_vmsize);
+	iface.end_vram_write(0, GSLocalMemory::m_vmsize);
+
+	// 4 GIF paths
+	for (int i = 0; i < 4; i++)
+	{
+		auto gif_path = iface.get_gif_path(i);
+		gif_path.tag.NLOOP -= gif_path.loop;
+		read_data(ptr, &gif_path.tag, sizeof(gif_path.tag));
+		gif_path.loop = 0;
+		read_reg(ptr, gif_path.reg);
+	}
+
+	// internal_Q
+	read_reg(ptr, iface.get_register_state().internal_q);
+
+	iface.clobber_register_state();
+	return 0;
+}
+
+void GSRendererPGS::VSync(u32 field, bool registers_written)
+{
+	if (dump)
+	{
+		if (dump->VSync(field, dump_frames == 0, reinterpret_cast<GSPrivRegSet *>(priv)))
+			dump.reset();
+		else if (dump_frames != 0)
+			dump_frames--;
+	}
+
+	iface.flush();
+	iface.get_priv_register_state() = *priv;
+
+	VSyncInfo info = {};
+
+	info.phase = field;
+
+	// Apparently this is needed for some games. It's set by game-fixes.
+	// I assume this problem exists at a higher level than whatever GS controls, so we'll just
+	// apply this hack too.
+	if (GSConfig.InterlaceMode != GSInterlaceMode::Automatic)
+		info.phase ^= (static_cast<int>(GSConfig.InterlaceMode) - 2) & 1;
+
+	info.anti_blur = GSConfig.PCRTCAntiBlur;
+	info.force_progressive = true;
+	info.overscan = GSConfig.PCRTCOverscan;
+	info.crtc_offsets = GSConfig.PCRTCOffsets;
+	info.dst_access = VK_ACCESS_2_SHADER_SAMPLED_READ_BIT;
+	info.dst_stage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;
+	info.dst_layout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
+	// The scaling blur is technically a blur ...
+	info.adapt_to_internal_horizontal_resolution = GSConfig.PCRTCAntiBlur;
+	info.raw_circuit_scanout = true;
+	info.high_resolution_scanout = GSConfig.PGSHighResScanout != 0;
+	auto vsync = iface.vsync(info);
+
+	auto stats = iface.consume_flush_stats();
+
+	bool frame_is_duped = !registers_written && stats.num_render_passes == 0 && stats.num_copies == 0;
+
+	// Experimental heuristic. If running on an iGPU / APU, we're quite wary about draining the GPU for work
+	// in GPU bound scenarios. This should keep the GPU better fed at the cost of a little more latency.
+	if (wsi.get_device().get_gpu_properties().deviceType == VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU &&
+	    frame_is_duped && !GSConfig.SkipDuplicateFrames)
+	{
+		wsi.set_next_present_is_duplicated();
+	}
+
+	if (GSConfig.SkipDuplicateFrames && has_presented_in_current_swapchain && frame_is_duped)
+	{
+		PerformanceMetrics::Update(false, false, true);
+		return;
+	}
+
+	if (vsync.image)
+	{
+		last_internal_width = vsync.internal_width;
+		last_internal_height = vsync.internal_height;
+		if (vsync.high_resolution_scanout)
+		{
+			last_internal_width *= 2;
+			last_internal_height *= 2;
+		}
+	}
+
+	if (!has_wsi_begin_frame)
+		has_wsi_begin_frame = wsi.begin_frame();
+
+	if (!has_wsi_begin_frame)
+		return;
+
+	auto &dev = wsi.get_device();
+
+	float vp_offset_x = 0.0f;
+	float vp_offset_y = 0.0f;
+	float vp_width = 0.0f;
+	float vp_height = 0.0f;
+
+	if (GSConfig.LinearPresent != GSPostBilinearMode::BilinearSharp)
+		fsr_render_target.reset();
+
+	if (vsync.image)
+	{
+		uint32_t fsr_width = dev.get_swapchain_view().get_view_width();
+		uint32_t fsr_height = dev.get_swapchain_view().get_view_height();
+		uint32_t new_width = fsr_width;
+		uint32_t new_height = fsr_height;
+
+		float display_aspect = float(fsr_width) / float(fsr_height);
+		float game_aspect = GetCurrentAspectRatioFloat(priv->smode1.CMOD == 0);
+
+		float horizontal_scanout_ratio = float(vsync.internal_width) / float(vsync.mode_width);
+		float vertical_scanout_ratio = float(vsync.internal_height) / float(vsync.mode_height);
+		game_aspect *= horizontal_scanout_ratio / vertical_scanout_ratio;
+
+		if (display_aspect > game_aspect)
+			new_width = uint32_t(std::round(float(fsr_height) * game_aspect));
+		else
+			new_height = uint32_t(std::round(float(fsr_width) / game_aspect));
+
+		// This won't preserve the aspect ratio necessarily, but eh.
+		if (GSConfig.IntegerScaling)
+		{
+			new_width -= new_width % vsync.image->get_width();
+			new_height -= new_height % vsync.image->get_height();
+			if (new_width == 0)
+				new_width = fsr_width;
+			if (new_height == 0)
+				new_height = fsr_height;
+		}
+
+		vp_offset_x = std::round(0.5f * float(fsr_width - new_width));
+		fsr_width = new_width;
+		vp_offset_y = std::round(0.5f * float(fsr_height - new_height));
+		fsr_height = new_height;
+
+		// Safeguard against ridiculous situations.
+		if (!fsr_width)
+			fsr_width = 1;
+		if (!fsr_height)
+			fsr_height = 1;
+
+		vp_width = float(fsr_width);
+		vp_height = float(fsr_height);
+
+		if (GSConfig.LinearPresent == GSPostBilinearMode::BilinearSharp)
+		{
+			if (!fsr_render_target || fsr_render_target->get_width() != fsr_width || fsr_render_target->get_height() != fsr_height)
+			{
+				auto fsr_info = ImageCreateInfo::render_target(fsr_width, fsr_height, VK_FORMAT_R8G8B8A8_UNORM);
+				fsr_info.initial_layout = VK_IMAGE_LAYOUT_UNDEFINED;
+				fsr_info.usage |= VK_IMAGE_USAGE_SAMPLED_BIT;
+				fsr_info.misc |= IMAGE_MISC_MUTABLE_SRGB_BIT;
+				fsr_render_target = dev.create_image(fsr_info);
+			}
+		}
+	}
+
+	auto cmd = dev.request_command_buffer();
+	if (vsync.image && fsr_render_target)
+		render_fsr(*cmd, vsync.image->get_view());
+	cmd->begin_render_pass(dev.get_swapchain_render_pass(SwapchainRenderPass::ColorOnly));
+	if (vsync.image)
+	{
+		if (fsr_render_target)
+			render_rcas(*cmd, fsr_render_target->get_view(), vp_offset_x, vp_offset_y, vp_width, vp_height);
+		else
+			render_blit(*cmd, vsync.image->get_view(), vp_offset_x, vp_offset_y, vp_width, vp_height);
+	}
+	cmd->end_render_pass();
+	dev.submit(cmd);
+
+	wsi.end_frame();
+	has_wsi_begin_frame = false;
+	// For pacing purposes.
+	has_wsi_begin_frame = wsi.begin_frame();
+	has_presented_in_current_swapchain = true;
+
+	PerformanceMetrics::Update(registers_written, stats.num_render_passes != 0, false);
+}
+
+void GSRendererPGS::Transfer(const u8* mem, u32 size)
+{
+	size *= 16;
+	iface.gif_transfer(3, mem, size);
+	if (dump)
+		dump->Transfer(3, mem, size);
+}
+
+void GSRendererPGS::ReadFIFO(u8 *mem, u32 size)
+{
+	iface.read_transfer_fifo(mem, size);
+	if (dump)
+		dump->ReadFIFO(size);
+}
+
+void GSRendererPGS::GetInternalResolution(int *width, int *height)
+{
+	*width = int(last_internal_width);
+	*height = int(last_internal_height);
+}
+
+bool GSRendererPGS::UpdateWindow()
+{
+	iface.flush();
+
+	std::optional<WindowInfo> window = Host::AcquireRenderWindow(true);
+	if (window.has_value())
+	{
+		window_info = window.value();
+		wsi.deinit_surface_and_swapchain();
+		return wsi.init_surface_swapchain();
+	}
+	else
+		return false;
+}
+
+void GSRendererPGS::ResizeWindow(int width, int height, float /*scale*/)
+{
+	resize = true;
+	window_info.surface_width = width;
+	window_info.surface_height = height;
+	// TODO: No idea what to do about scale.
+}
+
+const WindowInfo &GSRendererPGS::GetWindowInfo() const
+{
+	return window_info;
+}
+
+void GSRendererPGS::SetVSyncMode(GSVSyncMode mode, bool /*allow_present_throttle*/)
+{
+	if (mode == GSVSyncMode::FIFO)
+		wsi.set_present_mode(PresentMode::SyncToVBlank);
+	else if (mode == GSVSyncMode::Mailbox)
+		wsi.set_present_mode(PresentMode::UnlockedNoTearing);
+	else
+		wsi.set_present_mode(PresentMode::UnlockedMaybeTear);
+	// Unknown what allow_present_throttle means.
+}
+
+VkSurfaceKHR GSRendererPGS::create_surface(VkInstance instance, VkPhysicalDevice gpu)
+{
+	if (window_info.type == WindowInfo::Type::Surfaceless)
+	{
+		std::optional<WindowInfo> window = Host::AcquireRenderWindow(true);
+		if (window.has_value())
+			window_info = window.value();
+	}
+
+	if (window_info.type == WindowInfo::Type::Surfaceless)
+		return VK_NULL_HANDLE;
+
+#if defined(X11_API)
+	if (window_info.type == WindowInfo::Type::X11)
+	{
+		VkXlibSurfaceCreateInfoKHR info = { VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR };
+		info.dpy = static_cast<Display *>(window_info.display_connection);
+		info.window = reinterpret_cast<Window>(window_info.window_handle);
+		VkSurfaceKHR surface;
+		if (vkCreateXlibSurfaceKHR(instance, &info, nullptr, &surface) == VK_SUCCESS)
+			return surface;
+	}
+#endif
+#if defined(WAYLAND_API)
+	if (window_info.type == WindowInfo::Type::Wayland)
+	{
+		VkWaylandSurfaceCreateInfoKHR info = { VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR };
+		info.display = static_cast<wl_display *>(window_info.display_connection);
+		info.surface = static_cast<wl_surface *>(window_info.window_handle);
+		VkSurfaceKHR surface;
+		if (vkCreateWaylandSurfaceKHR(instance, &info, nullptr, &surface) == VK_SUCCESS)
+			return surface;
+	}
+#endif
+#if defined(_WIN32)
+	if (window_info.type == WindowInfo::Type::Win32)
+	{
+		VkWin32SurfaceCreateInfoKHR info = { VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR };
+		info.hwnd = static_cast<HWND>(window_info.window_handle);
+		VkSurfaceKHR surface;
+		if (vkCreateWin32SurfaceKHR(instance, &info, nullptr, &surface) == VK_SUCCESS)
+			return surface;
+	}
+#endif
+
+	return VK_NULL_HANDLE;
+}
+
+void GSRendererPGS::destroy_surface(VkInstance instance, VkSurfaceKHR surface)
+{
+	WSIPlatform::destroy_surface(instance, surface);
+}
+
+std::vector<const char *> GSRendererPGS::get_instance_extensions()
+{
+	return {
+		VK_KHR_SURFACE_EXTENSION_NAME,
+#if defined(X11_API)
+		VK_KHR_XLIB_SURFACE_EXTENSION_NAME,
+#endif
+#if defined(WAYLAND_API)
+		VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME,
+#endif
+#if defined(_WIN32)
+		VK_KHR_WIN32_SURFACE_EXTENSION_NAME,
+#endif
+	};
+}
+
+std::vector<const char *> GSRendererPGS::get_device_extensions()
+{
+	return { VK_KHR_SWAPCHAIN_EXTENSION_NAME };
+}
+
+bool GSRendererPGS::alive(WSI &)
+{
+	return true;
+}
+
+uint32_t GSRendererPGS::get_surface_width()
+{
+	return window_info.surface_width;
+}
+
+uint32_t GSRendererPGS::get_surface_height()
+{
+	return window_info.surface_height;
+}
+
+void GSRendererPGS::poll_input()
+{
+	// Dummy, we don't care about input here.
+}
+
+void GSRendererPGS::poll_input_async(Granite::InputTrackerHandler *)
+{
+	// Dummy, we don't care about input here.
+}
+
+void GSRendererPGS::event_swapchain_destroyed()
+{
+	WSIPlatform::event_swapchain_destroyed();
+	has_wsi_begin_frame = false;
+	has_presented_in_current_swapchain = false;
+}
+
+void GSRendererPGS::QueueSnapshot(const std::string &path, u32 gsdump_frames)
+{
+	freezeData fd = {0, nullptr};
+	Freeze(&fd, true);
+	fd.data = new u8[fd.size];
+	Freeze(&fd, false);
+
+	if (GSConfig.GSDumpCompression == GSDumpCompressionMethod::Uncompressed)
+	{
+		dump = GSDumpBase::CreateUncompressedDump(path, VMManager::GetDiscSerial(),
+		                                          VMManager::GetDiscCRC(), 0, 0,
+		                                          nullptr, fd, reinterpret_cast<GSPrivRegSet *>(priv));
+	}
+	else if (GSConfig.GSDumpCompression == GSDumpCompressionMethod::LZMA)
+	{
+		dump = GSDumpBase::CreateXzDump(path, VMManager::GetDiscSerial(),
+		                                VMManager::GetDiscCRC(), 0, 0,
+		                                nullptr, fd, reinterpret_cast<GSPrivRegSet *>(priv));
+	}
+	else
+	{
+		dump = GSDumpBase::CreateZstDump(path, VMManager::GetDiscSerial(),
+		                                 VMManager::GetDiscCRC(), 0, 0,
+		                                 nullptr, fd, reinterpret_cast<GSPrivRegSet *>(priv));
+	}
+
+	dump_frames = gsdump_frames;
+	delete[] fd.data;
+}
+
+const VkApplicationInfo *GSRendererPGS::get_application_info()
+{
+	static const VkApplicationInfo app = { VK_STRUCTURE_TYPE_APPLICATION_INFO, nullptr,
+	                                       "pcsx2", 0, "Granite", 0, VK_API_VERSION_1_3 };
+	return &app;
+}
diff --git a/pcsx2/GS/Renderers/parallel-gs/GSRendererPGS.h b/pcsx2/GS/Renderers/parallel-gs/GSRendererPGS.h
new file mode 100644
index 000000000..8271a37bb
--- /dev/null
+++ b/pcsx2/GS/Renderers/parallel-gs/GSRendererPGS.h
@@ -0,0 +1,86 @@
+// SPDX-FileCopyrightText: 2024 Hans-Kristian Arntzen
+// SPDX-License-Identifier: LGPL-3.0+
+
+#pragma once
+
+#include "../Vulkan/VKLoaderPlatformDefines.h"
+#include "SaveState.h"
+#include "GS/GSDump.h"
+#include "Config.h"
+#include "common/WindowInfo.h"
+#include "gs_interface.hpp"
+#include "device.hpp"
+#include "context.hpp"
+#include "wsi.hpp"
+
+class GSRendererPGS final : private Vulkan::WSIPlatform
+{
+public:
+	explicit GSRendererPGS(u8 *basemem);
+
+	bool Init();
+	bool UpdateWindow();
+	void ResizeWindow(int width, int height, float scale);
+	const WindowInfo &GetWindowInfo() const;
+	void SetVSyncMode(GSVSyncMode mode, bool allow_present_throttle);
+	void Reset(bool hardware_reset);
+
+	void Transfer(const u8 *mem, u32 size);
+
+	void VSync(u32 field, bool registers_written);
+	inline ParallelGS::GSInterface &get_interface() { return iface; };
+	void ReadFIFO(u8 *mem, u32 size);
+
+	void UpdateConfig();
+
+	void GetInternalResolution(int *width, int *height);
+
+	int Freeze(freezeData *data, bool sizeonly);
+	int Defrost(freezeData *data);
+
+	u8 *GetRegsMem();
+
+	void QueueSnapshot(const std::string &path, u32 gsdump_frames);
+
+private:
+	VkSurfaceKHR create_surface(VkInstance instance, VkPhysicalDevice gpu) override;
+	void destroy_surface(VkInstance instance, VkSurfaceKHR surface) override;
+	std::vector<const char *> get_instance_extensions() override;
+	std::vector<const char *> get_device_extensions() override;
+	bool alive(Vulkan::WSI &wsi) override;
+	uint32_t get_surface_width() override;
+	uint32_t get_surface_height() override;
+	void poll_input() override;
+	void poll_input_async(Granite::InputTrackerHandler *) override;
+
+	ParallelGS::PrivRegisterState *priv;
+	Vulkan::WSI wsi;
+	ParallelGS::GSInterface iface;
+	WindowInfo window_info = {};
+	bool has_wsi_begin_frame = false;
+
+	Vulkan::Program *upscale_program = nullptr;
+	Vulkan::Program *sharpen_program = nullptr;
+	Vulkan::Program *blit_program = nullptr;
+	void render_fsr(Vulkan::CommandBuffer &cmd, const Vulkan::ImageView &view);
+	void render_rcas(Vulkan::CommandBuffer &cmd, const Vulkan::ImageView &view,
+	                 float offset_x, float offset_y,
+	                 float width, float height);
+	void render_blit(Vulkan::CommandBuffer &cmd, const Vulkan::ImageView &view,
+	                 float offset_x, float offset_y,
+	                 float width, float height);
+	void event_swapchain_destroyed() override;
+	Vulkan::ImageHandle fsr_render_target;
+
+	ParallelGS::SuperSampling current_super_sampling = ParallelGS::SuperSampling::X1;
+	bool current_ordered_super_sampling = false;
+	bool has_presented_in_current_swapchain = false;
+	uint32_t last_internal_width = 0;
+	uint32_t last_internal_height = 0;
+
+	static int GetSaveStateSize();
+	const VkApplicationInfo* get_application_info() override;
+
+	std::unique_ptr<GSDumpBase> dump;
+	uint32_t dump_frames = 0;
+};
diff --git a/pcsx2/ImGui/ImGuiFullscreen.cpp b/pcsx2/ImGui/ImGuiFullscreen.cpp
index 8d9a8a07e..d20b14963 100644
--- a/pcsx2/ImGui/ImGuiFullscreen.cpp
+++ b/pcsx2/ImGui/ImGuiFullscreen.cpp
@@ -586,6 +586,8 @@ ImGuiFullscreen::FocusResetType ImGuiFullscreen::GetQueuedFocusResetType()
 
 void ImGuiFullscreen::ForceKeyNavEnabled()
 {
+	if (!ImGui::GetCurrentContext())
+		return;
 	ImGuiContext& g = *ImGui::GetCurrentContext();
 	g.ActiveIdSource = (g.ActiveIdSource == ImGuiInputSource_Mouse) ? ImGuiInputSource_Keyboard : g.ActiveIdSource;
 	g.NavInputSource = (g.NavInputSource == ImGuiInputSource_Mouse) ? ImGuiInputSource_Keyboard : g.ActiveIdSource;
diff --git a/pcsx2/Pcsx2Config.cpp b/pcsx2/Pcsx2Config.cpp
index be60b540f..e3f5d2e95 100644
--- a/pcsx2/Pcsx2Config.cpp
+++ b/pcsx2/Pcsx2Config.cpp
@@ -683,6 +683,7 @@ const char* Pcsx2Config::GSOptions::GetRendererName(GSRendererType type)
 		case GSRendererType::VK:    return "Vulkan";
 		case GSRendererType::SW:    return "Software";
 		case GSRendererType::Null:  return "Null";
+		case GSRendererType::ParallelGS: return "paraLLEl";
 		default:                    return "";
 			// clang-format on
 	}
@@ -860,7 +861,10 @@ bool Pcsx2Config::GSOptions::OptionsAreEqual(const GSOptions& right) const
 		OpEqu(Adapter) &&
 
 		OpEqu(HWDumpDirectory) &&
-		OpEqu(SWDumpDirectory));
+		OpEqu(SWDumpDirectory)) &&
+		OpEqu(PGSSuperSampling) &&
+		OpEqu(PGSHighResScanout) &&
+		OpEqu(PGSDisableMipmaps);
 }
 
 bool Pcsx2Config::GSOptions::operator!=(const GSOptions& right) const
@@ -942,6 +946,9 @@ void Pcsx2Config::GSOptions::LoadSave(SettingsWrapper& wrap)
 	SettingsWrapBitBool(HWSpinCPUForReadbacks);
 	SettingsWrapBitBoolEx(GPUPaletteConversion, "paltex");
 	SettingsWrapBitBoolEx(AutoFlushSW, "autoflush_sw");
+	SettingsWrapIntEnumEx(PGSSuperSampling, "pgsSuperSampling");
+	SettingsWrapBitBoolEx(PGSHighResScanout, "pgsHighResScanout");
+	SettingsWrapBitBoolEx(PGSDisableMipmaps, "pgsDisableMipmaps");
 	SettingsWrapBitBoolEx(PreloadFrameWithGSData, "preload_frame_with_gs_data");
 	SettingsWrapBitBoolEx(Mipmap, "mipmap");
 	SettingsWrapBitBoolEx(ManualUserHacks, "UserHacks");
diff --git a/pcsx2/pcsx2.vcxproj b/pcsx2/pcsx2.vcxproj
index 41ff04385..b8816342c 100644
--- a/pcsx2/pcsx2.vcxproj
+++ b/pcsx2/pcsx2.vcxproj
@@ -53,6 +53,15 @@
       <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)3rdparty\d3d12memalloc\include</AdditionalIncludeDirectories>
       <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)3rdparty\lzma\include</AdditionalIncludeDirectories>
       <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)3rdparty\freesurround\include</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)pcsx2\GS\parallel-gs\gs</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)pcsx2\GS\parallel-gs\Granite\vulkan</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)pcsx2\GS\parallel-gs\Granite\util</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)pcsx2\GS\parallel-gs\Granite\math</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)pcsx2\GS\parallel-gs\Granite\filesystem</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)pcsx2\GS\parallel-gs\Granite\application\global</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)pcsx2\GS\parallel-gs\Granite\third_party\volk</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)pcsx2\GS\parallel-gs\Granite\third_party\renderdoc</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)pcsx2\GS\parallel-gs\Granite\third_party\stb\stb</AdditionalIncludeDirectories>
       <AdditionalIncludeDirectories Condition="'$(Platform)'=='x64'">%(AdditionalIncludeDirectories);$(SolutionDir)3rdparty\xbyak</AdditionalIncludeDirectories>
       <AdditionalIncludeDirectories Condition="'$(Platform)'=='x64'">%(AdditionalIncludeDirectories);$(SolutionDir)3rdparty\zydis\include;$(SolutionDir)3rdparty\zydis\dependencies\zycore\include</AdditionalIncludeDirectories>
       <AdditionalIncludeDirectories Condition="'$(Platform)'=='ARM64'">%(AdditionalIncludeDirectories);$(SolutionDir)3rdparty\vixl\include</AdditionalIncludeDirectories>
@@ -61,7 +70,7 @@
       <PrecompiledHeader>Use</PrecompiledHeader>
       <PrecompiledHeaderFile>PrecompiledHeader.h</PrecompiledHeaderFile>
       <ForcedIncludeFiles>PrecompiledHeader.h;%(ForcedIncludeFiles)</ForcedIncludeFiles>
-      <PreprocessorDefinitions>C4_NO_DEBUG_BREAK;ST_NO_EXCEPTION_HANDLING;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <PreprocessorDefinitions>HAVE_PARALLEL_GS;C4_NO_DEBUG_BREAK;ST_NO_EXCEPTION_HANDLING;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <PreprocessorDefinitions Condition="'$(Platform)'!='ARM64'">ENABLE_RAINTEGRATION;ENABLE_OPENGL;ENABLE_VULKAN;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <PreprocessorDefinitions Condition="'$(Platform)'=='x64'">XBYAK_NO_EXCEPTION;ZYCORE_STATIC_DEFINE;ZYDIS_STATIC_DEFINE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <PreprocessorDefinitions Condition="'$(Platform)'=='ARM64'">VIXL_INCLUDE_TARGET_AARCH64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
@@ -259,6 +268,47 @@
     <ClCompile Include="Gif_Logger.cpp" />
     <ClCompile Include="Gif_Unit.cpp" />
     <ClCompile Include="GSDumpReplayer.cpp" />
+    <ClCompile Include="GS\Renderers\parallel-gs\GSRendererPGS.cpp" />
+    <ClCompile Include="GS\parallel-gs\gs\gs_interface.cpp" />
+    <ClCompile Include="GS\parallel-gs\gs\gs_renderer.cpp" />
+    <ClCompile Include="GS\parallel-gs\gs\gs_util.cpp" />
+    <ClCompile Include="GS\parallel-gs\gs\page_tracker.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\buffer.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\buffer_pool.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\command_buffer.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\command_pool.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\context.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\cookie.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\descriptor_set.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\device.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\event_manager.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\fence.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\fence_manager.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\image.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\indirect_layout.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\memory_allocator.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\pipeline_event.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\query_pool.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\render_pass.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\renderdoc_capture.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\sampler.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\semaphore.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\semaphore_manager.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\shader.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\wsi.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\pipeline_cache.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\texture\memory_mapped_texture.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\texture\texture_files.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\texture\texture_format.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\util\aligned_alloc.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\util\arena_allocator.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\util\logging.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\util\timer.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\util\environment.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\util\timeline_trace_file.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\util\thread_id.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\util\thread_name.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\util\thread_priority.cpp" />
     <ClCompile Include="GS\Renderers\DX11\D3D.cpp" />
     <ClCompile Include="GS\Renderers\DX12\GSDevice12.cpp" />
     <ClCompile Include="GS\Renderers\DX12\GSTexture12.cpp" />
-- 
2.47.1

