From 20526aa68d52a8c9d95d8a7bf996df965fcfad0a Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Sun, 23 Jun 2024 14:54:43 +0200
Subject: [PATCH] Early integration of parallel-GS.

---
 .gitignore                                    |    2 +
 .../vk_video/vulkan_video_codec_av1std.h      |    4 +-
 .../vulkan_video_codec_av1std_encode.h        |  143 +
 3rdparty/vulkan/include/vulkan/vulkan_core.h  | 2416 +++++++++++------
 CMakeLists.txt                                |    8 +
 pcsx2-gsrunner/Main.cpp                       |    4 +
 pcsx2-qt/MainWindow.cpp                       |    3 +
 pcsx2-qt/Settings/GraphicsSettingsWidget.cpp  |   78 +-
 pcsx2-qt/Settings/GraphicsSettingsWidget.ui   |  100 +
 pcsx2-qt/pcsx2-qt.vcxproj                     |    2 +-
 pcsx2/CMakeLists.txt                          |   18 +
 pcsx2/Config.h                                |    8 +
 pcsx2/GS/GS.cpp                               |  379 ++-
 pcsx2/GS/GS.h                                 |    3 +
 pcsx2/GS/GSState.cpp                          |    2 +-
 pcsx2/GS/GSState.h                            |    2 +-
 pcsx2/GS/GSUtil.cpp                           |    4 +-
 pcsx2/GS/Renderers/Common/GSRenderer.cpp      |    2 +-
 pcsx2/GS/Renderers/Vulkan/VKLoader.cpp        |   18 +-
 pcsx2/GS/Renderers/Vulkan/VKLoader.h          |   19 +-
 .../Vulkan/VKLoaderPlatformDefines.h          |   23 +
 .../Renderers/parallel-gs/GSRendererPGS.cpp   |  845 ++++++
 .../GS/Renderers/parallel-gs/GSRendererPGS.h  |   88 +
 pcsx2/ImGui/ImGuiFullscreen.cpp               |    2 +
 pcsx2/Pcsx2Config.cpp                         |   17 +-
 pcsx2/pcsx2.vcxproj                           |   52 +-
 26 files changed, 3370 insertions(+), 872 deletions(-)
 create mode 100644 3rdparty/vulkan/include/vk_video/vulkan_video_codec_av1std_encode.h
 create mode 100644 pcsx2/GS/Renderers/Vulkan/VKLoaderPlatformDefines.h
 create mode 100644 pcsx2/GS/Renderers/parallel-gs/GSRendererPGS.cpp
 create mode 100644 pcsx2/GS/Renderers/parallel-gs/GSRendererPGS.h

diff --git a/.gitignore b/.gitignore
index b59e873da..aac77d348 100644
--- a/.gitignore
+++ b/.gitignore
@@ -120,3 +120,5 @@ CMakeSettings.json
 /ci-artifacts/
 /out/
 /.cache/
+
+/pcsx2/GS/parallel-gs
diff --git a/3rdparty/vulkan/include/vk_video/vulkan_video_codec_av1std.h b/3rdparty/vulkan/include/vk_video/vulkan_video_codec_av1std.h
index 8ce283e8a..4fdced78e 100644
--- a/3rdparty/vulkan/include/vk_video/vulkan_video_codec_av1std.h
+++ b/3rdparty/vulkan/include/vk_video/vulkan_video_codec_av1std.h
@@ -132,7 +132,7 @@ typedef enum StdVideoAV1FrameRestorationType {
 
 typedef enum StdVideoAV1ColorPrimaries {
     STD_VIDEO_AV1_COLOR_PRIMARIES_BT_709 = 1,
-    STD_VIDEO_AV1_COLOR_PRIMARIES_BT_UNSPECIFIED = 2,
+    STD_VIDEO_AV1_COLOR_PRIMARIES_UNSPECIFIED = 2,
     STD_VIDEO_AV1_COLOR_PRIMARIES_BT_470_M = 4,
     STD_VIDEO_AV1_COLOR_PRIMARIES_BT_470_B_G = 5,
     STD_VIDEO_AV1_COLOR_PRIMARIES_BT_601 = 6,
@@ -144,6 +144,8 @@ typedef enum StdVideoAV1ColorPrimaries {
     STD_VIDEO_AV1_COLOR_PRIMARIES_SMPTE_432 = 12,
     STD_VIDEO_AV1_COLOR_PRIMARIES_EBU_3213 = 22,
     STD_VIDEO_AV1_COLOR_PRIMARIES_INVALID = 0x7FFFFFFF,
+  // STD_VIDEO_AV1_COLOR_PRIMARIES_BT_UNSPECIFIED is a deprecated alias
+    STD_VIDEO_AV1_COLOR_PRIMARIES_BT_UNSPECIFIED = STD_VIDEO_AV1_COLOR_PRIMARIES_UNSPECIFIED,
     STD_VIDEO_AV1_COLOR_PRIMARIES_MAX_ENUM = 0x7FFFFFFF
 } StdVideoAV1ColorPrimaries;
 
diff --git a/3rdparty/vulkan/include/vk_video/vulkan_video_codec_av1std_encode.h b/3rdparty/vulkan/include/vk_video/vulkan_video_codec_av1std_encode.h
new file mode 100644
index 000000000..87fc093b5
--- /dev/null
+++ b/3rdparty/vulkan/include/vk_video/vulkan_video_codec_av1std_encode.h
@@ -0,0 +1,143 @@
+#ifndef VULKAN_VIDEO_CODEC_AV1STD_ENCODE_H_
+#define VULKAN_VIDEO_CODEC_AV1STD_ENCODE_H_ 1
+
+/*
+** Copyright 2015-2024 The Khronos Group Inc.
+**
+** SPDX-License-Identifier: Apache-2.0
+*/
+
+/*
+** This header is generated from the Khronos Vulkan XML API Registry.
+**
+*/
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+
+// vulkan_video_codec_av1std_encode is a preprocessor guard. Do not pass it to API calls.
+#define vulkan_video_codec_av1std_encode 1
+#include "vulkan_video_codec_av1std.h"
+
+#define VK_STD_VULKAN_VIDEO_CODEC_AV1_ENCODE_API_VERSION_1_0_0 VK_MAKE_VIDEO_STD_VERSION(1, 0, 0)
+
+#define VK_STD_VULKAN_VIDEO_CODEC_AV1_ENCODE_SPEC_VERSION VK_STD_VULKAN_VIDEO_CODEC_AV1_ENCODE_API_VERSION_1_0_0
+#define VK_STD_VULKAN_VIDEO_CODEC_AV1_ENCODE_EXTENSION_NAME "VK_STD_vulkan_video_codec_av1_encode"
+typedef struct StdVideoEncodeAV1DecoderModelInfo {
+    uint8_t     buffer_delay_length_minus_1;
+    uint8_t     buffer_removal_time_length_minus_1;
+    uint8_t     frame_presentation_time_length_minus_1;
+    uint8_t     reserved1;
+    uint32_t    num_units_in_decoding_tick;
+} StdVideoEncodeAV1DecoderModelInfo;
+
+typedef struct StdVideoEncodeAV1ExtensionHeader {
+    uint8_t    temporal_id;
+    uint8_t    spatial_id;
+} StdVideoEncodeAV1ExtensionHeader;
+
+typedef struct StdVideoEncodeAV1OperatingPointInfoFlags {
+    uint32_t    decoder_model_present_for_this_op : 1;
+    uint32_t    low_delay_mode_flag : 1;
+    uint32_t    initial_display_delay_present_for_this_op : 1;
+    uint32_t    reserved : 29;
+} StdVideoEncodeAV1OperatingPointInfoFlags;
+
+typedef struct StdVideoEncodeAV1OperatingPointInfo {
+    StdVideoEncodeAV1OperatingPointInfoFlags    flags;
+    uint16_t                                    operating_point_idc;
+    uint8_t                                     seq_level_idx;
+    uint8_t                                     seq_tier;
+    uint32_t                                    decoder_buffer_delay;
+    uint32_t                                    encoder_buffer_delay;
+    uint8_t                                     initial_display_delay_minus_1;
+} StdVideoEncodeAV1OperatingPointInfo;
+
+typedef struct StdVideoEncodeAV1PictureInfoFlags {
+    uint32_t    error_resilient_mode : 1;
+    uint32_t    disable_cdf_update : 1;
+    uint32_t    use_superres : 1;
+    uint32_t    render_and_frame_size_different : 1;
+    uint32_t    allow_screen_content_tools : 1;
+    uint32_t    is_filter_switchable : 1;
+    uint32_t    force_integer_mv : 1;
+    uint32_t    frame_size_override_flag : 1;
+    uint32_t    buffer_removal_time_present_flag : 1;
+    uint32_t    allow_intrabc : 1;
+    uint32_t    frame_refs_short_signaling : 1;
+    uint32_t    allow_high_precision_mv : 1;
+    uint32_t    is_motion_mode_switchable : 1;
+    uint32_t    use_ref_frame_mvs : 1;
+    uint32_t    disable_frame_end_update_cdf : 1;
+    uint32_t    allow_warped_motion : 1;
+    uint32_t    reduced_tx_set : 1;
+    uint32_t    skip_mode_present : 1;
+    uint32_t    delta_q_present : 1;
+    uint32_t    delta_lf_present : 1;
+    uint32_t    delta_lf_multi : 1;
+    uint32_t    segmentation_enabled : 1;
+    uint32_t    segmentation_update_map : 1;
+    uint32_t    segmentation_temporal_update : 1;
+    uint32_t    segmentation_update_data : 1;
+    uint32_t    UsesLr : 1;
+    uint32_t    usesChromaLr : 1;
+    uint32_t    show_frame : 1;
+    uint32_t    showable_frame : 1;
+    uint32_t    reserved : 3;
+} StdVideoEncodeAV1PictureInfoFlags;
+
+typedef struct StdVideoEncodeAV1PictureInfo {
+    StdVideoEncodeAV1PictureInfoFlags          flags;
+    StdVideoAV1FrameType                       frame_type;
+    uint32_t                                   frame_presentation_time;
+    uint32_t                                   current_frame_id;
+    uint8_t                                    order_hint;
+    uint8_t                                    primary_ref_frame;
+    uint8_t                                    refresh_frame_flags;
+    uint8_t                                    coded_denom;
+    uint16_t                                   render_width_minus_1;
+    uint16_t                                   render_height_minus_1;
+    StdVideoAV1InterpolationFilter             interpolation_filter;
+    StdVideoAV1TxMode                          TxMode;
+    uint8_t                                    delta_q_res;
+    uint8_t                                    delta_lf_res;
+    uint8_t                                    ref_order_hint[STD_VIDEO_AV1_NUM_REF_FRAMES];
+    int8_t                                     ref_frame_idx[STD_VIDEO_AV1_REFS_PER_FRAME];
+    uint8_t                                    reserved1[3];
+    uint32_t                                   delta_frame_id_minus_1[STD_VIDEO_AV1_REFS_PER_FRAME];
+    const StdVideoAV1TileInfo*                 pTileInfo;
+    const StdVideoAV1Quantization*             pQuantization;
+    const StdVideoAV1Segmentation*             pSegmentation;
+    const StdVideoAV1LoopFilter*               pLoopFilter;
+    const StdVideoAV1CDEF*                     pCDEF;
+    const StdVideoAV1LoopRestoration*          pLoopRestoration;
+    const StdVideoAV1GlobalMotion*             pGlobalMotion;
+    const StdVideoEncodeAV1ExtensionHeader*    pExtensionHeader;
+    const uint32_t*                            pBufferRemovalTimes;
+} StdVideoEncodeAV1PictureInfo;
+
+typedef struct StdVideoEncodeAV1ReferenceInfoFlags {
+    uint32_t    disable_frame_end_update_cdf : 1;
+    uint32_t    segmentation_enabled : 1;
+    uint32_t    reserved : 30;
+} StdVideoEncodeAV1ReferenceInfoFlags;
+
+typedef struct StdVideoEncodeAV1ReferenceInfo {
+    StdVideoEncodeAV1ReferenceInfoFlags        flags;
+    uint32_t                                   RefFrameId;
+    StdVideoAV1FrameType                       frame_type;
+    uint8_t                                    OrderHint;
+    uint8_t                                    reserved1[3];
+    const StdVideoEncodeAV1ExtensionHeader*    pExtensionHeader;
+} StdVideoEncodeAV1ReferenceInfo;
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/3rdparty/vulkan/include/vulkan/vulkan_core.h b/3rdparty/vulkan/include/vulkan/vulkan_core.h
index e6c16498a..4e716da03 100644
--- a/3rdparty/vulkan/include/vulkan/vulkan_core.h
+++ b/3rdparty/vulkan/include/vulkan/vulkan_core.h
@@ -69,10 +69,10 @@ extern "C" {
 #define VK_API_VERSION_1_0 VK_MAKE_API_VERSION(0, 1, 0, 0)// Patch version should always be set to 0
 
 // Version of this file
-#define VK_HEADER_VERSION 296
+#define VK_HEADER_VERSION 303
 
 // Complete version of this file
-#define VK_HEADER_VERSION_COMPLETE VK_MAKE_API_VERSION(0, 1, 3, VK_HEADER_VERSION)
+#define VK_HEADER_VERSION_COMPLETE VK_MAKE_API_VERSION(0, 1, 4, VK_HEADER_VERSION)
 
 // VK_MAKE_VERSION is deprecated, but no reason was given in the API XML
 // DEPRECATED: This define is deprecated. VK_MAKE_API_VERSION should be used instead.
@@ -166,6 +166,7 @@ typedef enum VkResult {
     VK_ERROR_FRAGMENTATION = -1000161000,
     VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS = -1000257000,
     VK_PIPELINE_COMPILE_REQUIRED = 1000297000,
+    VK_ERROR_NOT_PERMITTED = -1000174001,
     VK_ERROR_SURFACE_LOST_KHR = -1000000000,
     VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
     VK_SUBOPTIMAL_KHR = 1000001003,
@@ -180,7 +181,6 @@ typedef enum VkResult {
     VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR = -1000023004,
     VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR = -1000023005,
     VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT = -1000158000,
-    VK_ERROR_NOT_PERMITTED_KHR = -1000174001,
     VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT = -1000255000,
     VK_THREAD_IDLE_KHR = 1000268000,
     VK_THREAD_DONE_KHR = 1000268001,
@@ -194,7 +194,8 @@ typedef enum VkResult {
     VK_ERROR_OUT_OF_POOL_MEMORY_KHR = VK_ERROR_OUT_OF_POOL_MEMORY,
     VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR = VK_ERROR_INVALID_EXTERNAL_HANDLE,
     VK_ERROR_FRAGMENTATION_EXT = VK_ERROR_FRAGMENTATION,
-    VK_ERROR_NOT_PERMITTED_EXT = VK_ERROR_NOT_PERMITTED_KHR,
+    VK_ERROR_NOT_PERMITTED_EXT = VK_ERROR_NOT_PERMITTED,
+    VK_ERROR_NOT_PERMITTED_KHR = VK_ERROR_NOT_PERMITTED,
     VK_ERROR_INVALID_DEVICE_ADDRESS_EXT = VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS,
     VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR = VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS,
     VK_PIPELINE_COMPILE_REQUIRED_EXT = VK_PIPELINE_COMPILE_REQUIRED,
@@ -421,6 +422,56 @@ typedef enum VkStructureType {
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES = 1000413001,
     VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS = 1000413002,
     VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS = 1000413003,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES = 55,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES = 56,
+    VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO = 1000174000,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES = 1000388000,
+    VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES = 1000388001,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES = 1000416000,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES = 1000528000,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES = 1000544000,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES = 1000259000,
+    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO = 1000259001,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES = 1000259002,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES = 1000525000,
+    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO = 1000190001,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES = 1000190002,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES = 1000265000,
+    VK_STRUCTURE_TYPE_MEMORY_MAP_INFO = 1000271000,
+    VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO = 1000271001,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES = 1000470000,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES = 1000470001,
+    VK_STRUCTURE_TYPE_RENDERING_AREA_INFO = 1000470003,
+    VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO = 1000470004,
+    VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2 = 1000338002,
+    VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2 = 1000338003,
+    VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO = 1000470005,
+    VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO = 1000470006,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES = 1000080000,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES = 1000232000,
+    VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO = 1000232001,
+    VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO = 1000232002,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES = 1000545000,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES = 1000545001,
+    VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS = 1000545002,
+    VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO = 1000545003,
+    VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO = 1000545004,
+    VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO = 1000545005,
+    VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO = 1000545006,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES = 1000466000,
+    VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO = 1000068000,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES = 1000068001,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES = 1000068002,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES = 1000270000,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES = 1000270001,
+    VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY = 1000270002,
+    VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY = 1000270003,
+    VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO = 1000270004,
+    VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO = 1000270005,
+    VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO = 1000270006,
+    VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO = 1000270007,
+    VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE = 1000270008,
+    VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY = 1000270009,
     VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
     VK_STRUCTURE_TYPE_PRESENT_INFO_KHR = 1000001001,
     VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR = 1000060007,
@@ -471,6 +522,7 @@ typedef enum VkStructureType {
     VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX = 1000029000,
     VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX = 1000029001,
     VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX = 1000029002,
+    VK_STRUCTURE_TYPE_CU_MODULE_TEXTURING_MODE_CREATE_INFO_NVX = 1000029004,
     VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX = 1000030000,
     VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX = 1000030001,
     VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR = 1000038000,
@@ -508,10 +560,6 @@ typedef enum VkStructureType {
     VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR = 1000040005,
     VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR = 1000040006,
     VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD = 1000041000,
-    VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 1000044006,
-    VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT = 1000044007,
-    VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD = 1000044008,
-    VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX = 1000044009,
     VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP = 1000049000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV = 1000050000,
     VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = 1000056000,
@@ -523,9 +571,6 @@ typedef enum VkStructureType {
     VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN = 1000062000,
     VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT = 1000067000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT = 1000067001,
-    VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT = 1000068000,
-    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT = 1000068001,
-    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT = 1000068002,
     VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073000,
     VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073001,
     VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR = 1000073002,
@@ -540,7 +585,6 @@ typedef enum VkStructureType {
     VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR = 1000078003,
     VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR = 1000079000,
     VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR = 1000079001,
-    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR = 1000080000,
     VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT = 1000081000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT = 1000081001,
     VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT = 1000081002,
@@ -553,6 +597,7 @@ typedef enum VkStructureType {
     VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT = 1000091003,
     VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE = 1000092000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX = 1000097000,
+    VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX = 1000044009,
     VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV = 1000098000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT = 1000099000,
     VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT = 1000099001,
@@ -612,6 +657,7 @@ typedef enum VkStructureType {
 #ifdef VK_ENABLE_BETA_EXTENSIONS
     VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX = 1000134004,
 #endif
+    VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD = 1000044008,
     VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT = 1000143000,
     VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT = 1000143001,
     VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT = 1000143002,
@@ -690,9 +736,6 @@ typedef enum VkStructureType {
     VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR = 1000187003,
     VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR = 1000187004,
     VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR = 1000187005,
-    VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR = 1000174000,
-    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR = 1000388000,
-    VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR = 1000388001,
     VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD = 1000189000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT = 1000190000,
     VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP = 1000191000,
@@ -703,6 +746,8 @@ typedef enum VkStructureType {
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV = 1000205002,
     VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV = 1000206000,
     VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV = 1000206001,
+    VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV = 1000314008,
+    VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV = 1000314009,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL = 1000209000,
     VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL = 1000210000,
     VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL = 1000210001,
@@ -718,16 +763,15 @@ typedef enum VkStructureType {
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT = 1000218000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT = 1000218001,
     VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT = 1000218002,
+    VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT = 1000044007,
     VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 1000226000,
     VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR = 1000226001,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR = 1000226002,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR = 1000226003,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR = 1000226004,
+    VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 1000044006,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD = 1000227000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD = 1000229000,
-    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES_KHR = 1000232000,
-    VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO_KHR = 1000232001,
-    VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO_KHR = 1000232002,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT = 1000234000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR = 1000235000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT = 1000237000,
@@ -762,18 +806,6 @@ typedef enum VkStructureType {
     VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR = 1000269003,
     VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR = 1000269004,
     VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR = 1000269005,
-    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT = 1000270000,
-    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT = 1000270001,
-    VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY_EXT = 1000270002,
-    VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY_EXT = 1000270003,
-    VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO_EXT = 1000270004,
-    VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO_EXT = 1000270005,
-    VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT = 1000270006,
-    VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO_EXT = 1000270007,
-    VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT = 1000270008,
-    VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT = 1000270009,
-    VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR = 1000271000,
-    VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR = 1000271001,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT = 1000272000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT = 1000272001,
     VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT = 1000272002,
@@ -848,8 +880,6 @@ typedef enum VkStructureType {
     VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT = 1000311009,
     VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT = 1000311010,
     VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT = 1000311011,
-    VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV = 1000314008,
-    VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV = 1000314009,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT = 1000316000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT = 1000316001,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT = 1000316002,
@@ -902,6 +932,7 @@ typedef enum VkStructureType {
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT = 1000355000,
     VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT = 1000355001,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT = 1000356000,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_EXT = 1000361000,
     VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA = 1000364000,
     VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA = 1000364001,
     VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA = 1000364002,
@@ -969,7 +1000,6 @@ typedef enum VkStructureType {
     VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT = 1000411001,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT = 1000412000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM = 1000415000,
-    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES_KHR = 1000416000,
     VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM = 1000417000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM = 1000417001,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM = 1000417002,
@@ -1025,18 +1055,9 @@ typedef enum VkStructureType {
     VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV = 1000464005,
     VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV = 1000464010,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT = 1000465000,
-    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT = 1000466000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID = 1000468000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID = 1000468001,
     VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID = 1000468002,
-    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR = 1000470000,
-    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR = 1000470001,
-    VK_STRUCTURE_TYPE_RENDERING_AREA_INFO_KHR = 1000470003,
-    VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO_KHR = 1000470004,
-    VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR = 1000338002,
-    VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR = 1000338003,
-    VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR = 1000470005,
-    VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR = 1000470006,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD = 1000476000,
     VK_STRUCTURE_TYPE_ANTI_LAG_DATA_AMD = 1000476001,
     VK_STRUCTURE_TYPE_ANTI_LAG_PRESENTATION_INFO_AMD = 1000476002,
@@ -1093,6 +1114,17 @@ typedef enum VkStructureType {
     VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR = 1000512003,
     VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000512004,
     VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR = 1000512005,
+    VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR = 1000513000,
+    VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000513001,
+    VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR = 1000513002,
+    VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR = 1000513003,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR = 1000513004,
+    VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR = 1000513005,
+    VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR = 1000513006,
+    VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR = 1000513007,
+    VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR = 1000513008,
+    VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR = 1000513009,
+    VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR = 1000513010,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR = 1000515000,
     VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR = 1000515001,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV = 1000516000,
@@ -1106,32 +1138,28 @@ typedef enum VkStructureType {
     VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM = 1000520001,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM = 1000521000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT = 1000524000,
-    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_KHR = 1000525000,
-    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_KHR = 1000190001,
-    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_KHR = 1000190002,
-    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES_KHR = 1000528000,
     VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX = 1000529000,
     VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX = 1000529001,
     VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX = 1000529002,
     VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX = 1000529003,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX = 1000529004,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT = 1000530000,
-    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_KHR = 1000265000,
-    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR = 1000259000,
-    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR = 1000259001,
-    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR = 1000259002,
     VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR = 1000184000,
-    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES_KHR = 1000544000,
-    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES_KHR = 1000545000,
-    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES_KHR = 1000545001,
-    VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS_KHR = 1000545002,
-    VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO_KHR = 1000545003,
-    VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO_KHR = 1000545004,
-    VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO_KHR = 1000545005,
-    VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO_KHR = 1000545006,
     VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT = 1000545007,
     VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT = 1000545008,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV = 1000546000,
+    VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV = 1000551000,
+    VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV = 1000551001,
+    VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR = 1000553000,
+    VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR = 1000553001,
+    VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR = 1000553002,
+    VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000553005,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR = 1000553009,
+    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR = 1000553003,
+    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR = 1000553004,
+    VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR = 1000553006,
+    VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR = 1000553007,
+    VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR = 1000553008,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV = 1000555000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR = 1000558000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV = 1000559000,
@@ -1162,6 +1190,12 @@ typedef enum VkStructureType {
     VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA = 1000575002,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT = 1000582000,
     VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT = 1000582001,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI = 1000590000,
+    VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI = 1000590001,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV = 1000593000,
+    VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV = 1000593001,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV = 1000593002,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT = 1000608000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES,
   // VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT is a deprecated alias
@@ -1171,7 +1205,6 @@ typedef enum VkStructureType {
     VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES,
     VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO,
-    VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_NV = VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD,
     VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES,
@@ -1192,6 +1225,9 @@ typedef enum VkStructureType {
     VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO,
     VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES,
+    VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES,
     VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO,
@@ -1205,6 +1241,7 @@ typedef enum VkStructureType {
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO,
     VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES,
     VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES,
@@ -1245,6 +1282,7 @@ typedef enum VkStructureType {
     VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
     VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR = VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2,
     VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
+    VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_NV = VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD,
     VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO,
     VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO,
     VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO,
@@ -1260,13 +1298,16 @@ typedef enum VkStructureType {
     VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES,
     VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT,
-    VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR,
+    VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES,
     VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT = VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR,
-    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_KHR,
-    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_KHR,
+    VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES,
+    VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR = VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES,
+    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES,
     VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES,
@@ -1288,6 +1329,9 @@ typedef enum VkStructureType {
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES,
     VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES,
+    VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO_KHR = VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO,
+    VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO_KHR = VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES,
     VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR = VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT,
     VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT,
@@ -1301,11 +1345,23 @@ typedef enum VkStructureType {
     VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO,
     VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR = VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO,
     VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO,
-    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR,
-    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR,
-    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES,
+    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES,
-    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_KHR,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES,
+    VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY_EXT = VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY,
+    VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY_EXT = VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY,
+    VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO_EXT = VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO,
+    VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO_EXT = VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO,
+    VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT = VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO,
+    VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO_EXT = VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO,
+    VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT = VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE,
+    VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT = VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY,
+    VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR = VK_STRUCTURE_TYPE_MEMORY_MAP_INFO,
+    VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR = VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES,
@@ -1335,20 +1391,46 @@ typedef enum VkStructureType {
     VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR = VK_STRUCTURE_TYPE_IMAGE_BLIT_2,
     VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR = VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2,
     VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR = VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2,
-    VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_EXT = VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR,
-    VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_EXT = VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR,
+    VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_EXT = VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2,
+    VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_EXT = VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_ARM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT,
     VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE = VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT,
     VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3,
     VK_STRUCTURE_TYPE_PIPELINE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR,
-    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR,
-    VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT = VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES,
+    VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT = VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES,
     VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR = VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS,
     VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR = VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES,
+    VK_STRUCTURE_TYPE_RENDERING_AREA_INFO_KHR = VK_STRUCTURE_TYPE_RENDERING_AREA_INFO,
+    VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO,
+    VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR = VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2,
+    VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR = VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2,
+    VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO,
+    VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO,
     VK_STRUCTURE_TYPE_SHADER_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES,
+    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES,
+    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES,
+    VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS_KHR = VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS,
+    VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO_KHR = VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO,
+    VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO_KHR = VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO,
+    VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO_KHR = VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO,
+    VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO_KHR = VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO,
     VK_STRUCTURE_TYPE_MAX_ENUM = 0x7FFFFFFF
 } VkStructureType;
 
@@ -1375,6 +1457,7 @@ typedef enum VkImageLayout {
     VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL = 1000241003,
     VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL = 1000314000,
     VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL = 1000314001,
+    VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ = 1000232000,
     VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002,
     VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR = 1000024000,
     VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR = 1000024001,
@@ -1382,14 +1465,15 @@ typedef enum VkImageLayout {
     VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR = 1000111000,
     VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT = 1000218000,
     VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR = 1000164003,
-    VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR = 1000232000,
     VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR = 1000299000,
     VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR = 1000299001,
     VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR = 1000299002,
     VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT = 1000339000,
+    VK_IMAGE_LAYOUT_VIDEO_ENCODE_QUANTIZATION_MAP_KHR = 1000553000,
     VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL,
     VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL,
     VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV = VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR,
+    VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR = VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ,
     VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL,
     VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL,
     VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL,
@@ -1726,6 +1810,8 @@ typedef enum VkFormat {
     VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK = 1000066011,
     VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK = 1000066012,
     VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK = 1000066013,
+    VK_FORMAT_A1B5G5R5_UNORM_PACK16 = 1000470000,
+    VK_FORMAT_A8_UNORM = 1000470001,
     VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000,
     VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001,
     VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002,
@@ -1735,8 +1821,6 @@ typedef enum VkFormat {
     VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006,
     VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007,
     VK_FORMAT_R16G16_SFIXED5_NV = 1000464000,
-    VK_FORMAT_A1B5G5R5_UNORM_PACK16_KHR = 1000470000,
-    VK_FORMAT_A8_UNORM_KHR = 1000470001,
     VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK,
     VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK,
     VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK,
@@ -1793,6 +1877,8 @@ typedef enum VkFormat {
     VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT = VK_FORMAT_A4B4G4R4_UNORM_PACK16,
   // VK_FORMAT_R16G16_S10_5_NV is a deprecated alias
     VK_FORMAT_R16G16_S10_5_NV = VK_FORMAT_R16G16_SFIXED5_NV,
+    VK_FORMAT_A1B5G5R5_UNORM_PACK16_KHR = VK_FORMAT_A1B5G5R5_UNORM_PACK16,
+    VK_FORMAT_A8_UNORM_KHR = VK_FORMAT_A8_UNORM,
     VK_FORMAT_MAX_ENUM = 0x7FFFFFFF
 } VkFormat;
 
@@ -1983,6 +2069,7 @@ typedef enum VkDynamicState {
     VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE = 1000377001,
     VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE = 1000377002,
     VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE = 1000377004,
+    VK_DYNAMIC_STATE_LINE_STIPPLE = 1000259000,
     VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV = 1000087000,
     VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT = 1000099000,
     VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT = 1000099001,
@@ -2030,9 +2117,8 @@ typedef enum VkDynamicState {
     VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV = 1000455031,
     VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV = 1000455032,
     VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT = 1000524000,
-    VK_DYNAMIC_STATE_LINE_STIPPLE_KHR = 1000259000,
     VK_DYNAMIC_STATE_DEPTH_CLAMP_RANGE_EXT = 1000582000,
-    VK_DYNAMIC_STATE_LINE_STIPPLE_EXT = VK_DYNAMIC_STATE_LINE_STIPPLE_KHR,
+    VK_DYNAMIC_STATE_LINE_STIPPLE_EXT = VK_DYNAMIC_STATE_LINE_STIPPLE,
     VK_DYNAMIC_STATE_CULL_MODE_EXT = VK_DYNAMIC_STATE_CULL_MODE,
     VK_DYNAMIC_STATE_FRONT_FACE_EXT = VK_DYNAMIC_STATE_FRONT_FACE,
     VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT = VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY,
@@ -2048,6 +2134,7 @@ typedef enum VkDynamicState {
     VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT = VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE,
     VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT = VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE,
     VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT = VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE,
+    VK_DYNAMIC_STATE_LINE_STIPPLE_KHR = VK_DYNAMIC_STATE_LINE_STIPPLE,
     VK_DYNAMIC_STATE_MAX_ENUM = 0x7FFFFFFF
 } VkDynamicState;
 
@@ -2182,8 +2269,9 @@ typedef enum VkAttachmentLoadOp {
     VK_ATTACHMENT_LOAD_OP_LOAD = 0,
     VK_ATTACHMENT_LOAD_OP_CLEAR = 1,
     VK_ATTACHMENT_LOAD_OP_DONT_CARE = 2,
-    VK_ATTACHMENT_LOAD_OP_NONE_KHR = 1000400000,
-    VK_ATTACHMENT_LOAD_OP_NONE_EXT = VK_ATTACHMENT_LOAD_OP_NONE_KHR,
+    VK_ATTACHMENT_LOAD_OP_NONE = 1000400000,
+    VK_ATTACHMENT_LOAD_OP_NONE_EXT = VK_ATTACHMENT_LOAD_OP_NONE,
+    VK_ATTACHMENT_LOAD_OP_NONE_KHR = VK_ATTACHMENT_LOAD_OP_NONE,
     VK_ATTACHMENT_LOAD_OP_MAX_ENUM = 0x7FFFFFFF
 } VkAttachmentLoadOp;
 
@@ -2218,10 +2306,11 @@ typedef enum VkCommandBufferLevel {
 typedef enum VkIndexType {
     VK_INDEX_TYPE_UINT16 = 0,
     VK_INDEX_TYPE_UINT32 = 1,
+    VK_INDEX_TYPE_UINT8 = 1000265000,
     VK_INDEX_TYPE_NONE_KHR = 1000165000,
-    VK_INDEX_TYPE_UINT8_KHR = 1000265000,
     VK_INDEX_TYPE_NONE_NV = VK_INDEX_TYPE_NONE_KHR,
-    VK_INDEX_TYPE_UINT8_EXT = VK_INDEX_TYPE_UINT8_KHR,
+    VK_INDEX_TYPE_UINT8_EXT = VK_INDEX_TYPE_UINT8,
+    VK_INDEX_TYPE_UINT8_KHR = VK_INDEX_TYPE_UINT8,
     VK_INDEX_TYPE_MAX_ENUM = 0x7FFFFFFF
 } VkIndexType;
 
@@ -2393,12 +2482,12 @@ typedef enum VkImageUsageFlagBits {
     VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000020,
     VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 0x00000040,
     VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 0x00000080,
+    VK_IMAGE_USAGE_HOST_TRANSFER_BIT = 0x00400000,
     VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR = 0x00000400,
     VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR = 0x00000800,
     VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR = 0x00001000,
     VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT = 0x00000200,
     VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00000100,
-    VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT = 0x00400000,
     VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR = 0x00002000,
     VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR = 0x00004000,
     VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR = 0x00008000,
@@ -2406,7 +2495,10 @@ typedef enum VkImageUsageFlagBits {
     VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI = 0x00040000,
     VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM = 0x00100000,
     VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM = 0x00200000,
+    VK_IMAGE_USAGE_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR = 0x02000000,
+    VK_IMAGE_USAGE_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR = 0x04000000,
     VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV = VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
+    VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT = VK_IMAGE_USAGE_HOST_TRANSFER_BIT,
     VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
 } VkImageUsageFlagBits;
 typedef VkFlags VkImageUsageFlags;
@@ -2646,8 +2738,8 @@ typedef enum VkPipelineCreateFlagBits {
     VK_PIPELINE_CREATE_DISPATCH_BASE_BIT = 0x00000010,
     VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT = 0x00000100,
     VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT = 0x00000200,
-    VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00200000,
-    VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = 0x00400000,
+    VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT = 0x08000000,
+    VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT = 0x40000000,
     VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR = 0x00004000,
     VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR = 0x00008000,
     VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR = 0x00010000,
@@ -2656,6 +2748,8 @@ typedef enum VkPipelineCreateFlagBits {
     VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR = 0x00002000,
     VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR = 0x00080000,
     VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV = 0x00000020,
+    VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = 0x00400000,
+    VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00200000,
     VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR = 0x00000040,
     VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR = 0x00000080,
     VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV = 0x00040000,
@@ -2670,17 +2764,17 @@ typedef enum VkPipelineCreateFlagBits {
 #ifdef VK_ENABLE_BETA_EXTENSIONS
     VK_PIPELINE_CREATE_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV = 0x10000000,
 #endif
-    VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT = 0x08000000,
-    VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT = 0x40000000,
     VK_PIPELINE_CREATE_DISPATCH_BASE = VK_PIPELINE_CREATE_DISPATCH_BASE_BIT,
-  // VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR is a deprecated alias
-    VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
-  // VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT is a deprecated alias
-    VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT,
     VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR = VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT,
     VK_PIPELINE_CREATE_DISPATCH_BASE_KHR = VK_PIPELINE_CREATE_DISPATCH_BASE,
+  // VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT is a deprecated alias
+    VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT,
+  // VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR is a deprecated alias
+    VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
     VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT = VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT,
     VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT = VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT,
+    VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT = VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT,
+    VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT = VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT,
     VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
 } VkPipelineCreateFlagBits;
 typedef VkFlags VkPipelineCreateFlags;
@@ -2788,12 +2882,13 @@ typedef VkFlags VkDescriptorPoolResetFlags;
 
 typedef enum VkDescriptorSetLayoutCreateFlagBits {
     VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT = 0x00000002,
-    VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR = 0x00000001,
+    VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT = 0x00000001,
     VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT = 0x00000010,
     VK_DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT = 0x00000020,
     VK_DESCRIPTOR_SET_LAYOUT_CREATE_INDIRECT_BINDABLE_BIT_NV = 0x00000080,
     VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT = 0x00000004,
     VK_DESCRIPTOR_SET_LAYOUT_CREATE_PER_STAGE_BIT_NV = 0x00000040,
+    VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR = VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT,
     VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT = VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT,
     VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE = VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT,
     VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
@@ -5011,7 +5106,8 @@ typedef enum VkChromaLocation {
 
 typedef enum VkDescriptorUpdateTemplateType {
     VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET = 0,
-    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR = 1,
+    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS = 1,
+    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS,
     VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET,
     VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_MAX_ENUM = 0x7FFFFFFF
 } VkDescriptorUpdateTemplateType;
@@ -5025,9 +5121,11 @@ typedef enum VkSubgroupFeatureFlagBits {
     VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT = 0x00000020,
     VK_SUBGROUP_FEATURE_CLUSTERED_BIT = 0x00000040,
     VK_SUBGROUP_FEATURE_QUAD_BIT = 0x00000080,
+    VK_SUBGROUP_FEATURE_ROTATE_BIT = 0x00000200,
+    VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT = 0x00000400,
     VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV = 0x00000100,
-    VK_SUBGROUP_FEATURE_ROTATE_BIT_KHR = 0x00000200,
-    VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT_KHR = 0x00000400,
+    VK_SUBGROUP_FEATURE_ROTATE_BIT_KHR = VK_SUBGROUP_FEATURE_ROTATE_BIT,
+    VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT_KHR = VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT,
     VK_SUBGROUP_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
 } VkSubgroupFeatureFlagBits;
 typedef VkFlags VkSubgroupFeatureFlags;
@@ -6621,59 +6719,59 @@ typedef VkFlags64 VkPipelineStageFlags2;
 // Flag bits for VkPipelineStageFlagBits2
 typedef VkFlags64 VkPipelineStageFlagBits2;
 static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_NONE = 0ULL;
-static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_NONE_KHR = 0ULL;
 static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT = 0x00000001ULL;
-static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR = 0x00000001ULL;
 static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT = 0x00000002ULL;
-static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR = 0x00000002ULL;
 static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT = 0x00000004ULL;
-static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR = 0x00000004ULL;
 static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT = 0x00000008ULL;
-static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR = 0x00000008ULL;
 static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT = 0x00000010ULL;
-static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR = 0x00000010ULL;
 static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT = 0x00000020ULL;
-static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR = 0x00000020ULL;
 static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT = 0x00000040ULL;
-static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR = 0x00000040ULL;
 static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT = 0x00000080ULL;
-static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR = 0x00000080ULL;
 static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT = 0x00000100ULL;
-static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR = 0x00000100ULL;
 static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT = 0x00000200ULL;
-static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR = 0x00000200ULL;
 static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT = 0x00000400ULL;
-static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR = 0x00000400ULL;
 static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT = 0x00000800ULL;
-static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR = 0x00000800ULL;
 static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT = 0x00001000ULL;
-static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR = 0x00001000ULL;
 static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TRANSFER_BIT = 0x00001000ULL;
-static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TRANSFER_BIT_KHR = 0x00001000ULL;
 static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT = 0x00002000ULL;
-static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR = 0x00002000ULL;
 static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_HOST_BIT = 0x00004000ULL;
-static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_HOST_BIT_KHR = 0x00004000ULL;
 static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT = 0x00008000ULL;
-static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR = 0x00008000ULL;
 static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT = 0x00010000ULL;
-static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR = 0x00010000ULL;
 static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_COPY_BIT = 0x100000000ULL;
-static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_COPY_BIT_KHR = 0x100000000ULL;
 static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_RESOLVE_BIT = 0x200000000ULL;
-static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR = 0x200000000ULL;
 static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_BLIT_BIT = 0x400000000ULL;
-static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_BLIT_BIT_KHR = 0x400000000ULL;
 static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_CLEAR_BIT = 0x800000000ULL;
-static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR = 0x800000000ULL;
 static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT = 0x1000000000ULL;
-static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR = 0x1000000000ULL;
 static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT = 0x2000000000ULL;
-static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR = 0x2000000000ULL;
 static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT = 0x4000000000ULL;
-static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR = 0x4000000000ULL;
 static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR = 0x04000000ULL;
 static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR = 0x08000000ULL;
+static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_NONE_KHR = 0ULL;
+static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR = 0x00000001ULL;
+static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR = 0x00000002ULL;
+static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR = 0x00000004ULL;
+static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR = 0x00000008ULL;
+static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR = 0x00000010ULL;
+static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR = 0x00000020ULL;
+static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR = 0x00000040ULL;
+static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR = 0x00000080ULL;
+static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR = 0x00000100ULL;
+static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR = 0x00000200ULL;
+static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR = 0x00000400ULL;
+static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR = 0x00000800ULL;
+static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR = 0x00001000ULL;
+static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TRANSFER_BIT_KHR = 0x00001000ULL;
+static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR = 0x00002000ULL;
+static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_HOST_BIT_KHR = 0x00004000ULL;
+static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR = 0x00008000ULL;
+static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR = 0x00010000ULL;
+static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_COPY_BIT_KHR = 0x100000000ULL;
+static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR = 0x200000000ULL;
+static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_BLIT_BIT_KHR = 0x400000000ULL;
+static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR = 0x800000000ULL;
+static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR = 0x1000000000ULL;
+static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR = 0x2000000000ULL;
+static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR = 0x4000000000ULL;
 static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT = 0x01000000ULL;
 static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT = 0x00040000ULL;
 static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV = 0x00020000ULL;
@@ -6703,51 +6801,51 @@ typedef VkFlags64 VkAccessFlags2;
 // Flag bits for VkAccessFlagBits2
 typedef VkFlags64 VkAccessFlagBits2;
 static const VkAccessFlagBits2 VK_ACCESS_2_NONE = 0ULL;
-static const VkAccessFlagBits2 VK_ACCESS_2_NONE_KHR = 0ULL;
 static const VkAccessFlagBits2 VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT = 0x00000001ULL;
-static const VkAccessFlagBits2 VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR = 0x00000001ULL;
 static const VkAccessFlagBits2 VK_ACCESS_2_INDEX_READ_BIT = 0x00000002ULL;
-static const VkAccessFlagBits2 VK_ACCESS_2_INDEX_READ_BIT_KHR = 0x00000002ULL;
 static const VkAccessFlagBits2 VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT = 0x00000004ULL;
-static const VkAccessFlagBits2 VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR = 0x00000004ULL;
 static const VkAccessFlagBits2 VK_ACCESS_2_UNIFORM_READ_BIT = 0x00000008ULL;
-static const VkAccessFlagBits2 VK_ACCESS_2_UNIFORM_READ_BIT_KHR = 0x00000008ULL;
 static const VkAccessFlagBits2 VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT = 0x00000010ULL;
-static const VkAccessFlagBits2 VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR = 0x00000010ULL;
 static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_READ_BIT = 0x00000020ULL;
-static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_READ_BIT_KHR = 0x00000020ULL;
 static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_WRITE_BIT = 0x00000040ULL;
-static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_WRITE_BIT_KHR = 0x00000040ULL;
 static const VkAccessFlagBits2 VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT = 0x00000080ULL;
-static const VkAccessFlagBits2 VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR = 0x00000080ULL;
 static const VkAccessFlagBits2 VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT = 0x00000100ULL;
-static const VkAccessFlagBits2 VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR = 0x00000100ULL;
 static const VkAccessFlagBits2 VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 0x00000200ULL;
-static const VkAccessFlagBits2 VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR = 0x00000200ULL;
 static const VkAccessFlagBits2 VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 0x00000400ULL;
-static const VkAccessFlagBits2 VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR = 0x00000400ULL;
 static const VkAccessFlagBits2 VK_ACCESS_2_TRANSFER_READ_BIT = 0x00000800ULL;
-static const VkAccessFlagBits2 VK_ACCESS_2_TRANSFER_READ_BIT_KHR = 0x00000800ULL;
 static const VkAccessFlagBits2 VK_ACCESS_2_TRANSFER_WRITE_BIT = 0x00001000ULL;
-static const VkAccessFlagBits2 VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR = 0x00001000ULL;
 static const VkAccessFlagBits2 VK_ACCESS_2_HOST_READ_BIT = 0x00002000ULL;
-static const VkAccessFlagBits2 VK_ACCESS_2_HOST_READ_BIT_KHR = 0x00002000ULL;
 static const VkAccessFlagBits2 VK_ACCESS_2_HOST_WRITE_BIT = 0x00004000ULL;
-static const VkAccessFlagBits2 VK_ACCESS_2_HOST_WRITE_BIT_KHR = 0x00004000ULL;
 static const VkAccessFlagBits2 VK_ACCESS_2_MEMORY_READ_BIT = 0x00008000ULL;
-static const VkAccessFlagBits2 VK_ACCESS_2_MEMORY_READ_BIT_KHR = 0x00008000ULL;
 static const VkAccessFlagBits2 VK_ACCESS_2_MEMORY_WRITE_BIT = 0x00010000ULL;
-static const VkAccessFlagBits2 VK_ACCESS_2_MEMORY_WRITE_BIT_KHR = 0x00010000ULL;
 static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_SAMPLED_READ_BIT = 0x100000000ULL;
-static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR = 0x100000000ULL;
 static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_STORAGE_READ_BIT = 0x200000000ULL;
-static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_STORAGE_READ_BIT_KHR = 0x200000000ULL;
 static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT = 0x400000000ULL;
-static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR = 0x400000000ULL;
 static const VkAccessFlagBits2 VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR = 0x800000000ULL;
 static const VkAccessFlagBits2 VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR = 0x1000000000ULL;
 static const VkAccessFlagBits2 VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR = 0x2000000000ULL;
 static const VkAccessFlagBits2 VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR = 0x4000000000ULL;
+static const VkAccessFlagBits2 VK_ACCESS_2_NONE_KHR = 0ULL;
+static const VkAccessFlagBits2 VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR = 0x00000001ULL;
+static const VkAccessFlagBits2 VK_ACCESS_2_INDEX_READ_BIT_KHR = 0x00000002ULL;
+static const VkAccessFlagBits2 VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR = 0x00000004ULL;
+static const VkAccessFlagBits2 VK_ACCESS_2_UNIFORM_READ_BIT_KHR = 0x00000008ULL;
+static const VkAccessFlagBits2 VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR = 0x00000010ULL;
+static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_READ_BIT_KHR = 0x00000020ULL;
+static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_WRITE_BIT_KHR = 0x00000040ULL;
+static const VkAccessFlagBits2 VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR = 0x00000080ULL;
+static const VkAccessFlagBits2 VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR = 0x00000100ULL;
+static const VkAccessFlagBits2 VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR = 0x00000200ULL;
+static const VkAccessFlagBits2 VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR = 0x00000400ULL;
+static const VkAccessFlagBits2 VK_ACCESS_2_TRANSFER_READ_BIT_KHR = 0x00000800ULL;
+static const VkAccessFlagBits2 VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR = 0x00001000ULL;
+static const VkAccessFlagBits2 VK_ACCESS_2_HOST_READ_BIT_KHR = 0x00002000ULL;
+static const VkAccessFlagBits2 VK_ACCESS_2_HOST_WRITE_BIT_KHR = 0x00004000ULL;
+static const VkAccessFlagBits2 VK_ACCESS_2_MEMORY_READ_BIT_KHR = 0x00008000ULL;
+static const VkAccessFlagBits2 VK_ACCESS_2_MEMORY_WRITE_BIT_KHR = 0x00010000ULL;
+static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR = 0x100000000ULL;
+static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_STORAGE_READ_BIT_KHR = 0x200000000ULL;
+static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR = 0x400000000ULL;
 static const VkAccessFlagBits2 VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = 0x02000000ULL;
 static const VkAccessFlagBits2 VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = 0x04000000ULL;
 static const VkAccessFlagBits2 VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = 0x08000000ULL;
@@ -6798,59 +6896,33 @@ typedef VkFlags64 VkFormatFeatureFlags2;
 // Flag bits for VkFormatFeatureFlagBits2
 typedef VkFlags64 VkFormatFeatureFlagBits2;
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT = 0x00000001ULL;
-static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT_KHR = 0x00000001ULL;
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT = 0x00000002ULL;
-static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT_KHR = 0x00000002ULL;
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT = 0x00000004ULL;
-static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT_KHR = 0x00000004ULL;
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT = 0x00000008ULL;
-static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR = 0x00000008ULL;
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT = 0x00000010ULL;
-static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT_KHR = 0x00000010ULL;
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 0x00000020ULL;
-static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT_KHR = 0x00000020ULL;
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT = 0x00000040ULL;
-static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT_KHR = 0x00000040ULL;
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT = 0x00000080ULL;
-static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT_KHR = 0x00000080ULL;
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT = 0x00000100ULL;
-static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT_KHR = 0x00000100ULL;
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000200ULL;
-static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT_KHR = 0x00000200ULL;
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_BLIT_SRC_BIT = 0x00000400ULL;
-static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_BLIT_SRC_BIT_KHR = 0x00000400ULL;
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_BLIT_DST_BIT = 0x00000800ULL;
-static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_BLIT_DST_BIT_KHR = 0x00000800ULL;
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 0x00001000ULL;
-static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT_KHR = 0x00001000ULL;
-static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT = 0x00002000ULL;
-static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT = 0x00002000ULL;
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT = 0x00004000ULL;
-static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT_KHR = 0x00004000ULL;
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT = 0x00008000ULL;
-static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT_KHR = 0x00008000ULL;
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT = 0x00010000ULL;
-static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT_KHR = 0x00010000ULL;
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT = 0x00020000ULL;
-static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT_KHR = 0x00020000ULL;
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT = 0x00040000ULL;
-static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR = 0x00040000ULL;
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT = 0x00080000ULL;
-static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR = 0x00080000ULL;
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT = 0x00100000ULL;
-static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR = 0x00100000ULL;
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT = 0x00200000ULL;
-static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR = 0x00200000ULL;
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_DISJOINT_BIT = 0x00400000ULL;
-static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_DISJOINT_BIT_KHR = 0x00400000ULL;
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT = 0x00800000ULL;
-static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT_KHR = 0x00800000ULL;
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT = 0x80000000ULL;
-static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT_KHR = 0x80000000ULL;
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT = 0x100000000ULL;
-static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT_KHR = 0x100000000ULL;
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT = 0x200000000ULL;
-static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT_KHR = 0x200000000ULL;
+static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT = 0x00002000ULL;
+static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_HOST_IMAGE_TRANSFER_BIT = 0x400000000000ULL;
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_VIDEO_DECODE_OUTPUT_BIT_KHR = 0x02000000ULL;
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_VIDEO_DECODE_DPB_BIT_KHR = 0x04000000ULL;
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR = 0x20000000ULL;
@@ -6859,6 +6931,33 @@ static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_FRAGMENT_SHADING_RATE_
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_HOST_IMAGE_TRANSFER_BIT_EXT = 0x400000000000ULL;
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_VIDEO_ENCODE_INPUT_BIT_KHR = 0x08000000ULL;
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_VIDEO_ENCODE_DPB_BIT_KHR = 0x10000000ULL;
+static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT_KHR = 0x00000001ULL;
+static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT_KHR = 0x00000002ULL;
+static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT_KHR = 0x00000004ULL;
+static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR = 0x00000008ULL;
+static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT_KHR = 0x00000010ULL;
+static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT_KHR = 0x00000020ULL;
+static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT_KHR = 0x00000040ULL;
+static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT_KHR = 0x00000080ULL;
+static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT_KHR = 0x00000100ULL;
+static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT_KHR = 0x00000200ULL;
+static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_BLIT_SRC_BIT_KHR = 0x00000400ULL;
+static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_BLIT_DST_BIT_KHR = 0x00000800ULL;
+static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT_KHR = 0x00001000ULL;
+static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT_KHR = 0x00004000ULL;
+static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT_KHR = 0x00008000ULL;
+static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT_KHR = 0x00020000ULL;
+static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR = 0x00040000ULL;
+static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR = 0x00080000ULL;
+static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR = 0x00100000ULL;
+static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR = 0x00200000ULL;
+static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_DISJOINT_BIT_KHR = 0x00400000ULL;
+static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT_KHR = 0x00800000ULL;
+static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT_KHR = 0x80000000ULL;
+static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT_KHR = 0x100000000ULL;
+static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT_KHR = 0x200000000ULL;
+static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT_KHR = 0x00010000ULL;
+static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT = 0x00002000ULL;
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV = 0x4000000000ULL;
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM = 0x400000000ULL;
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM = 0x800000000ULL;
@@ -6867,6 +6966,8 @@ static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_OPTICAL_FLOW_IMAGE_BIT_NV = 0x10000000000ULL;
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_OPTICAL_FLOW_VECTOR_BIT_NV = 0x20000000000ULL;
 static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_OPTICAL_FLOW_COST_BIT_NV = 0x40000000000ULL;
+static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR = 0x2000000000000ULL;
+static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR = 0x4000000000000ULL;
 
 typedef struct VkPhysicalDeviceVulkan13Features {
     VkStructureType    sType;
@@ -7620,55 +7721,781 @@ VKAPI_ATTR void VKAPI_CALL vkGetDeviceImageSparseMemoryRequirements(
 #endif
 
 
-// VK_KHR_surface is a preprocessor guard. Do not pass it to API calls.
-#define VK_KHR_surface 1
-VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSurfaceKHR)
-#define VK_KHR_SURFACE_SPEC_VERSION       25
-#define VK_KHR_SURFACE_EXTENSION_NAME     "VK_KHR_surface"
+// VK_VERSION_1_4 is a preprocessor guard. Do not pass it to API calls.
+#define VK_VERSION_1_4 1
+// Vulkan 1.4 version number
+#define VK_API_VERSION_1_4 VK_MAKE_API_VERSION(0, 1, 4, 0)// Patch version should always be set to 0
+
+#define VK_MAX_GLOBAL_PRIORITY_SIZE       16U
+
+typedef enum VkPipelineRobustnessBufferBehavior {
+    VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT = 0,
+    VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED = 1,
+    VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS = 2,
+    VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2 = 3,
+    VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT = VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT,
+    VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED_EXT = VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED,
+    VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT = VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS,
+    VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT = VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2,
+    VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_MAX_ENUM = 0x7FFFFFFF
+} VkPipelineRobustnessBufferBehavior;
+
+typedef enum VkPipelineRobustnessImageBehavior {
+    VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT = 0,
+    VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED = 1,
+    VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS = 2,
+    VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2 = 3,
+    VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT_EXT = VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT,
+    VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED_EXT = VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED,
+    VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_EXT = VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS,
+    VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2_EXT = VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2,
+    VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_MAX_ENUM = 0x7FFFFFFF
+} VkPipelineRobustnessImageBehavior;
+
+typedef enum VkQueueGlobalPriority {
+    VK_QUEUE_GLOBAL_PRIORITY_LOW = 128,
+    VK_QUEUE_GLOBAL_PRIORITY_MEDIUM = 256,
+    VK_QUEUE_GLOBAL_PRIORITY_HIGH = 512,
+    VK_QUEUE_GLOBAL_PRIORITY_REALTIME = 1024,
+    VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT = VK_QUEUE_GLOBAL_PRIORITY_LOW,
+    VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT = VK_QUEUE_GLOBAL_PRIORITY_MEDIUM,
+    VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT = VK_QUEUE_GLOBAL_PRIORITY_HIGH,
+    VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT = VK_QUEUE_GLOBAL_PRIORITY_REALTIME,
+    VK_QUEUE_GLOBAL_PRIORITY_LOW_KHR = VK_QUEUE_GLOBAL_PRIORITY_LOW,
+    VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_KHR = VK_QUEUE_GLOBAL_PRIORITY_MEDIUM,
+    VK_QUEUE_GLOBAL_PRIORITY_HIGH_KHR = VK_QUEUE_GLOBAL_PRIORITY_HIGH,
+    VK_QUEUE_GLOBAL_PRIORITY_REALTIME_KHR = VK_QUEUE_GLOBAL_PRIORITY_REALTIME,
+    VK_QUEUE_GLOBAL_PRIORITY_MAX_ENUM = 0x7FFFFFFF
+} VkQueueGlobalPriority;
+
+typedef enum VkLineRasterizationMode {
+    VK_LINE_RASTERIZATION_MODE_DEFAULT = 0,
+    VK_LINE_RASTERIZATION_MODE_RECTANGULAR = 1,
+    VK_LINE_RASTERIZATION_MODE_BRESENHAM = 2,
+    VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH = 3,
+    VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT = VK_LINE_RASTERIZATION_MODE_DEFAULT,
+    VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT = VK_LINE_RASTERIZATION_MODE_RECTANGULAR,
+    VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT = VK_LINE_RASTERIZATION_MODE_BRESENHAM,
+    VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT = VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH,
+    VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR = VK_LINE_RASTERIZATION_MODE_DEFAULT,
+    VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR = VK_LINE_RASTERIZATION_MODE_RECTANGULAR,
+    VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR = VK_LINE_RASTERIZATION_MODE_BRESENHAM,
+    VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR = VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH,
+    VK_LINE_RASTERIZATION_MODE_MAX_ENUM = 0x7FFFFFFF
+} VkLineRasterizationMode;
+
+typedef enum VkMemoryUnmapFlagBits {
+    VK_MEMORY_UNMAP_RESERVE_BIT_EXT = 0x00000001,
+    VK_MEMORY_UNMAP_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
+} VkMemoryUnmapFlagBits;
+typedef VkFlags VkMemoryUnmapFlags;
+typedef VkFlags64 VkPipelineCreateFlags2;
+
+// Flag bits for VkPipelineCreateFlagBits2
+typedef VkFlags64 VkPipelineCreateFlagBits2;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT = 0x00000001ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT = 0x00000002ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_DERIVATIVE_BIT = 0x00000004ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT = 0x00000008ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT = 0x00000010ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT = 0x00000100ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT = 0x00000200ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT = 0x08000000ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT = 0x40000000ULL;
+#ifdef VK_ENABLE_BETA_EXTENSIONS
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_EXECUTION_GRAPH_BIT_AMDX = 0x100000000ULL;
+#endif
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT = 0x400000000ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT_KHR = 0x00000001ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT_KHR = 0x00000002ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_DERIVATIVE_BIT_KHR = 0x00000004ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR = 0x00000008ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT_KHR = 0x00000010ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_DEFER_COMPILE_BIT_NV = 0x00000020ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_CAPTURE_STATISTICS_BIT_KHR = 0x00000040ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR = 0x00000080ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_KHR = 0x00000100ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT_KHR = 0x00000200ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_LINK_TIME_OPTIMIZATION_BIT_EXT = 0x00000400ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT = 0x00800000ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_LIBRARY_BIT_KHR = 0x00000800ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR = 0x00001000ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_AABBS_BIT_KHR = 0x00002000ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR = 0x00004000ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR = 0x00008000ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR = 0x00010000ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR = 0x00020000ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR = 0x00080000ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_NV = 0x00040000ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_MOTION_BIT_NV = 0x00100000ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00200000ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = 0x00400000ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT = 0x01000000ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 0x02000000ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 0x04000000ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT_EXT = 0x08000000ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT_EXT = 0x40000000ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV = 0x10000000ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_DESCRIPTOR_BUFFER_BIT_EXT = 0x20000000ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_CAPTURE_DATA_BIT_KHR = 0x80000000ULL;
+static const VkPipelineCreateFlagBits2 VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_EXT = 0x4000000000ULL;
+
+typedef VkFlags64 VkBufferUsageFlags2;
+
+// Flag bits for VkBufferUsageFlagBits2
+typedef VkFlags64 VkBufferUsageFlagBits2;
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_TRANSFER_SRC_BIT = 0x00000001ULL;
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_TRANSFER_DST_BIT = 0x00000002ULL;
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT = 0x00000004ULL;
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT = 0x00000008ULL;
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_UNIFORM_BUFFER_BIT = 0x00000010ULL;
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_STORAGE_BUFFER_BIT = 0x00000020ULL;
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT = 0x00000040ULL;
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT = 0x00000080ULL;
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT = 0x00000100ULL;
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_SHADER_DEVICE_ADDRESS_BIT = 0x00020000ULL;
+#ifdef VK_ENABLE_BETA_EXTENSIONS
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_EXECUTION_GRAPH_SCRATCH_BIT_AMDX = 0x02000000ULL;
+#endif
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_TRANSFER_SRC_BIT_KHR = 0x00000001ULL;
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_TRANSFER_DST_BIT_KHR = 0x00000002ULL;
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR = 0x00000004ULL;
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT_KHR = 0x00000008ULL;
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_UNIFORM_BUFFER_BIT_KHR = 0x00000010ULL;
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_STORAGE_BUFFER_BIT_KHR = 0x00000020ULL;
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT_KHR = 0x00000040ULL;
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT_KHR = 0x00000080ULL;
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT_KHR = 0x00000100ULL;
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_CONDITIONAL_RENDERING_BIT_EXT = 0x00000200ULL;
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_SHADER_BINDING_TABLE_BIT_KHR = 0x00000400ULL;
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_RAY_TRACING_BIT_NV = 0x00000400ULL;
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT = 0x00000800ULL;
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT = 0x00001000ULL;
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_VIDEO_DECODE_SRC_BIT_KHR = 0x00002000ULL;
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_VIDEO_DECODE_DST_BIT_KHR = 0x00004000ULL;
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_VIDEO_ENCODE_DST_BIT_KHR = 0x00008000ULL;
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_VIDEO_ENCODE_SRC_BIT_KHR = 0x00010000ULL;
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_SHADER_DEVICE_ADDRESS_BIT_KHR = 0x00020000ULL;
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR = 0x00080000ULL;
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR = 0x00100000ULL;
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT = 0x00200000ULL;
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT = 0x00400000ULL;
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT = 0x04000000ULL;
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT = 0x00800000ULL;
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_MICROMAP_STORAGE_BIT_EXT = 0x01000000ULL;
+static const VkBufferUsageFlagBits2 VK_BUFFER_USAGE_2_PREPROCESS_BUFFER_BIT_EXT = 0x80000000ULL;
+
+
+typedef enum VkHostImageCopyFlagBits {
+    VK_HOST_IMAGE_COPY_MEMCPY = 0x00000001,
+    VK_HOST_IMAGE_COPY_MEMCPY_EXT = VK_HOST_IMAGE_COPY_MEMCPY,
+    VK_HOST_IMAGE_COPY_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
+} VkHostImageCopyFlagBits;
+typedef VkFlags VkHostImageCopyFlags;
+typedef struct VkPhysicalDeviceVulkan14Features {
+    VkStructureType    sType;
+    void*              pNext;
+    VkBool32           globalPriorityQuery;
+    VkBool32           shaderSubgroupRotate;
+    VkBool32           shaderSubgroupRotateClustered;
+    VkBool32           shaderFloatControls2;
+    VkBool32           shaderExpectAssume;
+    VkBool32           rectangularLines;
+    VkBool32           bresenhamLines;
+    VkBool32           smoothLines;
+    VkBool32           stippledRectangularLines;
+    VkBool32           stippledBresenhamLines;
+    VkBool32           stippledSmoothLines;
+    VkBool32           vertexAttributeInstanceRateDivisor;
+    VkBool32           vertexAttributeInstanceRateZeroDivisor;
+    VkBool32           indexTypeUint8;
+    VkBool32           dynamicRenderingLocalRead;
+    VkBool32           maintenance5;
+    VkBool32           maintenance6;
+    VkBool32           pipelineProtectedAccess;
+    VkBool32           pipelineRobustness;
+    VkBool32           hostImageCopy;
+    VkBool32           pushDescriptor;
+} VkPhysicalDeviceVulkan14Features;
 
-typedef enum VkPresentModeKHR {
-    VK_PRESENT_MODE_IMMEDIATE_KHR = 0,
-    VK_PRESENT_MODE_MAILBOX_KHR = 1,
-    VK_PRESENT_MODE_FIFO_KHR = 2,
-    VK_PRESENT_MODE_FIFO_RELAXED_KHR = 3,
-    VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR = 1000111000,
-    VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR = 1000111001,
-    VK_PRESENT_MODE_MAX_ENUM_KHR = 0x7FFFFFFF
-} VkPresentModeKHR;
+typedef struct VkPhysicalDeviceVulkan14Properties {
+    VkStructureType                       sType;
+    void*                                 pNext;
+    uint32_t                              lineSubPixelPrecisionBits;
+    uint32_t                              maxVertexAttribDivisor;
+    VkBool32                              supportsNonZeroFirstInstance;
+    uint32_t                              maxPushDescriptors;
+    VkBool32                              dynamicRenderingLocalReadDepthStencilAttachments;
+    VkBool32                              dynamicRenderingLocalReadMultisampledAttachments;
+    VkBool32                              earlyFragmentMultisampleCoverageAfterSampleCounting;
+    VkBool32                              earlyFragmentSampleMaskTestBeforeSampleCounting;
+    VkBool32                              depthStencilSwizzleOneSupport;
+    VkBool32                              polygonModePointSize;
+    VkBool32                              nonStrictSinglePixelWideLinesUseParallelogram;
+    VkBool32                              nonStrictWideLinesUseParallelogram;
+    VkBool32                              blockTexelViewCompatibleMultipleLayers;
+    uint32_t                              maxCombinedImageSamplerDescriptorCount;
+    VkBool32                              fragmentShadingRateClampCombinerInputs;
+    VkPipelineRobustnessBufferBehavior    defaultRobustnessStorageBuffers;
+    VkPipelineRobustnessBufferBehavior    defaultRobustnessUniformBuffers;
+    VkPipelineRobustnessBufferBehavior    defaultRobustnessVertexInputs;
+    VkPipelineRobustnessImageBehavior     defaultRobustnessImages;
+    uint32_t                              copySrcLayoutCount;
+    VkImageLayout*                        pCopySrcLayouts;
+    uint32_t                              copyDstLayoutCount;
+    VkImageLayout*                        pCopyDstLayouts;
+    uint8_t                               optimalTilingLayoutUUID[VK_UUID_SIZE];
+    VkBool32                              identicalMemoryTypeRequirements;
+} VkPhysicalDeviceVulkan14Properties;
+
+typedef struct VkDeviceQueueGlobalPriorityCreateInfo {
+    VkStructureType          sType;
+    const void*              pNext;
+    VkQueueGlobalPriority    globalPriority;
+} VkDeviceQueueGlobalPriorityCreateInfo;
 
-typedef enum VkColorSpaceKHR {
-    VK_COLOR_SPACE_SRGB_NONLINEAR_KHR = 0,
-    VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT = 1000104001,
-    VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT = 1000104002,
-    VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT = 1000104003,
-    VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT = 1000104004,
-    VK_COLOR_SPACE_BT709_LINEAR_EXT = 1000104005,
-    VK_COLOR_SPACE_BT709_NONLINEAR_EXT = 1000104006,
-    VK_COLOR_SPACE_BT2020_LINEAR_EXT = 1000104007,
-    VK_COLOR_SPACE_HDR10_ST2084_EXT = 1000104008,
-  // VK_COLOR_SPACE_DOLBYVISION_EXT is deprecated, but no reason was given in the API XML
-    VK_COLOR_SPACE_DOLBYVISION_EXT = 1000104009,
-    VK_COLOR_SPACE_HDR10_HLG_EXT = 1000104010,
-    VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT = 1000104011,
-    VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT = 1000104012,
-    VK_COLOR_SPACE_PASS_THROUGH_EXT = 1000104013,
-    VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT = 1000104014,
-    VK_COLOR_SPACE_DISPLAY_NATIVE_AMD = 1000213000,
-  // VK_COLORSPACE_SRGB_NONLINEAR_KHR is a deprecated alias
-    VK_COLORSPACE_SRGB_NONLINEAR_KHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
-  // VK_COLOR_SPACE_DCI_P3_LINEAR_EXT is a deprecated alias
-    VK_COLOR_SPACE_DCI_P3_LINEAR_EXT = VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT,
-    VK_COLOR_SPACE_MAX_ENUM_KHR = 0x7FFFFFFF
-} VkColorSpaceKHR;
+typedef struct VkPhysicalDeviceGlobalPriorityQueryFeatures {
+    VkStructureType    sType;
+    void*              pNext;
+    VkBool32           globalPriorityQuery;
+} VkPhysicalDeviceGlobalPriorityQueryFeatures;
 
-typedef enum VkSurfaceTransformFlagBitsKHR {
-    VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR = 0x00000001,
-    VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = 0x00000002,
-    VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = 0x00000004,
-    VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = 0x00000008,
-    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = 0x00000010,
-    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = 0x00000020,
-    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 0x00000040,
+typedef struct VkQueueFamilyGlobalPriorityProperties {
+    VkStructureType          sType;
+    void*                    pNext;
+    uint32_t                 priorityCount;
+    VkQueueGlobalPriority    priorities[VK_MAX_GLOBAL_PRIORITY_SIZE];
+} VkQueueFamilyGlobalPriorityProperties;
+
+typedef struct VkPhysicalDeviceShaderSubgroupRotateFeatures {
+    VkStructureType    sType;
+    void*              pNext;
+    VkBool32           shaderSubgroupRotate;
+    VkBool32           shaderSubgroupRotateClustered;
+} VkPhysicalDeviceShaderSubgroupRotateFeatures;
+
+typedef struct VkPhysicalDeviceShaderFloatControls2Features {
+    VkStructureType    sType;
+    void*              pNext;
+    VkBool32           shaderFloatControls2;
+} VkPhysicalDeviceShaderFloatControls2Features;
+
+typedef struct VkPhysicalDeviceShaderExpectAssumeFeatures {
+    VkStructureType    sType;
+    void*              pNext;
+    VkBool32           shaderExpectAssume;
+} VkPhysicalDeviceShaderExpectAssumeFeatures;
+
+typedef struct VkPhysicalDeviceLineRasterizationFeatures {
+    VkStructureType    sType;
+    void*              pNext;
+    VkBool32           rectangularLines;
+    VkBool32           bresenhamLines;
+    VkBool32           smoothLines;
+    VkBool32           stippledRectangularLines;
+    VkBool32           stippledBresenhamLines;
+    VkBool32           stippledSmoothLines;
+} VkPhysicalDeviceLineRasterizationFeatures;
+
+typedef struct VkPhysicalDeviceLineRasterizationProperties {
+    VkStructureType    sType;
+    void*              pNext;
+    uint32_t           lineSubPixelPrecisionBits;
+} VkPhysicalDeviceLineRasterizationProperties;
+
+typedef struct VkPipelineRasterizationLineStateCreateInfo {
+    VkStructureType            sType;
+    const void*                pNext;
+    VkLineRasterizationMode    lineRasterizationMode;
+    VkBool32                   stippledLineEnable;
+    uint32_t                   lineStippleFactor;
+    uint16_t                   lineStipplePattern;
+} VkPipelineRasterizationLineStateCreateInfo;
+
+typedef struct VkPhysicalDeviceVertexAttributeDivisorProperties {
+    VkStructureType    sType;
+    void*              pNext;
+    uint32_t           maxVertexAttribDivisor;
+    VkBool32           supportsNonZeroFirstInstance;
+} VkPhysicalDeviceVertexAttributeDivisorProperties;
+
+typedef struct VkVertexInputBindingDivisorDescription {
+    uint32_t    binding;
+    uint32_t    divisor;
+} VkVertexInputBindingDivisorDescription;
+
+typedef struct VkPipelineVertexInputDivisorStateCreateInfo {
+    VkStructureType                                  sType;
+    const void*                                      pNext;
+    uint32_t                                         vertexBindingDivisorCount;
+    const VkVertexInputBindingDivisorDescription*    pVertexBindingDivisors;
+} VkPipelineVertexInputDivisorStateCreateInfo;
+
+typedef struct VkPhysicalDeviceVertexAttributeDivisorFeatures {
+    VkStructureType    sType;
+    void*              pNext;
+    VkBool32           vertexAttributeInstanceRateDivisor;
+    VkBool32           vertexAttributeInstanceRateZeroDivisor;
+} VkPhysicalDeviceVertexAttributeDivisorFeatures;
+
+typedef struct VkPhysicalDeviceIndexTypeUint8Features {
+    VkStructureType    sType;
+    void*              pNext;
+    VkBool32           indexTypeUint8;
+} VkPhysicalDeviceIndexTypeUint8Features;
+
+typedef struct VkMemoryMapInfo {
+    VkStructureType     sType;
+    const void*         pNext;
+    VkMemoryMapFlags    flags;
+    VkDeviceMemory      memory;
+    VkDeviceSize        offset;
+    VkDeviceSize        size;
+} VkMemoryMapInfo;
+
+typedef struct VkMemoryUnmapInfo {
+    VkStructureType       sType;
+    const void*           pNext;
+    VkMemoryUnmapFlags    flags;
+    VkDeviceMemory        memory;
+} VkMemoryUnmapInfo;
+
+typedef struct VkPhysicalDeviceMaintenance5Features {
+    VkStructureType    sType;
+    void*              pNext;
+    VkBool32           maintenance5;
+} VkPhysicalDeviceMaintenance5Features;
+
+typedef struct VkPhysicalDeviceMaintenance5Properties {
+    VkStructureType    sType;
+    void*              pNext;
+    VkBool32           earlyFragmentMultisampleCoverageAfterSampleCounting;
+    VkBool32           earlyFragmentSampleMaskTestBeforeSampleCounting;
+    VkBool32           depthStencilSwizzleOneSupport;
+    VkBool32           polygonModePointSize;
+    VkBool32           nonStrictSinglePixelWideLinesUseParallelogram;
+    VkBool32           nonStrictWideLinesUseParallelogram;
+} VkPhysicalDeviceMaintenance5Properties;
+
+typedef struct VkRenderingAreaInfo {
+    VkStructureType    sType;
+    const void*        pNext;
+    uint32_t           viewMask;
+    uint32_t           colorAttachmentCount;
+    const VkFormat*    pColorAttachmentFormats;
+    VkFormat           depthAttachmentFormat;
+    VkFormat           stencilAttachmentFormat;
+} VkRenderingAreaInfo;
+
+typedef struct VkImageSubresource2 {
+    VkStructureType       sType;
+    void*                 pNext;
+    VkImageSubresource    imageSubresource;
+} VkImageSubresource2;
+
+typedef struct VkDeviceImageSubresourceInfo {
+    VkStructureType               sType;
+    const void*                   pNext;
+    const VkImageCreateInfo*      pCreateInfo;
+    const VkImageSubresource2*    pSubresource;
+} VkDeviceImageSubresourceInfo;
+
+typedef struct VkSubresourceLayout2 {
+    VkStructureType        sType;
+    void*                  pNext;
+    VkSubresourceLayout    subresourceLayout;
+} VkSubresourceLayout2;
+
+typedef struct VkPipelineCreateFlags2CreateInfo {
+    VkStructureType           sType;
+    const void*               pNext;
+    VkPipelineCreateFlags2    flags;
+} VkPipelineCreateFlags2CreateInfo;
+
+typedef struct VkBufferUsageFlags2CreateInfo {
+    VkStructureType        sType;
+    const void*            pNext;
+    VkBufferUsageFlags2    usage;
+} VkBufferUsageFlags2CreateInfo;
+
+typedef struct VkPhysicalDevicePushDescriptorProperties {
+    VkStructureType    sType;
+    void*              pNext;
+    uint32_t           maxPushDescriptors;
+} VkPhysicalDevicePushDescriptorProperties;
+
+typedef struct VkPhysicalDeviceDynamicRenderingLocalReadFeatures {
+    VkStructureType    sType;
+    void*              pNext;
+    VkBool32           dynamicRenderingLocalRead;
+} VkPhysicalDeviceDynamicRenderingLocalReadFeatures;
+
+typedef struct VkRenderingAttachmentLocationInfo {
+    VkStructureType    sType;
+    const void*        pNext;
+    uint32_t           colorAttachmentCount;
+    const uint32_t*    pColorAttachmentLocations;
+} VkRenderingAttachmentLocationInfo;
+
+typedef struct VkRenderingInputAttachmentIndexInfo {
+    VkStructureType    sType;
+    const void*        pNext;
+    uint32_t           colorAttachmentCount;
+    const uint32_t*    pColorAttachmentInputIndices;
+    const uint32_t*    pDepthInputAttachmentIndex;
+    const uint32_t*    pStencilInputAttachmentIndex;
+} VkRenderingInputAttachmentIndexInfo;
+
+typedef struct VkPhysicalDeviceMaintenance6Features {
+    VkStructureType    sType;
+    void*              pNext;
+    VkBool32           maintenance6;
+} VkPhysicalDeviceMaintenance6Features;
+
+typedef struct VkPhysicalDeviceMaintenance6Properties {
+    VkStructureType    sType;
+    void*              pNext;
+    VkBool32           blockTexelViewCompatibleMultipleLayers;
+    uint32_t           maxCombinedImageSamplerDescriptorCount;
+    VkBool32           fragmentShadingRateClampCombinerInputs;
+} VkPhysicalDeviceMaintenance6Properties;
+
+typedef struct VkBindMemoryStatus {
+    VkStructureType    sType;
+    const void*        pNext;
+    VkResult*          pResult;
+} VkBindMemoryStatus;
+
+typedef struct VkBindDescriptorSetsInfo {
+    VkStructureType           sType;
+    const void*               pNext;
+    VkShaderStageFlags        stageFlags;
+    VkPipelineLayout          layout;
+    uint32_t                  firstSet;
+    uint32_t                  descriptorSetCount;
+    const VkDescriptorSet*    pDescriptorSets;
+    uint32_t                  dynamicOffsetCount;
+    const uint32_t*           pDynamicOffsets;
+} VkBindDescriptorSetsInfo;
+
+typedef struct VkPushConstantsInfo {
+    VkStructureType       sType;
+    const void*           pNext;
+    VkPipelineLayout      layout;
+    VkShaderStageFlags    stageFlags;
+    uint32_t              offset;
+    uint32_t              size;
+    const void*           pValues;
+} VkPushConstantsInfo;
+
+typedef struct VkPushDescriptorSetInfo {
+    VkStructureType                sType;
+    const void*                    pNext;
+    VkShaderStageFlags             stageFlags;
+    VkPipelineLayout               layout;
+    uint32_t                       set;
+    uint32_t                       descriptorWriteCount;
+    const VkWriteDescriptorSet*    pDescriptorWrites;
+} VkPushDescriptorSetInfo;
+
+typedef struct VkPushDescriptorSetWithTemplateInfo {
+    VkStructureType               sType;
+    const void*                   pNext;
+    VkDescriptorUpdateTemplate    descriptorUpdateTemplate;
+    VkPipelineLayout              layout;
+    uint32_t                      set;
+    const void*                   pData;
+} VkPushDescriptorSetWithTemplateInfo;
+
+typedef struct VkPhysicalDevicePipelineProtectedAccessFeatures {
+    VkStructureType    sType;
+    void*              pNext;
+    VkBool32           pipelineProtectedAccess;
+} VkPhysicalDevicePipelineProtectedAccessFeatures;
+
+typedef struct VkPhysicalDevicePipelineRobustnessFeatures {
+    VkStructureType    sType;
+    void*              pNext;
+    VkBool32           pipelineRobustness;
+} VkPhysicalDevicePipelineRobustnessFeatures;
+
+typedef struct VkPhysicalDevicePipelineRobustnessProperties {
+    VkStructureType                       sType;
+    void*                                 pNext;
+    VkPipelineRobustnessBufferBehavior    defaultRobustnessStorageBuffers;
+    VkPipelineRobustnessBufferBehavior    defaultRobustnessUniformBuffers;
+    VkPipelineRobustnessBufferBehavior    defaultRobustnessVertexInputs;
+    VkPipelineRobustnessImageBehavior     defaultRobustnessImages;
+} VkPhysicalDevicePipelineRobustnessProperties;
+
+typedef struct VkPipelineRobustnessCreateInfo {
+    VkStructureType                       sType;
+    const void*                           pNext;
+    VkPipelineRobustnessBufferBehavior    storageBuffers;
+    VkPipelineRobustnessBufferBehavior    uniformBuffers;
+    VkPipelineRobustnessBufferBehavior    vertexInputs;
+    VkPipelineRobustnessImageBehavior     images;
+} VkPipelineRobustnessCreateInfo;
+
+typedef struct VkPhysicalDeviceHostImageCopyFeatures {
+    VkStructureType    sType;
+    void*              pNext;
+    VkBool32           hostImageCopy;
+} VkPhysicalDeviceHostImageCopyFeatures;
+
+typedef struct VkPhysicalDeviceHostImageCopyProperties {
+    VkStructureType    sType;
+    void*              pNext;
+    uint32_t           copySrcLayoutCount;
+    VkImageLayout*     pCopySrcLayouts;
+    uint32_t           copyDstLayoutCount;
+    VkImageLayout*     pCopyDstLayouts;
+    uint8_t            optimalTilingLayoutUUID[VK_UUID_SIZE];
+    VkBool32           identicalMemoryTypeRequirements;
+} VkPhysicalDeviceHostImageCopyProperties;
+
+typedef struct VkMemoryToImageCopy {
+    VkStructureType             sType;
+    const void*                 pNext;
+    const void*                 pHostPointer;
+    uint32_t                    memoryRowLength;
+    uint32_t                    memoryImageHeight;
+    VkImageSubresourceLayers    imageSubresource;
+    VkOffset3D                  imageOffset;
+    VkExtent3D                  imageExtent;
+} VkMemoryToImageCopy;
+
+typedef struct VkImageToMemoryCopy {
+    VkStructureType             sType;
+    const void*                 pNext;
+    void*                       pHostPointer;
+    uint32_t                    memoryRowLength;
+    uint32_t                    memoryImageHeight;
+    VkImageSubresourceLayers    imageSubresource;
+    VkOffset3D                  imageOffset;
+    VkExtent3D                  imageExtent;
+} VkImageToMemoryCopy;
+
+typedef struct VkCopyMemoryToImageInfo {
+    VkStructureType               sType;
+    const void*                   pNext;
+    VkHostImageCopyFlags          flags;
+    VkImage                       dstImage;
+    VkImageLayout                 dstImageLayout;
+    uint32_t                      regionCount;
+    const VkMemoryToImageCopy*    pRegions;
+} VkCopyMemoryToImageInfo;
+
+typedef struct VkCopyImageToMemoryInfo {
+    VkStructureType               sType;
+    const void*                   pNext;
+    VkHostImageCopyFlags          flags;
+    VkImage                       srcImage;
+    VkImageLayout                 srcImageLayout;
+    uint32_t                      regionCount;
+    const VkImageToMemoryCopy*    pRegions;
+} VkCopyImageToMemoryInfo;
+
+typedef struct VkCopyImageToImageInfo {
+    VkStructureType         sType;
+    const void*             pNext;
+    VkHostImageCopyFlags    flags;
+    VkImage                 srcImage;
+    VkImageLayout           srcImageLayout;
+    VkImage                 dstImage;
+    VkImageLayout           dstImageLayout;
+    uint32_t                regionCount;
+    const VkImageCopy2*     pRegions;
+} VkCopyImageToImageInfo;
+
+typedef struct VkHostImageLayoutTransitionInfo {
+    VkStructureType            sType;
+    const void*                pNext;
+    VkImage                    image;
+    VkImageLayout              oldLayout;
+    VkImageLayout              newLayout;
+    VkImageSubresourceRange    subresourceRange;
+} VkHostImageLayoutTransitionInfo;
+
+typedef struct VkSubresourceHostMemcpySize {
+    VkStructureType    sType;
+    void*              pNext;
+    VkDeviceSize       size;
+} VkSubresourceHostMemcpySize;
+
+typedef struct VkHostImageCopyDevicePerformanceQuery {
+    VkStructureType    sType;
+    void*              pNext;
+    VkBool32           optimalDeviceAccess;
+    VkBool32           identicalMemoryLayout;
+} VkHostImageCopyDevicePerformanceQuery;
+
+typedef void (VKAPI_PTR *PFN_vkCmdSetLineStipple)(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern);
+typedef VkResult (VKAPI_PTR *PFN_vkMapMemory2)(VkDevice device, const VkMemoryMapInfo* pMemoryMapInfo, void** ppData);
+typedef VkResult (VKAPI_PTR *PFN_vkUnmapMemory2)(VkDevice device, const VkMemoryUnmapInfo* pMemoryUnmapInfo);
+typedef void (VKAPI_PTR *PFN_vkCmdBindIndexBuffer2)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkDeviceSize size, VkIndexType indexType);
+typedef void (VKAPI_PTR *PFN_vkGetRenderingAreaGranularity)(VkDevice device, const VkRenderingAreaInfo* pRenderingAreaInfo, VkExtent2D* pGranularity);
+typedef void (VKAPI_PTR *PFN_vkGetDeviceImageSubresourceLayout)(VkDevice device, const VkDeviceImageSubresourceInfo* pInfo, VkSubresourceLayout2* pLayout);
+typedef void (VKAPI_PTR *PFN_vkGetImageSubresourceLayout2)(VkDevice device, VkImage image, const VkImageSubresource2* pSubresource, VkSubresourceLayout2* pLayout);
+typedef void (VKAPI_PTR *PFN_vkCmdPushDescriptorSet)(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, const VkWriteDescriptorSet* pDescriptorWrites);
+typedef void (VKAPI_PTR *PFN_vkCmdPushDescriptorSetWithTemplate)(VkCommandBuffer commandBuffer, VkDescriptorUpdateTemplate descriptorUpdateTemplate, VkPipelineLayout layout, uint32_t set, const void* pData);
+typedef void (VKAPI_PTR *PFN_vkCmdSetRenderingAttachmentLocations)(VkCommandBuffer commandBuffer, const VkRenderingAttachmentLocationInfo* pLocationInfo);
+typedef void (VKAPI_PTR *PFN_vkCmdSetRenderingInputAttachmentIndices)(VkCommandBuffer commandBuffer, const VkRenderingInputAttachmentIndexInfo* pInputAttachmentIndexInfo);
+typedef void (VKAPI_PTR *PFN_vkCmdBindDescriptorSets2)(VkCommandBuffer commandBuffer, const VkBindDescriptorSetsInfo*   pBindDescriptorSetsInfo);
+typedef void (VKAPI_PTR *PFN_vkCmdPushConstants2)(VkCommandBuffer commandBuffer, const VkPushConstantsInfo*        pPushConstantsInfo);
+typedef void (VKAPI_PTR *PFN_vkCmdPushDescriptorSet2)(VkCommandBuffer commandBuffer, const VkPushDescriptorSetInfo*    pPushDescriptorSetInfo);
+typedef void (VKAPI_PTR *PFN_vkCmdPushDescriptorSetWithTemplate2)(VkCommandBuffer commandBuffer, const VkPushDescriptorSetWithTemplateInfo* pPushDescriptorSetWithTemplateInfo);
+typedef VkResult (VKAPI_PTR *PFN_vkCopyMemoryToImage)(VkDevice device, const VkCopyMemoryToImageInfo*    pCopyMemoryToImageInfo);
+typedef VkResult (VKAPI_PTR *PFN_vkCopyImageToMemory)(VkDevice device, const VkCopyImageToMemoryInfo*    pCopyImageToMemoryInfo);
+typedef VkResult (VKAPI_PTR *PFN_vkCopyImageToImage)(VkDevice device, const VkCopyImageToImageInfo*    pCopyImageToImageInfo);
+typedef VkResult (VKAPI_PTR *PFN_vkTransitionImageLayout)(VkDevice device, uint32_t transitionCount, const VkHostImageLayoutTransitionInfo*    pTransitions);
+
+#ifndef VK_NO_PROTOTYPES
+VKAPI_ATTR void VKAPI_CALL vkCmdSetLineStipple(
+    VkCommandBuffer                             commandBuffer,
+    uint32_t                                    lineStippleFactor,
+    uint16_t                                    lineStipplePattern);
+
+VKAPI_ATTR VkResult VKAPI_CALL vkMapMemory2(
+    VkDevice                                    device,
+    const VkMemoryMapInfo*                      pMemoryMapInfo,
+    void**                                      ppData);
+
+VKAPI_ATTR VkResult VKAPI_CALL vkUnmapMemory2(
+    VkDevice                                    device,
+    const VkMemoryUnmapInfo*                    pMemoryUnmapInfo);
+
+VKAPI_ATTR void VKAPI_CALL vkCmdBindIndexBuffer2(
+    VkCommandBuffer                             commandBuffer,
+    VkBuffer                                    buffer,
+    VkDeviceSize                                offset,
+    VkDeviceSize                                size,
+    VkIndexType                                 indexType);
+
+VKAPI_ATTR void VKAPI_CALL vkGetRenderingAreaGranularity(
+    VkDevice                                    device,
+    const VkRenderingAreaInfo*                  pRenderingAreaInfo,
+    VkExtent2D*                                 pGranularity);
+
+VKAPI_ATTR void VKAPI_CALL vkGetDeviceImageSubresourceLayout(
+    VkDevice                                    device,
+    const VkDeviceImageSubresourceInfo*         pInfo,
+    VkSubresourceLayout2*                       pLayout);
+
+VKAPI_ATTR void VKAPI_CALL vkGetImageSubresourceLayout2(
+    VkDevice                                    device,
+    VkImage                                     image,
+    const VkImageSubresource2*                  pSubresource,
+    VkSubresourceLayout2*                       pLayout);
+
+VKAPI_ATTR void VKAPI_CALL vkCmdPushDescriptorSet(
+    VkCommandBuffer                             commandBuffer,
+    VkPipelineBindPoint                         pipelineBindPoint,
+    VkPipelineLayout                            layout,
+    uint32_t                                    set,
+    uint32_t                                    descriptorWriteCount,
+    const VkWriteDescriptorSet*                 pDescriptorWrites);
+
+VKAPI_ATTR void VKAPI_CALL vkCmdPushDescriptorSetWithTemplate(
+    VkCommandBuffer                             commandBuffer,
+    VkDescriptorUpdateTemplate                  descriptorUpdateTemplate,
+    VkPipelineLayout                            layout,
+    uint32_t                                    set,
+    const void*                                 pData);
+
+VKAPI_ATTR void VKAPI_CALL vkCmdSetRenderingAttachmentLocations(
+    VkCommandBuffer                             commandBuffer,
+    const VkRenderingAttachmentLocationInfo*    pLocationInfo);
+
+VKAPI_ATTR void VKAPI_CALL vkCmdSetRenderingInputAttachmentIndices(
+    VkCommandBuffer                             commandBuffer,
+    const VkRenderingInputAttachmentIndexInfo*  pInputAttachmentIndexInfo);
+
+VKAPI_ATTR void VKAPI_CALL vkCmdBindDescriptorSets2(
+    VkCommandBuffer                             commandBuffer,
+    const VkBindDescriptorSetsInfo*             pBindDescriptorSetsInfo);
+
+VKAPI_ATTR void VKAPI_CALL vkCmdPushConstants2(
+    VkCommandBuffer                             commandBuffer,
+    const VkPushConstantsInfo*                  pPushConstantsInfo);
+
+VKAPI_ATTR void VKAPI_CALL vkCmdPushDescriptorSet2(
+    VkCommandBuffer                             commandBuffer,
+    const VkPushDescriptorSetInfo*              pPushDescriptorSetInfo);
+
+VKAPI_ATTR void VKAPI_CALL vkCmdPushDescriptorSetWithTemplate2(
+    VkCommandBuffer                             commandBuffer,
+    const VkPushDescriptorSetWithTemplateInfo*  pPushDescriptorSetWithTemplateInfo);
+
+VKAPI_ATTR VkResult VKAPI_CALL vkCopyMemoryToImage(
+    VkDevice                                    device,
+    const VkCopyMemoryToImageInfo*              pCopyMemoryToImageInfo);
+
+VKAPI_ATTR VkResult VKAPI_CALL vkCopyImageToMemory(
+    VkDevice                                    device,
+    const VkCopyImageToMemoryInfo*              pCopyImageToMemoryInfo);
+
+VKAPI_ATTR VkResult VKAPI_CALL vkCopyImageToImage(
+    VkDevice                                    device,
+    const VkCopyImageToImageInfo*               pCopyImageToImageInfo);
+
+VKAPI_ATTR VkResult VKAPI_CALL vkTransitionImageLayout(
+    VkDevice                                    device,
+    uint32_t                                    transitionCount,
+    const VkHostImageLayoutTransitionInfo*      pTransitions);
+#endif
+
+
+// VK_KHR_surface is a preprocessor guard. Do not pass it to API calls.
+#define VK_KHR_surface 1
+VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSurfaceKHR)
+#define VK_KHR_SURFACE_SPEC_VERSION       25
+#define VK_KHR_SURFACE_EXTENSION_NAME     "VK_KHR_surface"
+
+typedef enum VkPresentModeKHR {
+    VK_PRESENT_MODE_IMMEDIATE_KHR = 0,
+    VK_PRESENT_MODE_MAILBOX_KHR = 1,
+    VK_PRESENT_MODE_FIFO_KHR = 2,
+    VK_PRESENT_MODE_FIFO_RELAXED_KHR = 3,
+    VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR = 1000111000,
+    VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR = 1000111001,
+    VK_PRESENT_MODE_FIFO_LATEST_READY_EXT = 1000361000,
+    VK_PRESENT_MODE_MAX_ENUM_KHR = 0x7FFFFFFF
+} VkPresentModeKHR;
+
+typedef enum VkColorSpaceKHR {
+    VK_COLOR_SPACE_SRGB_NONLINEAR_KHR = 0,
+    VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT = 1000104001,
+    VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT = 1000104002,
+    VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT = 1000104003,
+    VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT = 1000104004,
+    VK_COLOR_SPACE_BT709_LINEAR_EXT = 1000104005,
+    VK_COLOR_SPACE_BT709_NONLINEAR_EXT = 1000104006,
+    VK_COLOR_SPACE_BT2020_LINEAR_EXT = 1000104007,
+    VK_COLOR_SPACE_HDR10_ST2084_EXT = 1000104008,
+  // VK_COLOR_SPACE_DOLBYVISION_EXT is deprecated, but no reason was given in the API XML
+    VK_COLOR_SPACE_DOLBYVISION_EXT = 1000104009,
+    VK_COLOR_SPACE_HDR10_HLG_EXT = 1000104010,
+    VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT = 1000104011,
+    VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT = 1000104012,
+    VK_COLOR_SPACE_PASS_THROUGH_EXT = 1000104013,
+    VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT = 1000104014,
+    VK_COLOR_SPACE_DISPLAY_NATIVE_AMD = 1000213000,
+  // VK_COLORSPACE_SRGB_NONLINEAR_KHR is a deprecated alias
+    VK_COLORSPACE_SRGB_NONLINEAR_KHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
+  // VK_COLOR_SPACE_DCI_P3_LINEAR_EXT is a deprecated alias
+    VK_COLOR_SPACE_DCI_P3_LINEAR_EXT = VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT,
+    VK_COLOR_SPACE_MAX_ENUM_KHR = 0x7FFFFFFF
+} VkColorSpaceKHR;
+
+typedef enum VkSurfaceTransformFlagBitsKHR {
+    VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR = 0x00000001,
+    VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = 0x00000002,
+    VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = 0x00000004,
+    VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = 0x00000008,
+    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = 0x00000010,
+    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = 0x00000020,
+    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 0x00000040,
     VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 0x00000080,
     VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR = 0x00000100,
     VK_SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
@@ -8077,6 +8904,7 @@ typedef enum VkVideoCodecOperationFlagBitsKHR {
     VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR = 0x00000001,
     VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR = 0x00000002,
     VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR = 0x00000004,
+    VK_VIDEO_CODEC_OPERATION_ENCODE_AV1_BIT_KHR = 0x00040000,
     VK_VIDEO_CODEC_OPERATION_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
 } VkVideoCodecOperationFlagBitsKHR;
 typedef VkFlags VkVideoCodecOperationFlagsKHR;
@@ -8111,9 +8939,16 @@ typedef enum VkVideoSessionCreateFlagBitsKHR {
     VK_VIDEO_SESSION_CREATE_PROTECTED_CONTENT_BIT_KHR = 0x00000001,
     VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_PARAMETER_OPTIMIZATIONS_BIT_KHR = 0x00000002,
     VK_VIDEO_SESSION_CREATE_INLINE_QUERIES_BIT_KHR = 0x00000004,
+    VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR = 0x00000008,
+    VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_EMPHASIS_MAP_BIT_KHR = 0x00000010,
     VK_VIDEO_SESSION_CREATE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
 } VkVideoSessionCreateFlagBitsKHR;
 typedef VkFlags VkVideoSessionCreateFlagsKHR;
+
+typedef enum VkVideoSessionParametersCreateFlagBitsKHR {
+    VK_VIDEO_SESSION_PARAMETERS_CREATE_QUANTIZATION_MAP_COMPATIBLE_BIT_KHR = 0x00000001,
+    VK_VIDEO_SESSION_PARAMETERS_CREATE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
+} VkVideoSessionParametersCreateFlagBitsKHR;
 typedef VkFlags VkVideoSessionParametersCreateFlagsKHR;
 typedef VkFlags VkVideoBeginCodingFlagsKHR;
 typedef VkFlags VkVideoEndCodingFlagsKHR;
@@ -8416,6 +9251,7 @@ typedef enum VkVideoEncodeH264CapabilityFlagBitsKHR {
     VK_VIDEO_ENCODE_H264_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR = 0x00000040,
     VK_VIDEO_ENCODE_H264_CAPABILITY_PER_SLICE_CONSTANT_QP_BIT_KHR = 0x00000080,
     VK_VIDEO_ENCODE_H264_CAPABILITY_GENERATE_PREFIX_NALU_BIT_KHR = 0x00000100,
+    VK_VIDEO_ENCODE_H264_CAPABILITY_MB_QP_DIFF_WRAPAROUND_BIT_KHR = 0x00000200,
     VK_VIDEO_ENCODE_H264_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
 } VkVideoEncodeH264CapabilityFlagBitsKHR;
 typedef VkFlags VkVideoEncodeH264CapabilityFlagsKHR;
@@ -8616,6 +9452,7 @@ typedef enum VkVideoEncodeH265CapabilityFlagBitsKHR {
     VK_VIDEO_ENCODE_H265_CAPABILITY_PER_SLICE_SEGMENT_CONSTANT_QP_BIT_KHR = 0x00000080,
     VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILES_PER_SLICE_SEGMENT_BIT_KHR = 0x00000100,
     VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_SLICE_SEGMENTS_PER_TILE_BIT_KHR = 0x00000200,
+    VK_VIDEO_ENCODE_H265_CAPABILITY_CU_QP_DIFF_WRAPAROUND_BIT_KHR = 0x00000400,
     VK_VIDEO_ENCODE_H265_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
 } VkVideoEncodeH265CapabilityFlagBitsKHR;
 typedef VkFlags VkVideoEncodeH265CapabilityFlagsKHR;
@@ -8901,38 +9738,6 @@ typedef VkPhysicalDeviceDynamicRenderingFeatures VkPhysicalDeviceDynamicRenderin
 
 typedef VkCommandBufferInheritanceRenderingInfo VkCommandBufferInheritanceRenderingInfoKHR;
 
-typedef struct VkRenderingFragmentShadingRateAttachmentInfoKHR {
-    VkStructureType    sType;
-    const void*        pNext;
-    VkImageView        imageView;
-    VkImageLayout      imageLayout;
-    VkExtent2D         shadingRateAttachmentTexelSize;
-} VkRenderingFragmentShadingRateAttachmentInfoKHR;
-
-typedef struct VkRenderingFragmentDensityMapAttachmentInfoEXT {
-    VkStructureType    sType;
-    const void*        pNext;
-    VkImageView        imageView;
-    VkImageLayout      imageLayout;
-} VkRenderingFragmentDensityMapAttachmentInfoEXT;
-
-typedef struct VkAttachmentSampleCountInfoAMD {
-    VkStructureType                 sType;
-    const void*                     pNext;
-    uint32_t                        colorAttachmentCount;
-    const VkSampleCountFlagBits*    pColorAttachmentSamples;
-    VkSampleCountFlagBits           depthStencilAttachmentSamples;
-} VkAttachmentSampleCountInfoAMD;
-
-typedef VkAttachmentSampleCountInfoAMD VkAttachmentSampleCountInfoNV;
-
-typedef struct VkMultiviewPerViewAttributesInfoNVX {
-    VkStructureType    sType;
-    const void*        pNext;
-    VkBool32           perViewAttributes;
-    VkBool32           perViewAttributesPositionXOnly;
-} VkMultiviewPerViewAttributesInfoNVX;
-
 typedef void (VKAPI_PTR *PFN_vkCmdBeginRenderingKHR)(VkCommandBuffer                   commandBuffer, const VkRenderingInfo*                              pRenderingInfo);
 typedef void (VKAPI_PTR *PFN_vkCmdEndRenderingKHR)(VkCommandBuffer                   commandBuffer);
 
@@ -9288,11 +10093,7 @@ VKAPI_ATTR VkResult VKAPI_CALL vkGetSemaphoreFdKHR(
 #define VK_KHR_push_descriptor 1
 #define VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION 2
 #define VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME "VK_KHR_push_descriptor"
-typedef struct VkPhysicalDevicePushDescriptorPropertiesKHR {
-    VkStructureType    sType;
-    void*              pNext;
-    uint32_t           maxPushDescriptors;
-} VkPhysicalDevicePushDescriptorPropertiesKHR;
+typedef VkPhysicalDevicePushDescriptorProperties VkPhysicalDevicePushDescriptorPropertiesKHR;
 
 typedef void (VKAPI_PTR *PFN_vkCmdPushDescriptorSetKHR)(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, const VkWriteDescriptorSet* pDescriptorWrites);
 typedef void (VKAPI_PTR *PFN_vkCmdPushDescriptorSetWithTemplateKHR)(VkCommandBuffer commandBuffer, VkDescriptorUpdateTemplate descriptorUpdateTemplate, VkPipelineLayout layout, uint32_t set, const void* pData);
@@ -10104,39 +10905,16 @@ typedef struct VkVideoDecodeH265DpbSlotInfoKHR {
 
 // VK_KHR_global_priority is a preprocessor guard. Do not pass it to API calls.
 #define VK_KHR_global_priority 1
-#define VK_MAX_GLOBAL_PRIORITY_SIZE_KHR   16U
 #define VK_KHR_GLOBAL_PRIORITY_SPEC_VERSION 1
 #define VK_KHR_GLOBAL_PRIORITY_EXTENSION_NAME "VK_KHR_global_priority"
+#define VK_MAX_GLOBAL_PRIORITY_SIZE_KHR   VK_MAX_GLOBAL_PRIORITY_SIZE
+typedef VkQueueGlobalPriority VkQueueGlobalPriorityKHR;
 
-typedef enum VkQueueGlobalPriorityKHR {
-    VK_QUEUE_GLOBAL_PRIORITY_LOW_KHR = 128,
-    VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_KHR = 256,
-    VK_QUEUE_GLOBAL_PRIORITY_HIGH_KHR = 512,
-    VK_QUEUE_GLOBAL_PRIORITY_REALTIME_KHR = 1024,
-    VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT = VK_QUEUE_GLOBAL_PRIORITY_LOW_KHR,
-    VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT = VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_KHR,
-    VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT = VK_QUEUE_GLOBAL_PRIORITY_HIGH_KHR,
-    VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT = VK_QUEUE_GLOBAL_PRIORITY_REALTIME_KHR,
-    VK_QUEUE_GLOBAL_PRIORITY_MAX_ENUM_KHR = 0x7FFFFFFF
-} VkQueueGlobalPriorityKHR;
-typedef struct VkDeviceQueueGlobalPriorityCreateInfoKHR {
-    VkStructureType             sType;
-    const void*                 pNext;
-    VkQueueGlobalPriorityKHR    globalPriority;
-} VkDeviceQueueGlobalPriorityCreateInfoKHR;
+typedef VkDeviceQueueGlobalPriorityCreateInfo VkDeviceQueueGlobalPriorityCreateInfoKHR;
 
-typedef struct VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR {
-    VkStructureType    sType;
-    void*              pNext;
-    VkBool32           globalPriorityQuery;
-} VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR;
+typedef VkPhysicalDeviceGlobalPriorityQueryFeatures VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR;
 
-typedef struct VkQueueFamilyGlobalPriorityPropertiesKHR {
-    VkStructureType             sType;
-    void*                       pNext;
-    uint32_t                    priorityCount;
-    VkQueueGlobalPriorityKHR    priorities[VK_MAX_GLOBAL_PRIORITY_SIZE_KHR];
-} VkQueueFamilyGlobalPriorityPropertiesKHR;
+typedef VkQueueFamilyGlobalPriorityProperties VkQueueFamilyGlobalPriorityPropertiesKHR;
 
 
 
@@ -10307,6 +11085,14 @@ typedef struct VkPhysicalDeviceFragmentShadingRateKHR {
     VkExtent2D            fragmentSize;
 } VkPhysicalDeviceFragmentShadingRateKHR;
 
+typedef struct VkRenderingFragmentShadingRateAttachmentInfoKHR {
+    VkStructureType    sType;
+    const void*        pNext;
+    VkImageView        imageView;
+    VkImageLayout      imageLayout;
+    VkExtent2D         shadingRateAttachmentTexelSize;
+} VkRenderingFragmentShadingRateAttachmentInfoKHR;
+
 typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR)(VkPhysicalDevice physicalDevice, uint32_t* pFragmentShadingRateCount, VkPhysicalDeviceFragmentShadingRateKHR* pFragmentShadingRates);
 typedef void (VKAPI_PTR *PFN_vkCmdSetFragmentShadingRateKHR)(VkCommandBuffer           commandBuffer, const VkExtent2D*                           pFragmentSize, const VkFragmentShadingRateCombinerOpKHR    combinerOps[2]);
 
@@ -10327,39 +11113,23 @@ VKAPI_ATTR void VKAPI_CALL vkCmdSetFragmentShadingRateKHR(
 #define VK_KHR_dynamic_rendering_local_read 1
 #define VK_KHR_DYNAMIC_RENDERING_LOCAL_READ_SPEC_VERSION 1
 #define VK_KHR_DYNAMIC_RENDERING_LOCAL_READ_EXTENSION_NAME "VK_KHR_dynamic_rendering_local_read"
-typedef struct VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR {
-    VkStructureType    sType;
-    void*              pNext;
-    VkBool32           dynamicRenderingLocalRead;
-} VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR;
+typedef VkPhysicalDeviceDynamicRenderingLocalReadFeatures VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR;
 
-typedef struct VkRenderingAttachmentLocationInfoKHR {
-    VkStructureType    sType;
-    const void*        pNext;
-    uint32_t           colorAttachmentCount;
-    const uint32_t*    pColorAttachmentLocations;
-} VkRenderingAttachmentLocationInfoKHR;
+typedef VkRenderingAttachmentLocationInfo VkRenderingAttachmentLocationInfoKHR;
 
-typedef struct VkRenderingInputAttachmentIndexInfoKHR {
-    VkStructureType    sType;
-    const void*        pNext;
-    uint32_t           colorAttachmentCount;
-    const uint32_t*    pColorAttachmentInputIndices;
-    const uint32_t*    pDepthInputAttachmentIndex;
-    const uint32_t*    pStencilInputAttachmentIndex;
-} VkRenderingInputAttachmentIndexInfoKHR;
+typedef VkRenderingInputAttachmentIndexInfo VkRenderingInputAttachmentIndexInfoKHR;
 
-typedef void (VKAPI_PTR *PFN_vkCmdSetRenderingAttachmentLocationsKHR)(VkCommandBuffer commandBuffer, const VkRenderingAttachmentLocationInfoKHR* pLocationInfo);
-typedef void (VKAPI_PTR *PFN_vkCmdSetRenderingInputAttachmentIndicesKHR)(VkCommandBuffer commandBuffer, const VkRenderingInputAttachmentIndexInfoKHR* pInputAttachmentIndexInfo);
+typedef void (VKAPI_PTR *PFN_vkCmdSetRenderingAttachmentLocationsKHR)(VkCommandBuffer commandBuffer, const VkRenderingAttachmentLocationInfo* pLocationInfo);
+typedef void (VKAPI_PTR *PFN_vkCmdSetRenderingInputAttachmentIndicesKHR)(VkCommandBuffer commandBuffer, const VkRenderingInputAttachmentIndexInfo* pInputAttachmentIndexInfo);
 
 #ifndef VK_NO_PROTOTYPES
 VKAPI_ATTR void VKAPI_CALL vkCmdSetRenderingAttachmentLocationsKHR(
     VkCommandBuffer                             commandBuffer,
-    const VkRenderingAttachmentLocationInfoKHR* pLocationInfo);
+    const VkRenderingAttachmentLocationInfo*    pLocationInfo);
 
 VKAPI_ATTR void VKAPI_CALL vkCmdSetRenderingInputAttachmentIndicesKHR(
     VkCommandBuffer                             commandBuffer,
-    const VkRenderingInputAttachmentIndexInfoKHR* pInputAttachmentIndexInfo);
+    const VkRenderingInputAttachmentIndexInfo*  pInputAttachmentIndexInfo);
 #endif
 
 
@@ -10598,40 +11368,26 @@ VKAPI_ATTR VkResult VKAPI_CALL vkGetPipelineExecutableInternalRepresentationsKHR
 #define VK_KHR_map_memory2 1
 #define VK_KHR_MAP_MEMORY_2_SPEC_VERSION  1
 #define VK_KHR_MAP_MEMORY_2_EXTENSION_NAME "VK_KHR_map_memory2"
+typedef VkMemoryUnmapFlagBits VkMemoryUnmapFlagBitsKHR;
 
-typedef enum VkMemoryUnmapFlagBitsKHR {
-    VK_MEMORY_UNMAP_RESERVE_BIT_EXT = 0x00000001,
-    VK_MEMORY_UNMAP_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
-} VkMemoryUnmapFlagBitsKHR;
-typedef VkFlags VkMemoryUnmapFlagsKHR;
-typedef struct VkMemoryMapInfoKHR {
-    VkStructureType     sType;
-    const void*         pNext;
-    VkMemoryMapFlags    flags;
-    VkDeviceMemory      memory;
-    VkDeviceSize        offset;
-    VkDeviceSize        size;
-} VkMemoryMapInfoKHR;
+typedef VkMemoryUnmapFlags VkMemoryUnmapFlagsKHR;
 
-typedef struct VkMemoryUnmapInfoKHR {
-    VkStructureType          sType;
-    const void*              pNext;
-    VkMemoryUnmapFlagsKHR    flags;
-    VkDeviceMemory           memory;
-} VkMemoryUnmapInfoKHR;
+typedef VkMemoryMapInfo VkMemoryMapInfoKHR;
+
+typedef VkMemoryUnmapInfo VkMemoryUnmapInfoKHR;
 
-typedef VkResult (VKAPI_PTR *PFN_vkMapMemory2KHR)(VkDevice device, const VkMemoryMapInfoKHR* pMemoryMapInfo, void** ppData);
-typedef VkResult (VKAPI_PTR *PFN_vkUnmapMemory2KHR)(VkDevice device, const VkMemoryUnmapInfoKHR* pMemoryUnmapInfo);
+typedef VkResult (VKAPI_PTR *PFN_vkMapMemory2KHR)(VkDevice device, const VkMemoryMapInfo* pMemoryMapInfo, void** ppData);
+typedef VkResult (VKAPI_PTR *PFN_vkUnmapMemory2KHR)(VkDevice device, const VkMemoryUnmapInfo* pMemoryUnmapInfo);
 
 #ifndef VK_NO_PROTOTYPES
 VKAPI_ATTR VkResult VKAPI_CALL vkMapMemory2KHR(
     VkDevice                                    device,
-    const VkMemoryMapInfoKHR*                   pMemoryMapInfo,
+    const VkMemoryMapInfo*                      pMemoryMapInfo,
     void**                                      ppData);
 
 VKAPI_ATTR VkResult VKAPI_CALL vkUnmapMemory2KHR(
     VkDevice                                    device,
-    const VkMemoryUnmapInfoKHR*                 pMemoryUnmapInfo);
+    const VkMemoryUnmapInfo*                    pMemoryUnmapInfo);
 #endif
 
 
@@ -10696,11 +11452,19 @@ typedef enum VkVideoEncodeTuningModeKHR {
     VK_VIDEO_ENCODE_TUNING_MODE_LOSSLESS_KHR = 4,
     VK_VIDEO_ENCODE_TUNING_MODE_MAX_ENUM_KHR = 0x7FFFFFFF
 } VkVideoEncodeTuningModeKHR;
+
+typedef enum VkVideoEncodeFlagBitsKHR {
+    VK_VIDEO_ENCODE_WITH_QUANTIZATION_DELTA_MAP_BIT_KHR = 0x00000001,
+    VK_VIDEO_ENCODE_WITH_EMPHASIS_MAP_BIT_KHR = 0x00000002,
+    VK_VIDEO_ENCODE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
+} VkVideoEncodeFlagBitsKHR;
 typedef VkFlags VkVideoEncodeFlagsKHR;
 
 typedef enum VkVideoEncodeCapabilityFlagBitsKHR {
     VK_VIDEO_ENCODE_CAPABILITY_PRECEDING_EXTERNALLY_ENCODED_BYTES_BIT_KHR = 0x00000001,
     VK_VIDEO_ENCODE_CAPABILITY_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_DETECTION_BIT_KHR = 0x00000002,
+    VK_VIDEO_ENCODE_CAPABILITY_QUANTIZATION_DELTA_MAP_BIT_KHR = 0x00000004,
+    VK_VIDEO_ENCODE_CAPABILITY_EMPHASIS_MAP_BIT_KHR = 0x00000008,
     VK_VIDEO_ENCODE_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
 } VkVideoEncodeCapabilityFlagBitsKHR;
 typedef VkFlags VkVideoEncodeCapabilityFlagsKHR;
@@ -10888,27 +11652,12 @@ typedef VkCommandBufferSubmitInfo VkCommandBufferSubmitInfoKHR;
 
 typedef VkPhysicalDeviceSynchronization2Features VkPhysicalDeviceSynchronization2FeaturesKHR;
 
-typedef struct VkQueueFamilyCheckpointProperties2NV {
-    VkStructureType          sType;
-    void*                    pNext;
-    VkPipelineStageFlags2    checkpointExecutionStageMask;
-} VkQueueFamilyCheckpointProperties2NV;
-
-typedef struct VkCheckpointData2NV {
-    VkStructureType          sType;
-    void*                    pNext;
-    VkPipelineStageFlags2    stage;
-    void*                    pCheckpointMarker;
-} VkCheckpointData2NV;
-
 typedef void (VKAPI_PTR *PFN_vkCmdSetEvent2KHR)(VkCommandBuffer                   commandBuffer, VkEvent                                             event, const VkDependencyInfo*                             pDependencyInfo);
 typedef void (VKAPI_PTR *PFN_vkCmdResetEvent2KHR)(VkCommandBuffer                   commandBuffer, VkEvent                                             event, VkPipelineStageFlags2               stageMask);
 typedef void (VKAPI_PTR *PFN_vkCmdWaitEvents2KHR)(VkCommandBuffer                   commandBuffer, uint32_t                                            eventCount, const VkEvent*                     pEvents, const VkDependencyInfo*            pDependencyInfos);
 typedef void (VKAPI_PTR *PFN_vkCmdPipelineBarrier2KHR)(VkCommandBuffer                   commandBuffer, const VkDependencyInfo*                             pDependencyInfo);
 typedef void (VKAPI_PTR *PFN_vkCmdWriteTimestamp2KHR)(VkCommandBuffer                   commandBuffer, VkPipelineStageFlags2               stage, VkQueryPool                                         queryPool, uint32_t                                            query);
 typedef VkResult (VKAPI_PTR *PFN_vkQueueSubmit2KHR)(VkQueue                           queue, uint32_t                            submitCount, const VkSubmitInfo2*              pSubmits, VkFence           fence);
-typedef void (VKAPI_PTR *PFN_vkCmdWriteBufferMarker2AMD)(VkCommandBuffer                   commandBuffer, VkPipelineStageFlags2               stage, VkBuffer                                            dstBuffer, VkDeviceSize                                        dstOffset, uint32_t                                            marker);
-typedef void (VKAPI_PTR *PFN_vkGetQueueCheckpointData2NV)(VkQueue queue, uint32_t* pCheckpointDataCount, VkCheckpointData2NV* pCheckpointData);
 
 #ifndef VK_NO_PROTOTYPES
 VKAPI_ATTR void VKAPI_CALL vkCmdSetEvent2KHR(
@@ -10942,18 +11691,6 @@ VKAPI_ATTR VkResult VKAPI_CALL vkQueueSubmit2KHR(
     uint32_t                                    submitCount,
     const VkSubmitInfo2*                        pSubmits,
     VkFence                                     fence);
-
-VKAPI_ATTR void VKAPI_CALL vkCmdWriteBufferMarker2AMD(
-    VkCommandBuffer                             commandBuffer,
-    VkPipelineStageFlags2                       stage,
-    VkBuffer                                    dstBuffer,
-    VkDeviceSize                                dstOffset,
-    uint32_t                                    marker);
-
-VKAPI_ATTR void VKAPI_CALL vkGetQueueCheckpointData2NV(
-    VkQueue                                     queue,
-    uint32_t*                                   pCheckpointDataCount,
-    VkCheckpointData2NV*                        pCheckpointData);
 #endif
 
 
@@ -11164,12 +11901,7 @@ VKAPI_ATTR void VKAPI_CALL vkGetDeviceImageSparseMemoryRequirementsKHR(
 #define VK_KHR_shader_subgroup_rotate 1
 #define VK_KHR_SHADER_SUBGROUP_ROTATE_SPEC_VERSION 2
 #define VK_KHR_SHADER_SUBGROUP_ROTATE_EXTENSION_NAME "VK_KHR_shader_subgroup_rotate"
-typedef struct VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR {
-    VkStructureType    sType;
-    void*              pNext;
-    VkBool32           shaderSubgroupRotate;
-    VkBool32           shaderSubgroupRotateClustered;
-} VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR;
+typedef VkPhysicalDeviceShaderSubgroupRotateFeatures VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR;
 
 
 
@@ -11189,140 +11921,34 @@ typedef struct VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR {
 #define VK_KHR_maintenance5 1
 #define VK_KHR_MAINTENANCE_5_SPEC_VERSION 1
 #define VK_KHR_MAINTENANCE_5_EXTENSION_NAME "VK_KHR_maintenance5"
-typedef VkFlags64 VkPipelineCreateFlags2KHR;
-
-// Flag bits for VkPipelineCreateFlagBits2KHR
-typedef VkFlags64 VkPipelineCreateFlagBits2KHR;
-static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT_KHR = 0x00000001ULL;
-static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT_KHR = 0x00000002ULL;
-static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_DERIVATIVE_BIT_KHR = 0x00000004ULL;
-static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT = 0x400000000ULL;
-static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR = 0x00000008ULL;
-static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT_KHR = 0x00000010ULL;
-static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_DEFER_COMPILE_BIT_NV = 0x00000020ULL;
-static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_CAPTURE_STATISTICS_BIT_KHR = 0x00000040ULL;
-static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR = 0x00000080ULL;
-static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_KHR = 0x00000100ULL;
-static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT_KHR = 0x00000200ULL;
-static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_LINK_TIME_OPTIMIZATION_BIT_EXT = 0x00000400ULL;
-static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT = 0x00800000ULL;
-static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_LIBRARY_BIT_KHR = 0x00000800ULL;
-static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR = 0x00001000ULL;
-static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_AABBS_BIT_KHR = 0x00002000ULL;
-static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR = 0x00004000ULL;
-static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR = 0x00008000ULL;
-static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR = 0x00010000ULL;
-static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR = 0x00020000ULL;
-static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR = 0x00080000ULL;
-static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_NV = 0x00040000ULL;
-static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_MOTION_BIT_NV = 0x00100000ULL;
-static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00200000ULL;
-static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = 0x00400000ULL;
-static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT = 0x01000000ULL;
-static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 0x02000000ULL;
-static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 0x04000000ULL;
-static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT_EXT = 0x08000000ULL;
-static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT_EXT = 0x40000000ULL;
-static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV = 0x10000000ULL;
-static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_DESCRIPTOR_BUFFER_BIT_EXT = 0x20000000ULL;
-static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_CAPTURE_DATA_BIT_KHR = 0x80000000ULL;
-static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_EXT = 0x4000000000ULL;
-
-typedef VkFlags64 VkBufferUsageFlags2KHR;
-
-// Flag bits for VkBufferUsageFlagBits2KHR
-typedef VkFlags64 VkBufferUsageFlagBits2KHR;
-static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_TRANSFER_SRC_BIT_KHR = 0x00000001ULL;
-static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_TRANSFER_DST_BIT_KHR = 0x00000002ULL;
-static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR = 0x00000004ULL;
-static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT_KHR = 0x00000008ULL;
-static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_UNIFORM_BUFFER_BIT_KHR = 0x00000010ULL;
-static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_STORAGE_BUFFER_BIT_KHR = 0x00000020ULL;
-static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT_KHR = 0x00000040ULL;
-static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT_KHR = 0x00000080ULL;
-static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT_KHR = 0x00000100ULL;
-static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_EXECUTION_GRAPH_SCRATCH_BIT_AMDX = 0x02000000ULL;
-static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_CONDITIONAL_RENDERING_BIT_EXT = 0x00000200ULL;
-static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_SHADER_BINDING_TABLE_BIT_KHR = 0x00000400ULL;
-static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_RAY_TRACING_BIT_NV = 0x00000400ULL;
-static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT = 0x00000800ULL;
-static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT = 0x00001000ULL;
-static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_VIDEO_DECODE_SRC_BIT_KHR = 0x00002000ULL;
-static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_VIDEO_DECODE_DST_BIT_KHR = 0x00004000ULL;
-static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_VIDEO_ENCODE_DST_BIT_KHR = 0x00008000ULL;
-static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_VIDEO_ENCODE_SRC_BIT_KHR = 0x00010000ULL;
-static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_SHADER_DEVICE_ADDRESS_BIT_KHR = 0x00020000ULL;
-static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR = 0x00080000ULL;
-static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR = 0x00100000ULL;
-static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT = 0x00200000ULL;
-static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT = 0x00400000ULL;
-static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT = 0x04000000ULL;
-static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT = 0x00800000ULL;
-static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_MICROMAP_STORAGE_BIT_EXT = 0x01000000ULL;
-static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_PREPROCESS_BUFFER_BIT_EXT = 0x80000000ULL;
-
-typedef struct VkPhysicalDeviceMaintenance5FeaturesKHR {
-    VkStructureType    sType;
-    void*              pNext;
-    VkBool32           maintenance5;
-} VkPhysicalDeviceMaintenance5FeaturesKHR;
+typedef VkPipelineCreateFlags2 VkPipelineCreateFlags2KHR;
 
-typedef struct VkPhysicalDeviceMaintenance5PropertiesKHR {
-    VkStructureType    sType;
-    void*              pNext;
-    VkBool32           earlyFragmentMultisampleCoverageAfterSampleCounting;
-    VkBool32           earlyFragmentSampleMaskTestBeforeSampleCounting;
-    VkBool32           depthStencilSwizzleOneSupport;
-    VkBool32           polygonModePointSize;
-    VkBool32           nonStrictSinglePixelWideLinesUseParallelogram;
-    VkBool32           nonStrictWideLinesUseParallelogram;
-} VkPhysicalDeviceMaintenance5PropertiesKHR;
+typedef VkPipelineCreateFlagBits2 VkPipelineCreateFlagBits2KHR;
 
-typedef struct VkRenderingAreaInfoKHR {
-    VkStructureType    sType;
-    const void*        pNext;
-    uint32_t           viewMask;
-    uint32_t           colorAttachmentCount;
-    const VkFormat*    pColorAttachmentFormats;
-    VkFormat           depthAttachmentFormat;
-    VkFormat           stencilAttachmentFormat;
-} VkRenderingAreaInfoKHR;
+typedef VkBufferUsageFlags2 VkBufferUsageFlags2KHR;
 
-typedef struct VkImageSubresource2KHR {
-    VkStructureType       sType;
-    void*                 pNext;
-    VkImageSubresource    imageSubresource;
-} VkImageSubresource2KHR;
+typedef VkBufferUsageFlagBits2 VkBufferUsageFlagBits2KHR;
 
-typedef struct VkDeviceImageSubresourceInfoKHR {
-    VkStructureType                  sType;
-    const void*                      pNext;
-    const VkImageCreateInfo*         pCreateInfo;
-    const VkImageSubresource2KHR*    pSubresource;
-} VkDeviceImageSubresourceInfoKHR;
+typedef VkPhysicalDeviceMaintenance5Features VkPhysicalDeviceMaintenance5FeaturesKHR;
 
-typedef struct VkSubresourceLayout2KHR {
-    VkStructureType        sType;
-    void*                  pNext;
-    VkSubresourceLayout    subresourceLayout;
-} VkSubresourceLayout2KHR;
+typedef VkPhysicalDeviceMaintenance5Properties VkPhysicalDeviceMaintenance5PropertiesKHR;
 
-typedef struct VkPipelineCreateFlags2CreateInfoKHR {
-    VkStructureType              sType;
-    const void*                  pNext;
-    VkPipelineCreateFlags2KHR    flags;
-} VkPipelineCreateFlags2CreateInfoKHR;
+typedef VkRenderingAreaInfo VkRenderingAreaInfoKHR;
 
-typedef struct VkBufferUsageFlags2CreateInfoKHR {
-    VkStructureType           sType;
-    const void*               pNext;
-    VkBufferUsageFlags2KHR    usage;
-} VkBufferUsageFlags2CreateInfoKHR;
+typedef VkDeviceImageSubresourceInfo VkDeviceImageSubresourceInfoKHR;
+
+typedef VkImageSubresource2 VkImageSubresource2KHR;
+
+typedef VkSubresourceLayout2 VkSubresourceLayout2KHR;
+
+typedef VkPipelineCreateFlags2CreateInfo VkPipelineCreateFlags2CreateInfoKHR;
+
+typedef VkBufferUsageFlags2CreateInfo VkBufferUsageFlags2CreateInfoKHR;
 
 typedef void (VKAPI_PTR *PFN_vkCmdBindIndexBuffer2KHR)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkDeviceSize size, VkIndexType indexType);
-typedef void (VKAPI_PTR *PFN_vkGetRenderingAreaGranularityKHR)(VkDevice device, const VkRenderingAreaInfoKHR* pRenderingAreaInfo, VkExtent2D* pGranularity);
-typedef void (VKAPI_PTR *PFN_vkGetDeviceImageSubresourceLayoutKHR)(VkDevice device, const VkDeviceImageSubresourceInfoKHR* pInfo, VkSubresourceLayout2KHR* pLayout);
-typedef void (VKAPI_PTR *PFN_vkGetImageSubresourceLayout2KHR)(VkDevice device, VkImage image, const VkImageSubresource2KHR* pSubresource, VkSubresourceLayout2KHR* pLayout);
+typedef void (VKAPI_PTR *PFN_vkGetRenderingAreaGranularityKHR)(VkDevice device, const VkRenderingAreaInfo* pRenderingAreaInfo, VkExtent2D* pGranularity);
+typedef void (VKAPI_PTR *PFN_vkGetDeviceImageSubresourceLayoutKHR)(VkDevice device, const VkDeviceImageSubresourceInfo* pInfo, VkSubresourceLayout2* pLayout);
+typedef void (VKAPI_PTR *PFN_vkGetImageSubresourceLayout2KHR)(VkDevice device, VkImage image, const VkImageSubresource2* pSubresource, VkSubresourceLayout2* pLayout);
 
 #ifndef VK_NO_PROTOTYPES
 VKAPI_ATTR void VKAPI_CALL vkCmdBindIndexBuffer2KHR(
@@ -11334,19 +11960,19 @@ VKAPI_ATTR void VKAPI_CALL vkCmdBindIndexBuffer2KHR(
 
 VKAPI_ATTR void VKAPI_CALL vkGetRenderingAreaGranularityKHR(
     VkDevice                                    device,
-    const VkRenderingAreaInfoKHR*               pRenderingAreaInfo,
+    const VkRenderingAreaInfo*                  pRenderingAreaInfo,
     VkExtent2D*                                 pGranularity);
 
 VKAPI_ATTR void VKAPI_CALL vkGetDeviceImageSubresourceLayoutKHR(
     VkDevice                                    device,
-    const VkDeviceImageSubresourceInfoKHR*      pInfo,
-    VkSubresourceLayout2KHR*                    pLayout);
+    const VkDeviceImageSubresourceInfo*         pInfo,
+    VkSubresourceLayout2*                       pLayout);
 
 VKAPI_ATTR void VKAPI_CALL vkGetImageSubresourceLayout2KHR(
     VkDevice                                    device,
     VkImage                                     image,
-    const VkImageSubresource2KHR*               pSubresource,
-    VkSubresourceLayout2KHR*                    pLayout);
+    const VkImageSubresource2*                  pSubresource,
+    VkSubresourceLayout2*                       pLayout);
 #endif
 
 
@@ -11627,6 +12253,200 @@ typedef struct VkVideoDecodeAV1DpbSlotInfoKHR {
 
 
 
+// VK_KHR_video_encode_av1 is a preprocessor guard. Do not pass it to API calls.
+#define VK_KHR_video_encode_av1 1
+#include "vk_video/vulkan_video_codec_av1std_encode.h"
+#define VK_KHR_VIDEO_ENCODE_AV1_SPEC_VERSION 1
+#define VK_KHR_VIDEO_ENCODE_AV1_EXTENSION_NAME "VK_KHR_video_encode_av1"
+
+typedef enum VkVideoEncodeAV1PredictionModeKHR {
+    VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_INTRA_ONLY_KHR = 0,
+    VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_SINGLE_REFERENCE_KHR = 1,
+    VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_UNIDIRECTIONAL_COMPOUND_KHR = 2,
+    VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_BIDIRECTIONAL_COMPOUND_KHR = 3,
+    VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_MAX_ENUM_KHR = 0x7FFFFFFF
+} VkVideoEncodeAV1PredictionModeKHR;
+
+typedef enum VkVideoEncodeAV1RateControlGroupKHR {
+    VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_INTRA_KHR = 0,
+    VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_PREDICTIVE_KHR = 1,
+    VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_BIPREDICTIVE_KHR = 2,
+    VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_MAX_ENUM_KHR = 0x7FFFFFFF
+} VkVideoEncodeAV1RateControlGroupKHR;
+
+typedef enum VkVideoEncodeAV1CapabilityFlagBitsKHR {
+    VK_VIDEO_ENCODE_AV1_CAPABILITY_PER_RATE_CONTROL_GROUP_MIN_MAX_Q_INDEX_BIT_KHR = 0x00000001,
+    VK_VIDEO_ENCODE_AV1_CAPABILITY_GENERATE_OBU_EXTENSION_HEADER_BIT_KHR = 0x00000002,
+    VK_VIDEO_ENCODE_AV1_CAPABILITY_PRIMARY_REFERENCE_CDF_ONLY_BIT_KHR = 0x00000004,
+    VK_VIDEO_ENCODE_AV1_CAPABILITY_FRAME_SIZE_OVERRIDE_BIT_KHR = 0x00000008,
+    VK_VIDEO_ENCODE_AV1_CAPABILITY_MOTION_VECTOR_SCALING_BIT_KHR = 0x00000010,
+    VK_VIDEO_ENCODE_AV1_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
+} VkVideoEncodeAV1CapabilityFlagBitsKHR;
+typedef VkFlags VkVideoEncodeAV1CapabilityFlagsKHR;
+
+typedef enum VkVideoEncodeAV1StdFlagBitsKHR {
+    VK_VIDEO_ENCODE_AV1_STD_UNIFORM_TILE_SPACING_FLAG_SET_BIT_KHR = 0x00000001,
+    VK_VIDEO_ENCODE_AV1_STD_SKIP_MODE_PRESENT_UNSET_BIT_KHR = 0x00000002,
+    VK_VIDEO_ENCODE_AV1_STD_PRIMARY_REF_FRAME_BIT_KHR = 0x00000004,
+    VK_VIDEO_ENCODE_AV1_STD_DELTA_Q_BIT_KHR = 0x00000008,
+    VK_VIDEO_ENCODE_AV1_STD_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
+} VkVideoEncodeAV1StdFlagBitsKHR;
+typedef VkFlags VkVideoEncodeAV1StdFlagsKHR;
+
+typedef enum VkVideoEncodeAV1SuperblockSizeFlagBitsKHR {
+    VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_64_BIT_KHR = 0x00000001,
+    VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_128_BIT_KHR = 0x00000002,
+    VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
+} VkVideoEncodeAV1SuperblockSizeFlagBitsKHR;
+typedef VkFlags VkVideoEncodeAV1SuperblockSizeFlagsKHR;
+
+typedef enum VkVideoEncodeAV1RateControlFlagBitsKHR {
+    VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REGULAR_GOP_BIT_KHR = 0x00000001,
+    VK_VIDEO_ENCODE_AV1_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR = 0x00000002,
+    VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR = 0x00000004,
+    VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR = 0x00000008,
+    VK_VIDEO_ENCODE_AV1_RATE_CONTROL_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
+} VkVideoEncodeAV1RateControlFlagBitsKHR;
+typedef VkFlags VkVideoEncodeAV1RateControlFlagsKHR;
+typedef struct VkPhysicalDeviceVideoEncodeAV1FeaturesKHR {
+    VkStructureType    sType;
+    void*              pNext;
+    VkBool32           videoEncodeAV1;
+} VkPhysicalDeviceVideoEncodeAV1FeaturesKHR;
+
+typedef struct VkVideoEncodeAV1CapabilitiesKHR {
+    VkStructureType                           sType;
+    void*                                     pNext;
+    VkVideoEncodeAV1CapabilityFlagsKHR        flags;
+    StdVideoAV1Level                          maxLevel;
+    VkExtent2D                                codedPictureAlignment;
+    VkExtent2D                                maxTiles;
+    VkExtent2D                                minTileSize;
+    VkExtent2D                                maxTileSize;
+    VkVideoEncodeAV1SuperblockSizeFlagsKHR    superblockSizes;
+    uint32_t                                  maxSingleReferenceCount;
+    uint32_t                                  singleReferenceNameMask;
+    uint32_t                                  maxUnidirectionalCompoundReferenceCount;
+    uint32_t                                  maxUnidirectionalCompoundGroup1ReferenceCount;
+    uint32_t                                  unidirectionalCompoundReferenceNameMask;
+    uint32_t                                  maxBidirectionalCompoundReferenceCount;
+    uint32_t                                  maxBidirectionalCompoundGroup1ReferenceCount;
+    uint32_t                                  maxBidirectionalCompoundGroup2ReferenceCount;
+    uint32_t                                  bidirectionalCompoundReferenceNameMask;
+    uint32_t                                  maxTemporalLayerCount;
+    uint32_t                                  maxSpatialLayerCount;
+    uint32_t                                  maxOperatingPoints;
+    uint32_t                                  minQIndex;
+    uint32_t                                  maxQIndex;
+    VkBool32                                  prefersGopRemainingFrames;
+    VkBool32                                  requiresGopRemainingFrames;
+    VkVideoEncodeAV1StdFlagsKHR               stdSyntaxFlags;
+} VkVideoEncodeAV1CapabilitiesKHR;
+
+typedef struct VkVideoEncodeAV1QIndexKHR {
+    uint32_t    intraQIndex;
+    uint32_t    predictiveQIndex;
+    uint32_t    bipredictiveQIndex;
+} VkVideoEncodeAV1QIndexKHR;
+
+typedef struct VkVideoEncodeAV1QualityLevelPropertiesKHR {
+    VkStructureType                        sType;
+    void*                                  pNext;
+    VkVideoEncodeAV1RateControlFlagsKHR    preferredRateControlFlags;
+    uint32_t                               preferredGopFrameCount;
+    uint32_t                               preferredKeyFramePeriod;
+    uint32_t                               preferredConsecutiveBipredictiveFrameCount;
+    uint32_t                               preferredTemporalLayerCount;
+    VkVideoEncodeAV1QIndexKHR              preferredConstantQIndex;
+    uint32_t                               preferredMaxSingleReferenceCount;
+    uint32_t                               preferredSingleReferenceNameMask;
+    uint32_t                               preferredMaxUnidirectionalCompoundReferenceCount;
+    uint32_t                               preferredMaxUnidirectionalCompoundGroup1ReferenceCount;
+    uint32_t                               preferredUnidirectionalCompoundReferenceNameMask;
+    uint32_t                               preferredMaxBidirectionalCompoundReferenceCount;
+    uint32_t                               preferredMaxBidirectionalCompoundGroup1ReferenceCount;
+    uint32_t                               preferredMaxBidirectionalCompoundGroup2ReferenceCount;
+    uint32_t                               preferredBidirectionalCompoundReferenceNameMask;
+} VkVideoEncodeAV1QualityLevelPropertiesKHR;
+
+typedef struct VkVideoEncodeAV1SessionCreateInfoKHR {
+    VkStructureType     sType;
+    const void*         pNext;
+    VkBool32            useMaxLevel;
+    StdVideoAV1Level    maxLevel;
+} VkVideoEncodeAV1SessionCreateInfoKHR;
+
+typedef struct VkVideoEncodeAV1SessionParametersCreateInfoKHR {
+    VkStructureType                               sType;
+    const void*                                   pNext;
+    const StdVideoAV1SequenceHeader*              pStdSequenceHeader;
+    const StdVideoEncodeAV1DecoderModelInfo*      pStdDecoderModelInfo;
+    uint32_t                                      stdOperatingPointCount;
+    const StdVideoEncodeAV1OperatingPointInfo*    pStdOperatingPoints;
+} VkVideoEncodeAV1SessionParametersCreateInfoKHR;
+
+typedef struct VkVideoEncodeAV1PictureInfoKHR {
+    VkStructureType                        sType;
+    const void*                            pNext;
+    VkVideoEncodeAV1PredictionModeKHR      predictionMode;
+    VkVideoEncodeAV1RateControlGroupKHR    rateControlGroup;
+    uint32_t                               constantQIndex;
+    const StdVideoEncodeAV1PictureInfo*    pStdPictureInfo;
+    int32_t                                referenceNameSlotIndices[VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR];
+    VkBool32                               primaryReferenceCdfOnly;
+    VkBool32                               generateObuExtensionHeader;
+} VkVideoEncodeAV1PictureInfoKHR;
+
+typedef struct VkVideoEncodeAV1DpbSlotInfoKHR {
+    VkStructureType                          sType;
+    const void*                              pNext;
+    const StdVideoEncodeAV1ReferenceInfo*    pStdReferenceInfo;
+} VkVideoEncodeAV1DpbSlotInfoKHR;
+
+typedef struct VkVideoEncodeAV1ProfileInfoKHR {
+    VkStructureType       sType;
+    const void*           pNext;
+    StdVideoAV1Profile    stdProfile;
+} VkVideoEncodeAV1ProfileInfoKHR;
+
+typedef struct VkVideoEncodeAV1FrameSizeKHR {
+    uint32_t    intraFrameSize;
+    uint32_t    predictiveFrameSize;
+    uint32_t    bipredictiveFrameSize;
+} VkVideoEncodeAV1FrameSizeKHR;
+
+typedef struct VkVideoEncodeAV1GopRemainingFrameInfoKHR {
+    VkStructureType    sType;
+    const void*        pNext;
+    VkBool32           useGopRemainingFrames;
+    uint32_t           gopRemainingIntra;
+    uint32_t           gopRemainingPredictive;
+    uint32_t           gopRemainingBipredictive;
+} VkVideoEncodeAV1GopRemainingFrameInfoKHR;
+
+typedef struct VkVideoEncodeAV1RateControlInfoKHR {
+    VkStructureType                        sType;
+    const void*                            pNext;
+    VkVideoEncodeAV1RateControlFlagsKHR    flags;
+    uint32_t                               gopFrameCount;
+    uint32_t                               keyFramePeriod;
+    uint32_t                               consecutiveBipredictiveFrameCount;
+    uint32_t                               temporalLayerCount;
+} VkVideoEncodeAV1RateControlInfoKHR;
+
+typedef struct VkVideoEncodeAV1RateControlLayerInfoKHR {
+    VkStructureType                 sType;
+    const void*                     pNext;
+    VkBool32                        useMinQIndex;
+    VkVideoEncodeAV1QIndexKHR       minQIndex;
+    VkBool32                        useMaxQIndex;
+    VkVideoEncodeAV1QIndexKHR       maxQIndex;
+    VkBool32                        useMaxFrameSize;
+    VkVideoEncodeAV1FrameSizeKHR    maxFrameSize;
+} VkVideoEncodeAV1RateControlLayerInfoKHR;
+
+
+
 // VK_KHR_video_maintenance1 is a preprocessor guard. Do not pass it to API calls.
 #define VK_KHR_video_maintenance1 1
 #define VK_KHR_VIDEO_MAINTENANCE_1_SPEC_VERSION 1
@@ -11651,31 +12471,13 @@ typedef struct VkVideoInlineQueryInfoKHR {
 #define VK_KHR_vertex_attribute_divisor 1
 #define VK_KHR_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION 1
 #define VK_KHR_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME "VK_KHR_vertex_attribute_divisor"
-typedef struct VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR {
-    VkStructureType    sType;
-    void*              pNext;
-    uint32_t           maxVertexAttribDivisor;
-    VkBool32           supportsNonZeroFirstInstance;
-} VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR;
+typedef VkPhysicalDeviceVertexAttributeDivisorProperties VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR;
 
-typedef struct VkVertexInputBindingDivisorDescriptionKHR {
-    uint32_t    binding;
-    uint32_t    divisor;
-} VkVertexInputBindingDivisorDescriptionKHR;
+typedef VkVertexInputBindingDivisorDescription VkVertexInputBindingDivisorDescriptionKHR;
 
-typedef struct VkPipelineVertexInputDivisorStateCreateInfoKHR {
-    VkStructureType                                     sType;
-    const void*                                         pNext;
-    uint32_t                                            vertexBindingDivisorCount;
-    const VkVertexInputBindingDivisorDescriptionKHR*    pVertexBindingDivisors;
-} VkPipelineVertexInputDivisorStateCreateInfoKHR;
+typedef VkPipelineVertexInputDivisorStateCreateInfo VkPipelineVertexInputDivisorStateCreateInfoKHR;
 
-typedef struct VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR {
-    VkStructureType    sType;
-    void*              pNext;
-    VkBool32           vertexAttributeInstanceRateDivisor;
-    VkBool32           vertexAttributeInstanceRateZeroDivisor;
-} VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR;
+typedef VkPhysicalDeviceVertexAttributeDivisorFeatures VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR;
 
 
 
@@ -11689,11 +12491,7 @@ typedef struct VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR {
 #define VK_KHR_shader_float_controls2 1
 #define VK_KHR_SHADER_FLOAT_CONTROLS_2_SPEC_VERSION 1
 #define VK_KHR_SHADER_FLOAT_CONTROLS_2_EXTENSION_NAME "VK_KHR_shader_float_controls2"
-typedef struct VkPhysicalDeviceShaderFloatControls2FeaturesKHR {
-    VkStructureType    sType;
-    void*              pNext;
-    VkBool32           shaderFloatControls2;
-} VkPhysicalDeviceShaderFloatControls2FeaturesKHR;
+typedef VkPhysicalDeviceShaderFloatControls2Features VkPhysicalDeviceShaderFloatControls2FeaturesKHR;
 
 
 
@@ -11701,11 +12499,7 @@ typedef struct VkPhysicalDeviceShaderFloatControls2FeaturesKHR {
 #define VK_KHR_index_type_uint8 1
 #define VK_KHR_INDEX_TYPE_UINT8_SPEC_VERSION 1
 #define VK_KHR_INDEX_TYPE_UINT8_EXTENSION_NAME "VK_KHR_index_type_uint8"
-typedef struct VkPhysicalDeviceIndexTypeUint8FeaturesKHR {
-    VkStructureType    sType;
-    void*              pNext;
-    VkBool32           indexTypeUint8;
-} VkPhysicalDeviceIndexTypeUint8FeaturesKHR;
+typedef VkPhysicalDeviceIndexTypeUint8Features VkPhysicalDeviceIndexTypeUint8FeaturesKHR;
 
 
 
@@ -11713,43 +12507,13 @@ typedef struct VkPhysicalDeviceIndexTypeUint8FeaturesKHR {
 #define VK_KHR_line_rasterization 1
 #define VK_KHR_LINE_RASTERIZATION_SPEC_VERSION 1
 #define VK_KHR_LINE_RASTERIZATION_EXTENSION_NAME "VK_KHR_line_rasterization"
+typedef VkLineRasterizationMode VkLineRasterizationModeKHR;
 
-typedef enum VkLineRasterizationModeKHR {
-    VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR = 0,
-    VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR = 1,
-    VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR = 2,
-    VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR = 3,
-    VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT = VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR,
-    VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT = VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR,
-    VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT = VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR,
-    VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT = VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR,
-    VK_LINE_RASTERIZATION_MODE_MAX_ENUM_KHR = 0x7FFFFFFF
-} VkLineRasterizationModeKHR;
-typedef struct VkPhysicalDeviceLineRasterizationFeaturesKHR {
-    VkStructureType    sType;
-    void*              pNext;
-    VkBool32           rectangularLines;
-    VkBool32           bresenhamLines;
-    VkBool32           smoothLines;
-    VkBool32           stippledRectangularLines;
-    VkBool32           stippledBresenhamLines;
-    VkBool32           stippledSmoothLines;
-} VkPhysicalDeviceLineRasterizationFeaturesKHR;
+typedef VkPhysicalDeviceLineRasterizationFeatures VkPhysicalDeviceLineRasterizationFeaturesKHR;
 
-typedef struct VkPhysicalDeviceLineRasterizationPropertiesKHR {
-    VkStructureType    sType;
-    void*              pNext;
-    uint32_t           lineSubPixelPrecisionBits;
-} VkPhysicalDeviceLineRasterizationPropertiesKHR;
+typedef VkPhysicalDeviceLineRasterizationProperties VkPhysicalDeviceLineRasterizationPropertiesKHR;
 
-typedef struct VkPipelineRasterizationLineStateCreateInfoKHR {
-    VkStructureType               sType;
-    const void*                   pNext;
-    VkLineRasterizationModeKHR    lineRasterizationMode;
-    VkBool32                      stippledLineEnable;
-    uint32_t                      lineStippleFactor;
-    uint16_t                      lineStipplePattern;
-} VkPipelineRasterizationLineStateCreateInfoKHR;
+typedef VkPipelineRasterizationLineStateCreateInfo VkPipelineRasterizationLineStateCreateInfoKHR;
 
 typedef void (VKAPI_PTR *PFN_vkCmdSetLineStippleKHR)(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern);
 
@@ -11805,11 +12569,7 @@ VKAPI_ATTR VkResult VKAPI_CALL vkGetCalibratedTimestampsKHR(
 #define VK_KHR_shader_expect_assume 1
 #define VK_KHR_SHADER_EXPECT_ASSUME_SPEC_VERSION 1
 #define VK_KHR_SHADER_EXPECT_ASSUME_EXTENSION_NAME "VK_KHR_shader_expect_assume"
-typedef struct VkPhysicalDeviceShaderExpectAssumeFeaturesKHR {
-    VkStructureType    sType;
-    void*              pNext;
-    VkBool32           shaderExpectAssume;
-} VkPhysicalDeviceShaderExpectAssumeFeaturesKHR;
+typedef VkPhysicalDeviceShaderExpectAssumeFeatures VkPhysicalDeviceShaderExpectAssumeFeaturesKHR;
 
 
 
@@ -11817,66 +12577,19 @@ typedef struct VkPhysicalDeviceShaderExpectAssumeFeaturesKHR {
 #define VK_KHR_maintenance6 1
 #define VK_KHR_MAINTENANCE_6_SPEC_VERSION 1
 #define VK_KHR_MAINTENANCE_6_EXTENSION_NAME "VK_KHR_maintenance6"
-typedef struct VkPhysicalDeviceMaintenance6FeaturesKHR {
-    VkStructureType    sType;
-    void*              pNext;
-    VkBool32           maintenance6;
-} VkPhysicalDeviceMaintenance6FeaturesKHR;
+typedef VkPhysicalDeviceMaintenance6Features VkPhysicalDeviceMaintenance6FeaturesKHR;
 
-typedef struct VkPhysicalDeviceMaintenance6PropertiesKHR {
-    VkStructureType    sType;
-    void*              pNext;
-    VkBool32           blockTexelViewCompatibleMultipleLayers;
-    uint32_t           maxCombinedImageSamplerDescriptorCount;
-    VkBool32           fragmentShadingRateClampCombinerInputs;
-} VkPhysicalDeviceMaintenance6PropertiesKHR;
+typedef VkPhysicalDeviceMaintenance6Properties VkPhysicalDeviceMaintenance6PropertiesKHR;
 
-typedef struct VkBindMemoryStatusKHR {
-    VkStructureType    sType;
-    const void*        pNext;
-    VkResult*          pResult;
-} VkBindMemoryStatusKHR;
+typedef VkBindMemoryStatus VkBindMemoryStatusKHR;
 
-typedef struct VkBindDescriptorSetsInfoKHR {
-    VkStructureType           sType;
-    const void*               pNext;
-    VkShaderStageFlags        stageFlags;
-    VkPipelineLayout          layout;
-    uint32_t                  firstSet;
-    uint32_t                  descriptorSetCount;
-    const VkDescriptorSet*    pDescriptorSets;
-    uint32_t                  dynamicOffsetCount;
-    const uint32_t*           pDynamicOffsets;
-} VkBindDescriptorSetsInfoKHR;
+typedef VkBindDescriptorSetsInfo VkBindDescriptorSetsInfoKHR;
 
-typedef struct VkPushConstantsInfoKHR {
-    VkStructureType       sType;
-    const void*           pNext;
-    VkPipelineLayout      layout;
-    VkShaderStageFlags    stageFlags;
-    uint32_t              offset;
-    uint32_t              size;
-    const void*           pValues;
-} VkPushConstantsInfoKHR;
+typedef VkPushConstantsInfo VkPushConstantsInfoKHR;
 
-typedef struct VkPushDescriptorSetInfoKHR {
-    VkStructureType                sType;
-    const void*                    pNext;
-    VkShaderStageFlags             stageFlags;
-    VkPipelineLayout               layout;
-    uint32_t                       set;
-    uint32_t                       descriptorWriteCount;
-    const VkWriteDescriptorSet*    pDescriptorWrites;
-} VkPushDescriptorSetInfoKHR;
+typedef VkPushDescriptorSetInfo VkPushDescriptorSetInfoKHR;
 
-typedef struct VkPushDescriptorSetWithTemplateInfoKHR {
-    VkStructureType               sType;
-    const void*                   pNext;
-    VkDescriptorUpdateTemplate    descriptorUpdateTemplate;
-    VkPipelineLayout              layout;
-    uint32_t                      set;
-    const void*                   pData;
-} VkPushDescriptorSetWithTemplateInfoKHR;
+typedef VkPushDescriptorSetWithTemplateInfo VkPushDescriptorSetWithTemplateInfoKHR;
 
 typedef struct VkSetDescriptorBufferOffsetsInfoEXT {
     VkStructureType        sType;
@@ -11897,29 +12610,29 @@ typedef struct VkBindDescriptorBufferEmbeddedSamplersInfoEXT {
     uint32_t              set;
 } VkBindDescriptorBufferEmbeddedSamplersInfoEXT;
 
-typedef void (VKAPI_PTR *PFN_vkCmdBindDescriptorSets2KHR)(VkCommandBuffer commandBuffer, const VkBindDescriptorSetsInfoKHR* pBindDescriptorSetsInfo);
-typedef void (VKAPI_PTR *PFN_vkCmdPushConstants2KHR)(VkCommandBuffer commandBuffer, const VkPushConstantsInfoKHR* pPushConstantsInfo);
-typedef void (VKAPI_PTR *PFN_vkCmdPushDescriptorSet2KHR)(VkCommandBuffer commandBuffer, const VkPushDescriptorSetInfoKHR* pPushDescriptorSetInfo);
-typedef void (VKAPI_PTR *PFN_vkCmdPushDescriptorSetWithTemplate2KHR)(VkCommandBuffer commandBuffer, const VkPushDescriptorSetWithTemplateInfoKHR* pPushDescriptorSetWithTemplateInfo);
+typedef void (VKAPI_PTR *PFN_vkCmdBindDescriptorSets2KHR)(VkCommandBuffer commandBuffer, const VkBindDescriptorSetsInfo*   pBindDescriptorSetsInfo);
+typedef void (VKAPI_PTR *PFN_vkCmdPushConstants2KHR)(VkCommandBuffer commandBuffer, const VkPushConstantsInfo*        pPushConstantsInfo);
+typedef void (VKAPI_PTR *PFN_vkCmdPushDescriptorSet2KHR)(VkCommandBuffer commandBuffer, const VkPushDescriptorSetInfo*    pPushDescriptorSetInfo);
+typedef void (VKAPI_PTR *PFN_vkCmdPushDescriptorSetWithTemplate2KHR)(VkCommandBuffer commandBuffer, const VkPushDescriptorSetWithTemplateInfo* pPushDescriptorSetWithTemplateInfo);
 typedef void (VKAPI_PTR *PFN_vkCmdSetDescriptorBufferOffsets2EXT)(VkCommandBuffer commandBuffer, const VkSetDescriptorBufferOffsetsInfoEXT* pSetDescriptorBufferOffsetsInfo);
 typedef void (VKAPI_PTR *PFN_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT)(VkCommandBuffer commandBuffer, const VkBindDescriptorBufferEmbeddedSamplersInfoEXT* pBindDescriptorBufferEmbeddedSamplersInfo);
 
 #ifndef VK_NO_PROTOTYPES
 VKAPI_ATTR void VKAPI_CALL vkCmdBindDescriptorSets2KHR(
     VkCommandBuffer                             commandBuffer,
-    const VkBindDescriptorSetsInfoKHR*          pBindDescriptorSetsInfo);
+    const VkBindDescriptorSetsInfo*             pBindDescriptorSetsInfo);
 
 VKAPI_ATTR void VKAPI_CALL vkCmdPushConstants2KHR(
     VkCommandBuffer                             commandBuffer,
-    const VkPushConstantsInfoKHR*               pPushConstantsInfo);
+    const VkPushConstantsInfo*                  pPushConstantsInfo);
 
 VKAPI_ATTR void VKAPI_CALL vkCmdPushDescriptorSet2KHR(
     VkCommandBuffer                             commandBuffer,
-    const VkPushDescriptorSetInfoKHR*           pPushDescriptorSetInfo);
+    const VkPushDescriptorSetInfo*              pPushDescriptorSetInfo);
 
 VKAPI_ATTR void VKAPI_CALL vkCmdPushDescriptorSetWithTemplate2KHR(
     VkCommandBuffer                             commandBuffer,
-    const VkPushDescriptorSetWithTemplateInfoKHR* pPushDescriptorSetWithTemplateInfo);
+    const VkPushDescriptorSetWithTemplateInfo*  pPushDescriptorSetWithTemplateInfo);
 
 VKAPI_ATTR void VKAPI_CALL vkCmdSetDescriptorBufferOffsets2EXT(
     VkCommandBuffer                             commandBuffer,
@@ -11931,6 +12644,76 @@ VKAPI_ATTR void VKAPI_CALL vkCmdBindDescriptorBufferEmbeddedSamplers2EXT(
 #endif
 
 
+// VK_KHR_video_encode_quantization_map is a preprocessor guard. Do not pass it to API calls.
+#define VK_KHR_video_encode_quantization_map 1
+#define VK_KHR_VIDEO_ENCODE_QUANTIZATION_MAP_SPEC_VERSION 2
+#define VK_KHR_VIDEO_ENCODE_QUANTIZATION_MAP_EXTENSION_NAME "VK_KHR_video_encode_quantization_map"
+typedef struct VkVideoEncodeQuantizationMapCapabilitiesKHR {
+    VkStructureType    sType;
+    void*              pNext;
+    VkExtent2D         maxQuantizationMapExtent;
+} VkVideoEncodeQuantizationMapCapabilitiesKHR;
+
+typedef struct VkVideoFormatQuantizationMapPropertiesKHR {
+    VkStructureType    sType;
+    void*              pNext;
+    VkExtent2D         quantizationMapTexelSize;
+} VkVideoFormatQuantizationMapPropertiesKHR;
+
+typedef struct VkVideoEncodeQuantizationMapInfoKHR {
+    VkStructureType    sType;
+    const void*        pNext;
+    VkImageView        quantizationMap;
+    VkExtent2D         quantizationMapExtent;
+} VkVideoEncodeQuantizationMapInfoKHR;
+
+typedef struct VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR {
+    VkStructureType    sType;
+    const void*        pNext;
+    VkExtent2D         quantizationMapTexelSize;
+} VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR;
+
+typedef struct VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR {
+    VkStructureType    sType;
+    void*              pNext;
+    VkBool32           videoEncodeQuantizationMap;
+} VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR;
+
+typedef struct VkVideoEncodeH264QuantizationMapCapabilitiesKHR {
+    VkStructureType    sType;
+    void*              pNext;
+    int32_t            minQpDelta;
+    int32_t            maxQpDelta;
+} VkVideoEncodeH264QuantizationMapCapabilitiesKHR;
+
+typedef struct VkVideoEncodeH265QuantizationMapCapabilitiesKHR {
+    VkStructureType    sType;
+    void*              pNext;
+    int32_t            minQpDelta;
+    int32_t            maxQpDelta;
+} VkVideoEncodeH265QuantizationMapCapabilitiesKHR;
+
+typedef struct VkVideoFormatH265QuantizationMapPropertiesKHR {
+    VkStructureType                     sType;
+    void*                               pNext;
+    VkVideoEncodeH265CtbSizeFlagsKHR    compatibleCtbSizes;
+} VkVideoFormatH265QuantizationMapPropertiesKHR;
+
+typedef struct VkVideoEncodeAV1QuantizationMapCapabilitiesKHR {
+    VkStructureType    sType;
+    void*              pNext;
+    int32_t            minQIndexDelta;
+    int32_t            maxQIndexDelta;
+} VkVideoEncodeAV1QuantizationMapCapabilitiesKHR;
+
+typedef struct VkVideoFormatAV1QuantizationMapPropertiesKHR {
+    VkStructureType                           sType;
+    void*                                     pNext;
+    VkVideoEncodeAV1SuperblockSizeFlagsKHR    compatibleSuperblockSizes;
+} VkVideoFormatAV1QuantizationMapPropertiesKHR;
+
+
+
 // VK_KHR_shader_relaxed_extended_instruction is a preprocessor guard. Do not pass it to API calls.
 #define VK_KHR_shader_relaxed_extended_instruction 1
 #define VK_KHR_SHADER_RELAXED_EXTENDED_INSTRUCTION_SPEC_VERSION 1
@@ -12339,7 +13122,7 @@ VKAPI_ATTR void VKAPI_CALL vkCmdDrawIndirectByteCountEXT(
 #define VK_NVX_binary_import 1
 VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkCuModuleNVX)
 VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkCuFunctionNVX)
-#define VK_NVX_BINARY_IMPORT_SPEC_VERSION 1
+#define VK_NVX_BINARY_IMPORT_SPEC_VERSION 2
 #define VK_NVX_BINARY_IMPORT_EXTENSION_NAME "VK_NVX_binary_import"
 typedef struct VkCuModuleCreateInfoNVX {
     VkStructureType    sType;
@@ -12348,6 +13131,12 @@ typedef struct VkCuModuleCreateInfoNVX {
     const void*        pData;
 } VkCuModuleCreateInfoNVX;
 
+typedef struct VkCuModuleTexturingModeCreateInfoNVX {
+    VkStructureType    sType;
+    const void*        pNext;
+    VkBool32           use64bitTexturing;
+} VkCuModuleTexturingModeCreateInfoNVX;
+
 typedef struct VkCuFunctionCreateInfoNVX {
     VkStructureType    sType;
     const void*        pNext;
@@ -12409,7 +13198,7 @@ VKAPI_ATTR void VKAPI_CALL vkCmdCuLaunchKernelNVX(
 
 // VK_NVX_image_view_handle is a preprocessor guard. Do not pass it to API calls.
 #define VK_NVX_image_view_handle 1
-#define VK_NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION 2
+#define VK_NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION 3
 #define VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME "VK_NVX_image_view_handle"
 typedef struct VkImageViewHandleInfoNVX {
     VkStructureType     sType;
@@ -12427,6 +13216,7 @@ typedef struct VkImageViewAddressPropertiesNVX {
 } VkImageViewAddressPropertiesNVX;
 
 typedef uint32_t (VKAPI_PTR *PFN_vkGetImageViewHandleNVX)(VkDevice device, const VkImageViewHandleInfoNVX* pInfo);
+typedef uint64_t (VKAPI_PTR *PFN_vkGetImageViewHandle64NVX)(VkDevice device, const VkImageViewHandleInfoNVX* pInfo);
 typedef VkResult (VKAPI_PTR *PFN_vkGetImageViewAddressNVX)(VkDevice device, VkImageView imageView, VkImageViewAddressPropertiesNVX* pProperties);
 
 #ifndef VK_NO_PROTOTYPES
@@ -12434,6 +13224,10 @@ VKAPI_ATTR uint32_t VKAPI_CALL vkGetImageViewHandleNVX(
     VkDevice                                    device,
     const VkImageViewHandleInfoNVX*             pInfo);
 
+VKAPI_ATTR uint64_t VKAPI_CALL vkGetImageViewHandle64NVX(
+    VkDevice                                    device,
+    const VkImageViewHandleInfoNVX*             pInfo);
+
 VKAPI_ATTR VkResult VKAPI_CALL vkGetImageViewAddressNVX(
     VkDevice                                    device,
     VkImageView                                 imageView,
@@ -12687,45 +13481,15 @@ typedef struct VkPhysicalDeviceASTCDecodeFeaturesEXT {
 #define VK_EXT_pipeline_robustness 1
 #define VK_EXT_PIPELINE_ROBUSTNESS_SPEC_VERSION 1
 #define VK_EXT_PIPELINE_ROBUSTNESS_EXTENSION_NAME "VK_EXT_pipeline_robustness"
+typedef VkPipelineRobustnessBufferBehavior VkPipelineRobustnessBufferBehaviorEXT;
 
-typedef enum VkPipelineRobustnessBufferBehaviorEXT {
-    VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT = 0,
-    VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED_EXT = 1,
-    VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT = 2,
-    VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT = 3,
-    VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_MAX_ENUM_EXT = 0x7FFFFFFF
-} VkPipelineRobustnessBufferBehaviorEXT;
+typedef VkPipelineRobustnessImageBehavior VkPipelineRobustnessImageBehaviorEXT;
 
-typedef enum VkPipelineRobustnessImageBehaviorEXT {
-    VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT_EXT = 0,
-    VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED_EXT = 1,
-    VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_EXT = 2,
-    VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2_EXT = 3,
-    VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_MAX_ENUM_EXT = 0x7FFFFFFF
-} VkPipelineRobustnessImageBehaviorEXT;
-typedef struct VkPhysicalDevicePipelineRobustnessFeaturesEXT {
-    VkStructureType    sType;
-    void*              pNext;
-    VkBool32           pipelineRobustness;
-} VkPhysicalDevicePipelineRobustnessFeaturesEXT;
+typedef VkPhysicalDevicePipelineRobustnessFeatures VkPhysicalDevicePipelineRobustnessFeaturesEXT;
 
-typedef struct VkPhysicalDevicePipelineRobustnessPropertiesEXT {
-    VkStructureType                          sType;
-    void*                                    pNext;
-    VkPipelineRobustnessBufferBehaviorEXT    defaultRobustnessStorageBuffers;
-    VkPipelineRobustnessBufferBehaviorEXT    defaultRobustnessUniformBuffers;
-    VkPipelineRobustnessBufferBehaviorEXT    defaultRobustnessVertexInputs;
-    VkPipelineRobustnessImageBehaviorEXT     defaultRobustnessImages;
-} VkPhysicalDevicePipelineRobustnessPropertiesEXT;
-
-typedef struct VkPipelineRobustnessCreateInfoEXT {
-    VkStructureType                          sType;
-    const void*                              pNext;
-    VkPipelineRobustnessBufferBehaviorEXT    storageBuffers;
-    VkPipelineRobustnessBufferBehaviorEXT    uniformBuffers;
-    VkPipelineRobustnessBufferBehaviorEXT    vertexInputs;
-    VkPipelineRobustnessImageBehaviorEXT     images;
-} VkPipelineRobustnessCreateInfoEXT;
+typedef VkPhysicalDevicePipelineRobustnessProperties VkPhysicalDevicePipelineRobustnessPropertiesEXT;
+
+typedef VkPipelineRobustnessCreateInfo VkPipelineRobustnessCreateInfoEXT;
 
 
 
@@ -13006,6 +13770,13 @@ typedef struct VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
     VkBool32           perViewPositionAllComponents;
 } VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX;
 
+typedef struct VkMultiviewPerViewAttributesInfoNVX {
+    VkStructureType    sType;
+    const void*        pNext;
+    VkBool32           perViewAttributes;
+    VkBool32           perViewAttributesPositionXOnly;
+} VkMultiviewPerViewAttributesInfoNVX;
+
 
 
 // VK_NV_viewport_swizzle is a preprocessor guard. Do not pass it to API calls.
@@ -13374,6 +14145,14 @@ typedef VkPhysicalDeviceSamplerFilterMinmaxProperties VkPhysicalDeviceSamplerFil
 #define VK_AMD_mixed_attachment_samples 1
 #define VK_AMD_MIXED_ATTACHMENT_SAMPLES_SPEC_VERSION 1
 #define VK_AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME "VK_AMD_mixed_attachment_samples"
+typedef struct VkAttachmentSampleCountInfoAMD {
+    VkStructureType                 sType;
+    const void*                     pNext;
+    uint32_t                        colorAttachmentCount;
+    const VkSampleCountFlagBits*    pColorAttachmentSamples;
+    VkSampleCountFlagBits           depthStencilAttachmentSamples;
+} VkAttachmentSampleCountInfoAMD;
+
 
 
 // VK_AMD_shader_fragment_mask is a preprocessor guard. Do not pass it to API calls.
@@ -13553,6 +14332,8 @@ typedef struct VkPipelineCoverageModulationStateCreateInfoNV {
     const float*                                      pCoverageModulationTable;
 } VkPipelineCoverageModulationStateCreateInfoNV;
 
+typedef VkAttachmentSampleCountInfoAMD VkAttachmentSampleCountInfoNV;
+
 
 
 // VK_NV_fill_rectangle is a preprocessor guard. Do not pass it to API calls.
@@ -14265,9 +15046,9 @@ typedef struct VkFilterCubicImageViewImageFormatPropertiesEXT {
 #define VK_EXT_global_priority 1
 #define VK_EXT_GLOBAL_PRIORITY_SPEC_VERSION 2
 #define VK_EXT_GLOBAL_PRIORITY_EXTENSION_NAME "VK_EXT_global_priority"
-typedef VkQueueGlobalPriorityKHR VkQueueGlobalPriorityEXT;
+typedef VkQueueGlobalPriority VkQueueGlobalPriorityEXT;
 
-typedef VkDeviceQueueGlobalPriorityCreateInfoKHR VkDeviceQueueGlobalPriorityCreateInfoEXT;
+typedef VkDeviceQueueGlobalPriorityCreateInfo VkDeviceQueueGlobalPriorityCreateInfoEXT;
 
 
 
@@ -14310,6 +15091,7 @@ VKAPI_ATTR VkResult VKAPI_CALL vkGetMemoryHostPointerPropertiesEXT(
 #define VK_AMD_BUFFER_MARKER_SPEC_VERSION 1
 #define VK_AMD_BUFFER_MARKER_EXTENSION_NAME "VK_AMD_buffer_marker"
 typedef void (VKAPI_PTR *PFN_vkCmdWriteBufferMarkerAMD)(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker);
+typedef void (VKAPI_PTR *PFN_vkCmdWriteBufferMarker2AMD)(VkCommandBuffer                   commandBuffer, VkPipelineStageFlags2               stage, VkBuffer                                            dstBuffer, VkDeviceSize                                        dstOffset, uint32_t                                            marker);
 
 #ifndef VK_NO_PROTOTYPES
 VKAPI_ATTR void VKAPI_CALL vkCmdWriteBufferMarkerAMD(
@@ -14318,6 +15100,13 @@ VKAPI_ATTR void VKAPI_CALL vkCmdWriteBufferMarkerAMD(
     VkBuffer                                    dstBuffer,
     VkDeviceSize                                dstOffset,
     uint32_t                                    marker);
+
+VKAPI_ATTR void VKAPI_CALL vkCmdWriteBufferMarker2AMD(
+    VkCommandBuffer                             commandBuffer,
+    VkPipelineStageFlags2                       stage,
+    VkBuffer                                    dstBuffer,
+    VkDeviceSize                                dstOffset,
+    uint32_t                                    marker);
 #endif
 
 
@@ -14418,11 +15207,11 @@ typedef struct VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT {
     uint32_t           maxVertexAttribDivisor;
 } VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT;
 
-typedef VkVertexInputBindingDivisorDescriptionKHR VkVertexInputBindingDivisorDescriptionEXT;
+typedef VkVertexInputBindingDivisorDescription VkVertexInputBindingDivisorDescriptionEXT;
 
-typedef VkPipelineVertexInputDivisorStateCreateInfoKHR VkPipelineVertexInputDivisorStateCreateInfoEXT;
+typedef VkPipelineVertexInputDivisorStateCreateInfo VkPipelineVertexInputDivisorStateCreateInfoEXT;
 
-typedef VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT;
+typedef VkPhysicalDeviceVertexAttributeDivisorFeatures VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT;
 
 
 
@@ -14588,8 +15377,22 @@ typedef struct VkCheckpointDataNV {
     void*                      pCheckpointMarker;
 } VkCheckpointDataNV;
 
+typedef struct VkQueueFamilyCheckpointProperties2NV {
+    VkStructureType          sType;
+    void*                    pNext;
+    VkPipelineStageFlags2    checkpointExecutionStageMask;
+} VkQueueFamilyCheckpointProperties2NV;
+
+typedef struct VkCheckpointData2NV {
+    VkStructureType          sType;
+    void*                    pNext;
+    VkPipelineStageFlags2    stage;
+    void*                    pCheckpointMarker;
+} VkCheckpointData2NV;
+
 typedef void (VKAPI_PTR *PFN_vkCmdSetCheckpointNV)(VkCommandBuffer commandBuffer, const void* pCheckpointMarker);
 typedef void (VKAPI_PTR *PFN_vkGetQueueCheckpointDataNV)(VkQueue queue, uint32_t* pCheckpointDataCount, VkCheckpointDataNV* pCheckpointData);
+typedef void (VKAPI_PTR *PFN_vkGetQueueCheckpointData2NV)(VkQueue queue, uint32_t* pCheckpointDataCount, VkCheckpointData2NV* pCheckpointData);
 
 #ifndef VK_NO_PROTOTYPES
 VKAPI_ATTR void VKAPI_CALL vkCmdSetCheckpointNV(
@@ -14600,6 +15403,11 @@ VKAPI_ATTR void VKAPI_CALL vkGetQueueCheckpointDataNV(
     VkQueue                                     queue,
     uint32_t*                                   pCheckpointDataCount,
     VkCheckpointDataNV*                         pCheckpointData);
+
+VKAPI_ATTR void VKAPI_CALL vkGetQueueCheckpointData2NV(
+    VkQueue                                     queue,
+    uint32_t*                                   pCheckpointDataCount,
+    VkCheckpointData2NV*                        pCheckpointData);
 #endif
 
 
@@ -14821,6 +15629,13 @@ typedef struct VkRenderPassFragmentDensityMapCreateInfoEXT {
     VkAttachmentReference    fragmentDensityMapAttachment;
 } VkRenderPassFragmentDensityMapCreateInfoEXT;
 
+typedef struct VkRenderingFragmentDensityMapAttachmentInfoEXT {
+    VkStructureType    sType;
+    const void*        pNext;
+    VkImageView        imageView;
+    VkImageLayout      imageLayout;
+} VkRenderingFragmentDensityMapAttachmentInfoEXT;
+
 
 
 // VK_EXT_scalar_block_layout is a preprocessor guard. Do not pass it to API calls.
@@ -15211,13 +16026,13 @@ VKAPI_ATTR VkResult VKAPI_CALL vkCreateHeadlessSurfaceEXT(
 #define VK_EXT_line_rasterization 1
 #define VK_EXT_LINE_RASTERIZATION_SPEC_VERSION 1
 #define VK_EXT_LINE_RASTERIZATION_EXTENSION_NAME "VK_EXT_line_rasterization"
-typedef VkLineRasterizationModeKHR VkLineRasterizationModeEXT;
+typedef VkLineRasterizationMode VkLineRasterizationModeEXT;
 
-typedef VkPhysicalDeviceLineRasterizationFeaturesKHR VkPhysicalDeviceLineRasterizationFeaturesEXT;
+typedef VkPhysicalDeviceLineRasterizationFeatures VkPhysicalDeviceLineRasterizationFeaturesEXT;
 
-typedef VkPhysicalDeviceLineRasterizationPropertiesKHR VkPhysicalDeviceLineRasterizationPropertiesEXT;
+typedef VkPhysicalDeviceLineRasterizationProperties VkPhysicalDeviceLineRasterizationPropertiesEXT;
 
-typedef VkPipelineRasterizationLineStateCreateInfoKHR VkPipelineRasterizationLineStateCreateInfoEXT;
+typedef VkPipelineRasterizationLineStateCreateInfo VkPipelineRasterizationLineStateCreateInfoEXT;
 
 typedef void (VKAPI_PTR *PFN_vkCmdSetLineStippleEXT)(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern);
 
@@ -15273,7 +16088,7 @@ VKAPI_ATTR void VKAPI_CALL vkResetQueryPoolEXT(
 #define VK_EXT_index_type_uint8 1
 #define VK_EXT_INDEX_TYPE_UINT8_SPEC_VERSION 1
 #define VK_EXT_INDEX_TYPE_UINT8_EXTENSION_NAME "VK_EXT_index_type_uint8"
-typedef VkPhysicalDeviceIndexTypeUint8FeaturesKHR VkPhysicalDeviceIndexTypeUint8FeaturesEXT;
+typedef VkPhysicalDeviceIndexTypeUint8Features VkPhysicalDeviceIndexTypeUint8FeaturesEXT;
 
 
 
@@ -15366,138 +16181,63 @@ VKAPI_ATTR void VKAPI_CALL vkCmdSetStencilOpEXT(
 #define VK_EXT_host_image_copy 1
 #define VK_EXT_HOST_IMAGE_COPY_SPEC_VERSION 1
 #define VK_EXT_HOST_IMAGE_COPY_EXTENSION_NAME "VK_EXT_host_image_copy"
+typedef VkHostImageCopyFlagBits VkHostImageCopyFlagBitsEXT;
 
-typedef enum VkHostImageCopyFlagBitsEXT {
-    VK_HOST_IMAGE_COPY_MEMCPY_EXT = 0x00000001,
-    VK_HOST_IMAGE_COPY_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF
-} VkHostImageCopyFlagBitsEXT;
-typedef VkFlags VkHostImageCopyFlagsEXT;
-typedef struct VkPhysicalDeviceHostImageCopyFeaturesEXT {
-    VkStructureType    sType;
-    void*              pNext;
-    VkBool32           hostImageCopy;
-} VkPhysicalDeviceHostImageCopyFeaturesEXT;
+typedef VkHostImageCopyFlags VkHostImageCopyFlagsEXT;
 
-typedef struct VkPhysicalDeviceHostImageCopyPropertiesEXT {
-    VkStructureType    sType;
-    void*              pNext;
-    uint32_t           copySrcLayoutCount;
-    VkImageLayout*     pCopySrcLayouts;
-    uint32_t           copyDstLayoutCount;
-    VkImageLayout*     pCopyDstLayouts;
-    uint8_t            optimalTilingLayoutUUID[VK_UUID_SIZE];
-    VkBool32           identicalMemoryTypeRequirements;
-} VkPhysicalDeviceHostImageCopyPropertiesEXT;
+typedef VkPhysicalDeviceHostImageCopyFeatures VkPhysicalDeviceHostImageCopyFeaturesEXT;
 
-typedef struct VkMemoryToImageCopyEXT {
-    VkStructureType             sType;
-    const void*                 pNext;
-    const void*                 pHostPointer;
-    uint32_t                    memoryRowLength;
-    uint32_t                    memoryImageHeight;
-    VkImageSubresourceLayers    imageSubresource;
-    VkOffset3D                  imageOffset;
-    VkExtent3D                  imageExtent;
-} VkMemoryToImageCopyEXT;
+typedef VkPhysicalDeviceHostImageCopyProperties VkPhysicalDeviceHostImageCopyPropertiesEXT;
 
-typedef struct VkImageToMemoryCopyEXT {
-    VkStructureType             sType;
-    const void*                 pNext;
-    void*                       pHostPointer;
-    uint32_t                    memoryRowLength;
-    uint32_t                    memoryImageHeight;
-    VkImageSubresourceLayers    imageSubresource;
-    VkOffset3D                  imageOffset;
-    VkExtent3D                  imageExtent;
-} VkImageToMemoryCopyEXT;
+typedef VkMemoryToImageCopy VkMemoryToImageCopyEXT;
 
-typedef struct VkCopyMemoryToImageInfoEXT {
-    VkStructureType                  sType;
-    const void*                      pNext;
-    VkHostImageCopyFlagsEXT          flags;
-    VkImage                          dstImage;
-    VkImageLayout                    dstImageLayout;
-    uint32_t                         regionCount;
-    const VkMemoryToImageCopyEXT*    pRegions;
-} VkCopyMemoryToImageInfoEXT;
-
-typedef struct VkCopyImageToMemoryInfoEXT {
-    VkStructureType                  sType;
-    const void*                      pNext;
-    VkHostImageCopyFlagsEXT          flags;
-    VkImage                          srcImage;
-    VkImageLayout                    srcImageLayout;
-    uint32_t                         regionCount;
-    const VkImageToMemoryCopyEXT*    pRegions;
-} VkCopyImageToMemoryInfoEXT;
-
-typedef struct VkCopyImageToImageInfoEXT {
-    VkStructureType            sType;
-    const void*                pNext;
-    VkHostImageCopyFlagsEXT    flags;
-    VkImage                    srcImage;
-    VkImageLayout              srcImageLayout;
-    VkImage                    dstImage;
-    VkImageLayout              dstImageLayout;
-    uint32_t                   regionCount;
-    const VkImageCopy2*        pRegions;
-} VkCopyImageToImageInfoEXT;
-
-typedef struct VkHostImageLayoutTransitionInfoEXT {
-    VkStructureType            sType;
-    const void*                pNext;
-    VkImage                    image;
-    VkImageLayout              oldLayout;
-    VkImageLayout              newLayout;
-    VkImageSubresourceRange    subresourceRange;
-} VkHostImageLayoutTransitionInfoEXT;
+typedef VkImageToMemoryCopy VkImageToMemoryCopyEXT;
 
-typedef struct VkSubresourceHostMemcpySizeEXT {
-    VkStructureType    sType;
-    void*              pNext;
-    VkDeviceSize       size;
-} VkSubresourceHostMemcpySizeEXT;
+typedef VkCopyMemoryToImageInfo VkCopyMemoryToImageInfoEXT;
 
-typedef struct VkHostImageCopyDevicePerformanceQueryEXT {
-    VkStructureType    sType;
-    void*              pNext;
-    VkBool32           optimalDeviceAccess;
-    VkBool32           identicalMemoryLayout;
-} VkHostImageCopyDevicePerformanceQueryEXT;
+typedef VkCopyImageToMemoryInfo VkCopyImageToMemoryInfoEXT;
+
+typedef VkCopyImageToImageInfo VkCopyImageToImageInfoEXT;
+
+typedef VkHostImageLayoutTransitionInfo VkHostImageLayoutTransitionInfoEXT;
 
-typedef VkSubresourceLayout2KHR VkSubresourceLayout2EXT;
+typedef VkSubresourceHostMemcpySize VkSubresourceHostMemcpySizeEXT;
 
-typedef VkImageSubresource2KHR VkImageSubresource2EXT;
+typedef VkHostImageCopyDevicePerformanceQuery VkHostImageCopyDevicePerformanceQueryEXT;
 
-typedef VkResult (VKAPI_PTR *PFN_vkCopyMemoryToImageEXT)(VkDevice device, const VkCopyMemoryToImageInfoEXT* pCopyMemoryToImageInfo);
-typedef VkResult (VKAPI_PTR *PFN_vkCopyImageToMemoryEXT)(VkDevice device, const VkCopyImageToMemoryInfoEXT* pCopyImageToMemoryInfo);
-typedef VkResult (VKAPI_PTR *PFN_vkCopyImageToImageEXT)(VkDevice device, const VkCopyImageToImageInfoEXT* pCopyImageToImageInfo);
-typedef VkResult (VKAPI_PTR *PFN_vkTransitionImageLayoutEXT)(VkDevice device, uint32_t transitionCount, const VkHostImageLayoutTransitionInfoEXT* pTransitions);
-typedef void (VKAPI_PTR *PFN_vkGetImageSubresourceLayout2EXT)(VkDevice device, VkImage image, const VkImageSubresource2KHR* pSubresource, VkSubresourceLayout2KHR* pLayout);
+typedef VkSubresourceLayout2 VkSubresourceLayout2EXT;
+
+typedef VkImageSubresource2 VkImageSubresource2EXT;
+
+typedef VkResult (VKAPI_PTR *PFN_vkCopyMemoryToImageEXT)(VkDevice device, const VkCopyMemoryToImageInfo*    pCopyMemoryToImageInfo);
+typedef VkResult (VKAPI_PTR *PFN_vkCopyImageToMemoryEXT)(VkDevice device, const VkCopyImageToMemoryInfo*    pCopyImageToMemoryInfo);
+typedef VkResult (VKAPI_PTR *PFN_vkCopyImageToImageEXT)(VkDevice device, const VkCopyImageToImageInfo*    pCopyImageToImageInfo);
+typedef VkResult (VKAPI_PTR *PFN_vkTransitionImageLayoutEXT)(VkDevice device, uint32_t transitionCount, const VkHostImageLayoutTransitionInfo*    pTransitions);
+typedef void (VKAPI_PTR *PFN_vkGetImageSubresourceLayout2EXT)(VkDevice device, VkImage image, const VkImageSubresource2* pSubresource, VkSubresourceLayout2* pLayout);
 
 #ifndef VK_NO_PROTOTYPES
 VKAPI_ATTR VkResult VKAPI_CALL vkCopyMemoryToImageEXT(
     VkDevice                                    device,
-    const VkCopyMemoryToImageInfoEXT*           pCopyMemoryToImageInfo);
+    const VkCopyMemoryToImageInfo*              pCopyMemoryToImageInfo);
 
 VKAPI_ATTR VkResult VKAPI_CALL vkCopyImageToMemoryEXT(
     VkDevice                                    device,
-    const VkCopyImageToMemoryInfoEXT*           pCopyImageToMemoryInfo);
+    const VkCopyImageToMemoryInfo*              pCopyImageToMemoryInfo);
 
 VKAPI_ATTR VkResult VKAPI_CALL vkCopyImageToImageEXT(
     VkDevice                                    device,
-    const VkCopyImageToImageInfoEXT*            pCopyImageToImageInfo);
+    const VkCopyImageToImageInfo*               pCopyImageToImageInfo);
 
 VKAPI_ATTR VkResult VKAPI_CALL vkTransitionImageLayoutEXT(
     VkDevice                                    device,
     uint32_t                                    transitionCount,
-    const VkHostImageLayoutTransitionInfoEXT*   pTransitions);
+    const VkHostImageLayoutTransitionInfo*      pTransitions);
 
 VKAPI_ATTR void VKAPI_CALL vkGetImageSubresourceLayout2EXT(
     VkDevice                                    device,
     VkImage                                     image,
-    const VkImageSubresource2KHR*               pSubresource,
-    VkSubresourceLayout2KHR*                    pLayout);
+    const VkImageSubresource2*                  pSubresource,
+    VkSubresourceLayout2*                       pLayout);
 #endif
 
 
@@ -17097,6 +17837,18 @@ typedef struct VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT {
 
 
 
+// VK_EXT_present_mode_fifo_latest_ready is a preprocessor guard. Do not pass it to API calls.
+#define VK_EXT_present_mode_fifo_latest_ready 1
+#define VK_EXT_PRESENT_MODE_FIFO_LATEST_READY_SPEC_VERSION 1
+#define VK_EXT_PRESENT_MODE_FIFO_LATEST_READY_EXTENSION_NAME "VK_EXT_present_mode_fifo_latest_ready"
+typedef struct VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT {
+    VkStructureType    sType;
+    void*              pNext;
+    VkBool32           presentModeFifoLatestReady;
+} VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT;
+
+
+
 // VK_HUAWEI_subpass_shading is a preprocessor guard. Do not pass it to API calls.
 #define VK_HUAWEI_subpass_shading 1
 #define VK_HUAWEI_SUBPASS_SHADING_SPEC_VERSION 3
@@ -17353,10 +18105,10 @@ typedef struct VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT {
 #define VK_EXT_global_priority_query 1
 #define VK_EXT_GLOBAL_PRIORITY_QUERY_SPEC_VERSION 1
 #define VK_EXT_GLOBAL_PRIORITY_QUERY_EXTENSION_NAME "VK_EXT_global_priority_query"
-#define VK_MAX_GLOBAL_PRIORITY_SIZE_EXT   VK_MAX_GLOBAL_PRIORITY_SIZE_KHR
-typedef VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT;
+#define VK_MAX_GLOBAL_PRIORITY_SIZE_EXT   VK_MAX_GLOBAL_PRIORITY_SIZE
+typedef VkPhysicalDeviceGlobalPriorityQueryFeatures VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT;
 
-typedef VkQueueFamilyGlobalPriorityPropertiesKHR VkQueueFamilyGlobalPriorityPropertiesEXT;
+typedef VkQueueFamilyGlobalPriorityProperties VkQueueFamilyGlobalPriorityPropertiesEXT;
 
 
 
@@ -18818,11 +19570,7 @@ typedef struct VkPhysicalDeviceLegacyDitheringFeaturesEXT {
 #define VK_EXT_pipeline_protected_access 1
 #define VK_EXT_PIPELINE_PROTECTED_ACCESS_SPEC_VERSION 1
 #define VK_EXT_PIPELINE_PROTECTED_ACCESS_EXTENSION_NAME "VK_EXT_pipeline_protected_access"
-typedef struct VkPhysicalDevicePipelineProtectedAccessFeaturesEXT {
-    VkStructureType    sType;
-    void*              pNext;
-    VkBool32           pipelineProtectedAccess;
-} VkPhysicalDevicePipelineProtectedAccessFeaturesEXT;
+typedef VkPhysicalDevicePipelineProtectedAccessFeatures VkPhysicalDevicePipelineProtectedAccessFeaturesEXT;
 
 
 
@@ -19496,6 +20244,32 @@ typedef struct VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV {
 
 
 
+// VK_NV_display_stereo is a preprocessor guard. Do not pass it to API calls.
+#define VK_NV_display_stereo 1
+#define VK_NV_DISPLAY_STEREO_SPEC_VERSION 1
+#define VK_NV_DISPLAY_STEREO_EXTENSION_NAME "VK_NV_display_stereo"
+
+typedef enum VkDisplaySurfaceStereoTypeNV {
+    VK_DISPLAY_SURFACE_STEREO_TYPE_NONE_NV = 0,
+    VK_DISPLAY_SURFACE_STEREO_TYPE_ONBOARD_DIN_NV = 1,
+    VK_DISPLAY_SURFACE_STEREO_TYPE_HDMI_3D_NV = 2,
+    VK_DISPLAY_SURFACE_STEREO_TYPE_INBAND_DISPLAYPORT_NV = 3,
+    VK_DISPLAY_SURFACE_STEREO_TYPE_MAX_ENUM_NV = 0x7FFFFFFF
+} VkDisplaySurfaceStereoTypeNV;
+typedef struct VkDisplaySurfaceStereoCreateInfoNV {
+    VkStructureType                 sType;
+    const void*                     pNext;
+    VkDisplaySurfaceStereoTypeNV    stereoType;
+} VkDisplaySurfaceStereoCreateInfoNV;
+
+typedef struct VkDisplayModeStereoPropertiesNV {
+    VkStructureType    sType;
+    const void*        pNext;
+    VkBool32           hdmi3DSupported;
+} VkDisplayModeStereoPropertiesNV;
+
+
+
 // VK_NV_raw_access_chains is a preprocessor guard. Do not pass it to API calls.
 #define VK_NV_raw_access_chains 1
 #define VK_NV_RAW_ACCESS_CHAINS_SPEC_VERSION 1
@@ -19627,7 +20401,7 @@ typedef struct VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT {
 
 typedef struct VkGeneratedCommandsMemoryRequirementsInfoEXT {
     VkStructureType                sType;
-    void*                          pNext;
+    const void*                    pNext;
     VkIndirectExecutionSetEXT      indirectExecutionSet;
     VkIndirectCommandsLayoutEXT    indirectCommandsLayout;
     uint32_t                       maxSequenceCount;
@@ -19879,6 +20653,86 @@ typedef struct VkPipelineViewportDepthClampControlCreateInfoEXT {
 
 
 
+// VK_HUAWEI_hdr_vivid is a preprocessor guard. Do not pass it to API calls.
+#define VK_HUAWEI_hdr_vivid 1
+#define VK_HUAWEI_HDR_VIVID_SPEC_VERSION  1
+#define VK_HUAWEI_HDR_VIVID_EXTENSION_NAME "VK_HUAWEI_hdr_vivid"
+typedef struct VkPhysicalDeviceHdrVividFeaturesHUAWEI {
+    VkStructureType    sType;
+    void*              pNext;
+    VkBool32           hdrVivid;
+} VkPhysicalDeviceHdrVividFeaturesHUAWEI;
+
+typedef struct VkHdrVividDynamicMetadataHUAWEI {
+    VkStructureType    sType;
+    const void*        pNext;
+    size_t             dynamicMetadataSize;
+    const void*        pDynamicMetadata;
+} VkHdrVividDynamicMetadataHUAWEI;
+
+
+
+// VK_NV_cooperative_matrix2 is a preprocessor guard. Do not pass it to API calls.
+#define VK_NV_cooperative_matrix2 1
+#define VK_NV_COOPERATIVE_MATRIX_2_SPEC_VERSION 1
+#define VK_NV_COOPERATIVE_MATRIX_2_EXTENSION_NAME "VK_NV_cooperative_matrix2"
+typedef struct VkCooperativeMatrixFlexibleDimensionsPropertiesNV {
+    VkStructureType       sType;
+    void*                 pNext;
+    uint32_t              MGranularity;
+    uint32_t              NGranularity;
+    uint32_t              KGranularity;
+    VkComponentTypeKHR    AType;
+    VkComponentTypeKHR    BType;
+    VkComponentTypeKHR    CType;
+    VkComponentTypeKHR    ResultType;
+    VkBool32              saturatingAccumulation;
+    VkScopeKHR            scope;
+    uint32_t              workgroupInvocations;
+} VkCooperativeMatrixFlexibleDimensionsPropertiesNV;
+
+typedef struct VkPhysicalDeviceCooperativeMatrix2FeaturesNV {
+    VkStructureType    sType;
+    void*              pNext;
+    VkBool32           cooperativeMatrixWorkgroupScope;
+    VkBool32           cooperativeMatrixFlexibleDimensions;
+    VkBool32           cooperativeMatrixReductions;
+    VkBool32           cooperativeMatrixConversions;
+    VkBool32           cooperativeMatrixPerElementOperations;
+    VkBool32           cooperativeMatrixTensorAddressing;
+    VkBool32           cooperativeMatrixBlockLoads;
+} VkPhysicalDeviceCooperativeMatrix2FeaturesNV;
+
+typedef struct VkPhysicalDeviceCooperativeMatrix2PropertiesNV {
+    VkStructureType    sType;
+    void*              pNext;
+    uint32_t           cooperativeMatrixWorkgroupScopeMaxWorkgroupSize;
+    uint32_t           cooperativeMatrixFlexibleDimensionsMaxDimension;
+    uint32_t           cooperativeMatrixWorkgroupScopeReservedSharedMemory;
+} VkPhysicalDeviceCooperativeMatrix2PropertiesNV;
+
+typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV)(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkCooperativeMatrixFlexibleDimensionsPropertiesNV* pProperties);
+
+#ifndef VK_NO_PROTOTYPES
+VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(
+    VkPhysicalDevice                            physicalDevice,
+    uint32_t*                                   pPropertyCount,
+    VkCooperativeMatrixFlexibleDimensionsPropertiesNV* pProperties);
+#endif
+
+
+// VK_EXT_vertex_attribute_robustness is a preprocessor guard. Do not pass it to API calls.
+#define VK_EXT_vertex_attribute_robustness 1
+#define VK_EXT_VERTEX_ATTRIBUTE_ROBUSTNESS_SPEC_VERSION 1
+#define VK_EXT_VERTEX_ATTRIBUTE_ROBUSTNESS_EXTENSION_NAME "VK_EXT_vertex_attribute_robustness"
+typedef struct VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT {
+    VkStructureType    sType;
+    void*              pNext;
+    VkBool32           vertexAttributeRobustness;
+} VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT;
+
+
+
 // VK_KHR_acceleration_structure is a preprocessor guard. Do not pass it to API calls.
 #define VK_KHR_acceleration_structure 1
 #define VK_KHR_ACCELERATION_STRUCTURE_SPEC_VERSION 13
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 4036241b4..2f369adb3 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -33,6 +33,14 @@ check_no_parenthesis_in_path()
 detect_operating_system()
 detect_compiler()
 
+# Need to make sure this is included early, so we can make sure we use our own Vulkan headers,
+# which are more recent than system headers.
+# Otherwise, Qt6 includes system Vulkan headers in SearchForStuff.
+if (IS_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/pcsx2/GS/parallel-gs)
+	set(PARALLEL_GS_STANDALONE ON CACHE BOOL "" FORCE)
+	add_subdirectory(pcsx2/GS/parallel-gs EXCLUDE_FROM_ALL)
+endif()
+
 #-------------------------------------------------------------------------------
 # Include specific module
 include(BuildParameters)
diff --git a/pcsx2-gsrunner/Main.cpp b/pcsx2-gsrunner/Main.cpp
index d3ad1e818..0f4120573 100644
--- a/pcsx2-gsrunner/Main.cpp
+++ b/pcsx2-gsrunner/Main.cpp
@@ -519,6 +519,10 @@ bool GSRunner::ParseCommandLineArgs(int argc, char* argv[], VMBootParameters& pa
 				else if (StringUtil::Strcasecmp(rname, "dx12") == 0)
 					type = GSRendererType::DX12;
 #endif
+#ifdef HAVE_PARALLEL_GS
+				else if (StringUtil::Strcasecmp(rname, "parallel-gs") == 0)
+					type = GSRendererType::ParallelGS;
+#endif
 #ifdef ENABLE_OPENGL
 				else if (StringUtil::Strcasecmp(rname, "gl") == 0)
 					type = GSRendererType::OGL;
diff --git a/pcsx2-qt/MainWindow.cpp b/pcsx2-qt/MainWindow.cpp
index 616e9efa9..4fe7cfc8f 100644
--- a/pcsx2-qt/MainWindow.cpp
+++ b/pcsx2-qt/MainWindow.cpp
@@ -462,6 +462,9 @@ void MainWindow::createRendererSwitchMenu()
 {
 	static constexpr const GSRendererType renderers[] = {
 		GSRendererType::Auto,
+#if defined(HAVE_PARALLEL_GS)
+		GSRendererType::ParallelGS,
+#endif
 #if defined(_WIN32)
 		GSRendererType::DX11,
 		GSRendererType::DX12,
diff --git a/pcsx2-qt/Settings/GraphicsSettingsWidget.cpp b/pcsx2-qt/Settings/GraphicsSettingsWidget.cpp
index 311143fd4..8e7ce2761 100644
--- a/pcsx2-qt/Settings/GraphicsSettingsWidget.cpp
+++ b/pcsx2-qt/Settings/GraphicsSettingsWidget.cpp
@@ -20,6 +20,9 @@ struct RendererInfo
 
 static constexpr RendererInfo s_renderer_info[] = {
 	{QT_TRANSLATE_NOOP("GraphicsSettingsWidget", "Automatic (Default)"), GSRendererType::Auto},
+#ifdef HAVE_PARALLEL_GS
+	{QT_TRANSLATE_NOOP("GraphicsSettingsWidget", "paraLLEl-GS"), GSRendererType::ParallelGS},
+#endif
 #ifdef _WIN32
 	//: Graphics backend/engine type. Leave as-is.
 	{QT_TRANSLATE_NOOP("GraphicsSettingsWidget", "Direct3D 11"), GSRendererType::DX11},
@@ -264,6 +267,17 @@ GraphicsSettingsWidget::GraphicsSettingsWidget(SettingsWindow* dialog, QWidget*
 	SettingWidgetBinder::BindWidgetToBoolSetting(sif, m_ui.swAutoFlush, "EmuCore/GS", "autoflush_sw", true);
 	SettingWidgetBinder::BindWidgetToBoolSetting(sif, m_ui.swMipmap, "EmuCore/GS", "mipmap", true);
 
+	//////////////////////////////////////////////////////////////////////////
+	// PGS Settings
+	//////////////////////////////////////////////////////////////////////////
+	SettingWidgetBinder::BindWidgetToIntSetting(sif, m_ui.pgsSuperSampling, "EmuCore/GS", "pgsSuperSampling", 0);
+	SettingWidgetBinder::BindWidgetToIntSetting(sif, m_ui.pgsHighResScanout, "EmuCore/GS", "pgsHighResScanout", 0);
+	SettingWidgetBinder::BindWidgetToIntSetting(sif, m_ui.pgsSuperSampleTextures, "EmuCore/GS", "pgsSuperSampleTextures", 0);
+	SettingWidgetBinder::BindWidgetToIntSetting(sif, m_ui.pgsDisableMipmaps, "EmuCore/GS", "pgsDisableMipmaps", 0);
+	SettingWidgetBinder::BindWidgetToIntSetting(sif, m_ui.pgsDisableReadbackSync, "EmuCore/GS", "pgsDisableReadbackSync", 0);
+	SettingWidgetBinder::BindWidgetToIntSetting(sif, m_ui.pgsSharpBackbuffer, "EmuCore/GS", "pgsSharpBackbuffer", 0);
+	SettingWidgetBinder::BindWidgetToIntSetting(sif, m_ui.pgsBlendDemotion, "EmuCore/GS", "pgsBlendDemotion", 0);
+
 	//////////////////////////////////////////////////////////////////////////
 	// Non-trivial settings
 	//////////////////////////////////////////////////////////////////////////
@@ -298,6 +312,7 @@ GraphicsSettingsWidget::GraphicsSettingsWidget(SettingsWindow* dialog, QWidget*
 	connect(m_ui.extendedUpscales, &QCheckBox::checkStateChanged, this, &GraphicsSettingsWidget::updateRendererDependentOptions);
 	connect(m_ui.textureFiltering, &QComboBox::currentIndexChanged, this, &GraphicsSettingsWidget::onTextureFilteringChange);
 	connect(m_ui.swTextureFiltering, &QComboBox::currentIndexChanged, this, &GraphicsSettingsWidget::onSWTextureFilteringChange);
+
 	updateRendererDependentOptions();
 
 #ifndef _WIN32
@@ -571,6 +586,42 @@ GraphicsSettingsWidget::GraphicsSettingsWidget(SettingsWindow* dialog, QWidget*
 
 		dialog->registerWidgetHelp(
 			m_ui.swMipmap, tr("Mipmapping"), tr("Checked"), tr("Enables mipmapping, which some games require to render correctly."));
+
+		dialog->registerWidgetHelp(m_ui.pgsSuperSampling, tr("paraLLEl-GS Super Sampling"), tr("1x (native)"),
+		                           tr("Number of super samples used by paraLLEl-GS before down-sampling to native resolution. "
+		                              "More than 4x SSAA is not recommended as there is diminishing returns in output quality. "
+		                              "16x SSAA yields a very nice result, but requires reasonably powerful hardware in some games."));
+
+		dialog->registerWidgetHelp(m_ui.pgsSharpBackbuffer, tr("Sharp backbuffer hacks (experimental)"), tr("Unchecked"),
+		                           tr("Some games perform a blit to the backbuffer. "
+		                              "This can significantly reduce image quality, since games tend to either scale the image, or convert the image to 16-bit colors. "
+		                              "This hack attempts to present the original image instead. This option may help alleviate that in lieu of a more proper game patch."));
+
+		dialog->registerWidgetHelp(m_ui.pgsBlendDemotion, tr("Blend demotion speed-hack (experimental)"), tr("Unchecked"),
+		                           tr("When super-sampling, some effect passes may become extremely expensive due to ridiculous overdraw. "
+									  "Most of these passes don't really need super-sampling to achieve its effect. "
+									  "Enabling this option tries to detect common cases and demotes those passes to single sampled. "
+									  "This may dramatically improve performance for certain effects at cost of some image quality, especially around geometry edges. "
+									  "Should not be used along high-res scanout or super-sampled textures since pixellation will be introduced."));
+
+		dialog->registerWidgetHelp(m_ui.pgsSuperSampleTextures, tr("Super-sample Textures (experimental)"), tr("Unchecked"),
+		                           tr("Ensures that frame buffer effects are sampled with all super-samples intact. "
+		                              "Costs some GPU performance and VRAM, but may significantly improve image quality, especially when enabling high-res scanout. "
+									  "This option is highly experimental and may show many rendering artifacts."));
+
+		dialog->registerWidgetHelp(m_ui.pgsHighResScanout, tr("High-res Scanout (experimental)"), tr("Unchecked"),
+		                           tr("When using SSAA, attempts to scan-out a higher resolution result based on stored super-samples. "
+		                              "Requires at least 4x SSAA (ordered) to work. Can benefit from 16x SSAA, at a steep GPU processing cost. "
+									  "Highly game dependent if it works well. Common issues include pixellated output, or lack of sharpness. "
+									  "When playing field rendered games, may eliminate most de-interlacing artifacts. "
+									  "May need super-sampled texture option to be enabled for good results."));
+
+		dialog->registerWidgetHelp(m_ui.pgsDisableMipmaps, tr("Disable mip-mapping"), tr("Unchecked"),
+		                           tr("Disables mip-mapping. May give a sharper image in games using mip-mapping intended for native resolution. "
+		                              "May also break games which rely on mipmaps being used in esoteric ways."));
+
+		dialog->registerWidgetHelp(m_ui.pgsDisableReadbackSync, tr("Disable readback sync"), tr("Unchecked"),
+		                           tr("Disables sync for readbacks. Eliminates stalls, but will probably break things. Used for perf debug."));
 	}
 
 	// Hardware Fixes tab
@@ -1084,6 +1135,7 @@ void GraphicsSettingsWidget::updateRendererDependentOptions()
 	const bool is_hardware = (type == GSRendererType::DX11 || type == GSRendererType::DX12 || type == GSRendererType::OGL ||
 							  type == GSRendererType::VK || type == GSRendererType::Metal);
 	const bool is_software = (type == GSRendererType::SW);
+	const bool is_pgs = (type == GSRendererType::ParallelGS);
 	const bool is_auto = (type == GSRendererType::Auto);
 	const bool is_vk = (type == GSRendererType::VK);
 	const bool is_disable_barriers = (type == GSRendererType::DX11 || type == GSRendererType::DX12 || type == GSRendererType::Metal || type == GSRendererType::SW);
@@ -1098,22 +1150,32 @@ void GraphicsSettingsWidget::updateRendererDependentOptions()
 	m_ui.tabs->setTabEnabled(2, is_software);
 	m_ui.tabs->setTabVisible(2, is_software);
 
-	// hardware fixes
-	m_ui.tabs->setTabEnabled(3, hw_fixes);
-	m_ui.tabs->setTabVisible(3, hw_fixes);
+	// pgs rendering
+	m_ui.tabs->setTabEnabled(3, is_pgs);
+	m_ui.tabs->setTabVisible(3, is_pgs);
 
-	// upscaling fixes
+	// hardware fixes
 	m_ui.tabs->setTabEnabled(4, hw_fixes);
 	m_ui.tabs->setTabVisible(4, hw_fixes);
 
+	// upscaling fixes
+	m_ui.tabs->setTabEnabled(5, hw_fixes);
+	m_ui.tabs->setTabVisible(5, hw_fixes);
+
 	// texture replacement
-	m_ui.tabs->setTabEnabled(5, is_hardware);
-	m_ui.tabs->setTabVisible(5, is_hardware);
+	m_ui.tabs->setTabEnabled(6, is_hardware);
+	m_ui.tabs->setTabVisible(6, is_hardware);
+
+	// Post-processing
+	m_ui.tabs->setTabEnabled(7, !is_pgs);
+	m_ui.tabs->setTabVisible(7, !is_pgs);
 
 	// move back to the renderer if we're on one of the now-hidden tabs
-	if (is_software && (prev_tab == 1 || (prev_tab >= 2 && prev_tab <= 5)))
+	if (is_software && (prev_tab == 1 || (prev_tab >= 2 && prev_tab <= 6)))
 		m_ui.tabs->setCurrentIndex(2);
-	else if (is_hardware && prev_tab == 2)
+	else if (is_pgs)
+		m_ui.tabs->setCurrentIndex(3);
+	else if (is_hardware && (prev_tab == 2 || prev_tab == 3))
 		m_ui.tabs->setCurrentIndex(1);
 
 	if (m_ui.useBlitSwapChain)
diff --git a/pcsx2-qt/Settings/GraphicsSettingsWidget.ui b/pcsx2-qt/Settings/GraphicsSettingsWidget.ui
index d1b6a9031..9259f8886 100644
--- a/pcsx2-qt/Settings/GraphicsSettingsWidget.ui
+++ b/pcsx2-qt/Settings/GraphicsSettingsWidget.ui
@@ -721,6 +721,106 @@
        </item>
       </layout>
      </widget>
+     <widget class="QWidget" name="pgsRenderingTab">
+      <attribute name="title"><string>Rendering</string></attribute>
+      <layout class="QFormLayout" name="formLayout_11">
+       <item row="0" column="0">
+        <widget class="QLabel" name="pgsSuperSamplingLabel">
+         <property name="text">
+          <string>Super Sampling:</string>
+         </property>
+        </widget>
+       </item>
+       <item row="0" column="1">
+        <widget class="QComboBox" name="pgsSuperSampling">
+         <property name="enabled">
+          <bool>true</bool>
+         </property>
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+         <property name="layoutDirection">
+          <enum>Qt::LayoutDirection::LeftToRight</enum>
+         </property>
+         <item>
+          <property name="text">
+           <string>1x (native)</string>
+          </property>
+         </item>
+         <item>
+          <property name="text">
+           <string>2x SSAA (checkerboard)</string>
+          </property>
+         </item>
+         <item>
+          <property name="text">
+           <string>4x SSAA (sparse grid)</string>
+          </property>
+         </item>
+         <item>
+          <property name="text">
+           <string>4x SSAA (ordered grid, high-res output capable)</string>
+          </property>
+         </item>
+         <item>
+          <property name="text">
+           <string>8x SSAA (checkerboard, high-res output capable)</string>
+          </property>
+         </item>
+         <item>
+          <property name="text">
+           <string>16x SSAA (sparse grid, high-res output capable)</string>
+          </property>
+         </item>
+        </widget>
+       </item>
+       <item row="1" column="0">
+          <widget class="QCheckBox" name="pgsHighResScanout">
+           <property name="text">
+            <string>High-resolution scanout</string>
+           </property>
+          </widget>
+       </item>
+       <item row="1" column="1">
+          <widget class="QCheckBox" name="pgsSuperSampleTextures">
+           <property name="text">
+            <string>Super-sample textures</string>
+           </property>
+          </widget>
+       </item>
+       <item row="2" column="0">
+          <widget class="QCheckBox" name="pgsDisableMipmaps">
+           <property name="text">
+            <string>Disable mip-mapping</string>
+           </property>
+          </widget>
+       </item>
+       <item row="2" column="1">
+          <widget class="QCheckBox" name="pgsDisableReadbackSync">
+           <property name="text">
+            <string>Disable readback sync</string>
+           </property>
+          </widget>
+       </item>
+       <item row="3" column="0">
+          <widget class="QCheckBox" name="pgsSharpBackbuffer">
+           <property name="text">
+            <string>Sharp backbuffer hack</string>
+           </property>
+          </widget>
+       </item>
+       <item row="3" column="1">
+          <widget class="QCheckBox" name="pgsBlendDemotion">
+           <property name="text">
+            <string>Blend demotion hack</string>
+           </property>
+          </widget>
+       </item>
+      </layout>
+     </widget>
      <widget class="QGroupBox" name="hardwareFixesTab">
       <attribute name="title">
        <string>Hardware Fixes</string>
diff --git a/pcsx2-qt/pcsx2-qt.vcxproj b/pcsx2-qt/pcsx2-qt.vcxproj
index f77da9595..5c3536ce9 100644
--- a/pcsx2-qt/pcsx2-qt.vcxproj
+++ b/pcsx2-qt/pcsx2-qt.vcxproj
@@ -54,7 +54,7 @@
       <ForcedIncludeFiles>PrecompiledHeader.h;%(ForcedIncludeFiles)</ForcedIncludeFiles>
       <PreprocessorDefinitions Condition="'$(Platform)'!='ARM64'">ENABLE_RAINTEGRATION;ENABLE_OPENGL;ENABLE_VULKAN;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <PreprocessorDefinitions>LZMA_API_STATIC;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <PreprocessorDefinitions>QT_NO_EXCEPTIONS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <PreprocessorDefinitions>HAVE_PARALLEL_GS;QT_NO_EXCEPTIONS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <!-- Current Qt debug builds assert on RTTI. Remove this once we next build Qt. -->
       <RuntimeTypeInfo Condition="$(Configuration.Contains(Debug))">true</RuntimeTypeInfo>
     </ClCompile>
diff --git a/pcsx2/CMakeLists.txt b/pcsx2/CMakeLists.txt
index 804ab2e40..9bb3b0af3 100644
--- a/pcsx2/CMakeLists.txt
+++ b/pcsx2/CMakeLists.txt
@@ -638,6 +638,7 @@ if(USE_VULKAN)
 		GS/Renderers/Vulkan/VKEntryPoints.h
 		GS/Renderers/Vulkan/VKEntryPoints.inl
 		GS/Renderers/Vulkan/VKLoader.h
+		GS/Renderers/Vulkan/VKLoaderPlatformDefines.h
 		GS/Renderers/Vulkan/VKShaderCache.h
 		GS/Renderers/Vulkan/VKStreamBuffer.h
 		GS/Renderers/Vulkan/VKSwapChain.h
@@ -646,6 +647,23 @@ if(USE_VULKAN)
 	target_include_directories(PCSX2_FLAGS INTERFACE ${SHADERC_INCLUDE_DIR})
 endif()
 
+if (TARGET parallel-gs)
+	message("Adding support for paraLLEl-GS")
+	target_link_libraries(PCSX2_FLAGS INTERFACE parallel-gs)
+	target_compile_definitions(PCSX2_FLAGS INTERFACE HAVE_PARALLEL_GS)
+	list(APPEND pcsx2GSSources GS/Renderers/parallel-gs/GSRendererPGS.cpp)
+	list(APPEND pcsx2GSHeaders GS/Renderers/parallel-gs/GSRendererPGS.h)
+	if (X11_API)
+		target_compile_definitions(granite-volk PUBLIC VK_USE_PLATFORM_XLIB_KHR)
+	endif()
+	if (WAYLAND_API)
+		target_compile_definitions(granite-volk PUBLIC VK_USE_PLATFORM_WAYLAND_KHR)
+	endif()
+	if (WIN32)
+		target_compile_definitions(granite-volk PUBLIC VK_USE_PLATFORM_WIN32_KHR)
+	endif()
+endif()
+
 set(pcsx2GSMetalShaders
 	GS/Renderers/Metal/cas.metal
 	GS/Renderers/Metal/convert.metal
diff --git a/pcsx2/Config.h b/pcsx2/Config.h
index 88f4da719..103710b5a 100644
--- a/pcsx2/Config.h
+++ b/pcsx2/Config.h
@@ -276,6 +276,7 @@ enum class GSRendererType : s8
 	VK = 14,
 	Metal = 17,
 	DX12 = 15,
+	ParallelGS = 18
 };
 
 enum class GSVSyncMode : u8
@@ -814,6 +815,13 @@ struct Pcsx2Config
 		u8 ShadeBoost_Contrast = 50;
 		u8 ShadeBoost_Saturation = 50;
 		u8 PNGCompressionLevel = 1;
+		u8 PGSSuperSampling = 0;
+		u8 PGSHighResScanout = 0;
+		u8 PGSDisableMipmaps = 0;
+		u8 PGSDisableReadbackSync = 0;
+		u8 PGSSuperSampleTextures = 0;
+		u8 PGSSharpBackbuffer = 0;
+		u8 PGSBlendDemotion = 0;
 
 		u16 SWExtraThreads = 2;
 		u16 SWExtraThreadsHeight = 4;
diff --git a/pcsx2/GS/GS.cpp b/pcsx2/GS/GS.cpp
index 84956d86a..94af60d8a 100644
--- a/pcsx2/GS/GS.cpp
+++ b/pcsx2/GS/GS.cpp
@@ -22,6 +22,11 @@
 #include "GS/Renderers/HW/GSTextureReplacements.h"
 #include "VMManager.h"
 
+#ifdef HAVE_PARALLEL_GS
+#include "GS/Renderers/parallel-gs/GSRendererPGS.h"
+std::unique_ptr<GSRendererPGS> g_pgs_renderer;
+#endif
+
 #ifdef ENABLE_OPENGL
 #include "GS/Renderers/OpenGL/GSDeviceOGL.h"
 #endif
@@ -58,6 +63,9 @@ Pcsx2Config::GSOptions GSConfig;
 
 static GSRendererType GSCurrentRenderer;
 
+struct FileDeleter { void operator()(FILE *file) { if (file) fclose(file); } };
+std::unique_ptr<FILE, FileDeleter> g_gs_stream;
+
 GSRendererType GSGetCurrentRenderer()
 {
 	return GSCurrentRenderer;
@@ -85,6 +93,11 @@ static RenderAPI GetAPIForRenderer(GSRendererType renderer)
 		case GSRendererType::VK:
 			return RenderAPI::Vulkan;
 
+#ifdef HAVE_PARALLEL_GS
+		case GSRendererType::ParallelGS:
+			return RenderAPI::Granite;
+#endif
+
 #ifdef _WIN32
 		case GSRendererType::DX11:
 			return RenderAPI::D3D11;
@@ -98,6 +111,10 @@ static RenderAPI GetAPIForRenderer(GSRendererType renderer)
 			return RenderAPI::Metal;
 #endif
 
+		case GSRendererType::SW:
+			// Hack.
+			return RenderAPI::Vulkan;
+
 			// We could end up here if we ever removed a renderer.
 		default:
 			return GetAPIForRenderer(GSUtil::GetPreferredRenderer());
@@ -135,6 +152,12 @@ static bool OpenGSDevice(GSRendererType renderer, bool clear_state_on_fail, bool
 			break;
 #endif
 
+#ifdef HAVE_PARALLEL_GS
+		case RenderAPI::Granite:
+			// The renderer owns its own device for now.
+			return true;
+#endif
+
 		default:
 			Console.Error("Unsupported render API %s", GSDevice::RenderAPIToString(new_api));
 			return false;
@@ -155,16 +178,20 @@ static bool OpenGSDevice(GSRendererType renderer, bool clear_state_on_fail, bool
 	if (!okay)
 	{
 		ImGuiManager::Shutdown(clear_state_on_fail);
-		g_gs_device->Destroy();
-		g_gs_device.reset();
+		if (g_gs_device)
+		{
+			g_gs_device->Destroy();
+			g_gs_device.reset();
+		}
 		Host::ReleaseRenderWindow();
 		return false;
 	}
 
-	GSConfig.OsdShowGPU = GSConfig.OsdShowGPU && g_gs_device->SetGPUTimingEnabled(true);
+	GSConfig.OsdShowGPU = g_gs_device && GSConfig.OsdShowGPU && g_gs_device->SetGPUTimingEnabled(true);
 
 	Console.WriteLn(Color_StrongGreen, "%s Graphics Driver Info:", GSDevice::RenderAPIToString(new_api));
-	Console.WriteLn(g_gs_device->GetDriverInfo());
+	if (g_gs_device)
+		Console.WriteLn(g_gs_device->GetDriverInfo());
 
 	return true;
 }
@@ -208,6 +235,17 @@ static bool OpenGSRenderer(GSRendererType renderer, u8* basemem)
 	{
 		g_gs_renderer = std::make_unique<GSRendererNull>();
 	}
+#ifdef HAVE_PARALLEL_GS
+	else if (renderer == GSRendererType::ParallelGS)
+	{
+		g_pgs_renderer = std::make_unique<GSRendererPGS>(basemem);
+		if (!g_pgs_renderer->Init())
+		{
+			g_pgs_renderer.reset();
+			return false;
+		}
+	}
+#endif
 	else if (renderer != GSRendererType::SW)
 	{
 		GSClampUpscaleMultiplier(GSConfig);
@@ -218,10 +256,18 @@ static bool OpenGSRenderer(GSRendererType renderer, u8* basemem)
 		g_gs_renderer = std::unique_ptr<GSRenderer>(MULTI_ISA_SELECT(makeGSRendererSW)(GSConfig.SWExtraThreads));
 	}
 
-	g_gs_renderer->SetRegsMem(basemem);
-	g_gs_renderer->ResetPCRTC();
-	g_gs_renderer->UpdateRenderFixes();
+	if (g_gs_renderer)
+	{
+		g_gs_renderer->SetRegsMem(basemem);
+		g_gs_renderer->ResetPCRTC();
+		g_gs_renderer->UpdateRenderFixes();
+	}
 	g_perfmon.Reset();
+
+	const char *env = getenv("GS_STREAM");
+	if (env)
+		g_gs_stream.reset(fopen(env, "wb"));
+
 	return true;
 }
 
@@ -229,11 +275,17 @@ static void CloseGSRenderer()
 {
 	GSTextureReplacements::Shutdown();
 
+#ifdef HAVE_PARALLEL_GS
+	g_pgs_renderer.reset();
+#endif
+
 	if (g_gs_renderer)
 	{
 		g_gs_renderer->Destroy();
 		g_gs_renderer.reset();
 	}
+
+	g_gs_stream.reset();
 }
 
 bool GSreopen(bool recreate_device, bool recreate_renderer, GSRendererType new_renderer,
@@ -241,18 +293,21 @@ bool GSreopen(bool recreate_device, bool recreate_renderer, GSRendererType new_r
 {
 	Console.WriteLn("Reopening GS with %s device", recreate_device ? "new" : "existing");
 
-	g_gs_renderer->Flush(GSState::GSFlushReason::GSREOPEN);
-
-	if (recreate_device && !recreate_renderer)
-	{
-		// Keeping the renderer around, this probably means we lost the device, so toss everything.
-		g_gs_renderer->PurgeTextureCache(true, true, true);
-		g_gs_device->ClearCurrent();
-		g_gs_device->PurgePool();
-	}
-	else if (GSConfig.UserHacks_ReadTCOnClose)
+	if (g_gs_renderer)
 	{
-		g_gs_renderer->ReadbackTextureCache();
+		g_gs_renderer->Flush(GSState::GSFlushReason::GSREOPEN);
+
+		if (recreate_device && !recreate_renderer)
+		{
+			// Keeping the renderer around, this probably means we lost the device, so toss everything.
+			g_gs_renderer->PurgeTextureCache(true, true, true);
+			g_gs_device->ClearCurrent();
+			g_gs_device->PurgePool();
+		}
+		else if (GSConfig.UserHacks_ReadTCOnClose)
+		{
+			g_gs_renderer->ReadbackTextureCache();
+		}
 	}
 
 	std::string capture_filename;
@@ -262,27 +317,65 @@ bool GSreopen(bool recreate_device, bool recreate_renderer, GSRendererType new_r
 		capture_filename = GSCapture::GetNextCaptureFileName();
 		capture_size = GSCapture::GetSize();
 		Console.Warning(fmt::format("Restarting video capture to {}.", capture_filename));
-		g_gs_renderer->EndCapture();
+		if (g_gs_renderer)
+			g_gs_renderer->EndCapture();
 	}
 
-	u8* basemem = g_gs_renderer->GetRegsMem();
+	u8* basemem;
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+	{
+		basemem = g_pgs_renderer->GetRegsMem();
+	}
+	else
+#endif
+	{
+		basemem = g_gs_renderer->GetRegsMem();
+	}
 
 	freezeData fd = {};
 	std::unique_ptr<u8[]> fd_data;
 	if (recreate_renderer)
 	{
-		if (g_gs_renderer->Freeze(&fd, true) != 0)
+#ifdef HAVE_PARALLEL_GS
+		if (g_pgs_renderer)
 		{
-			Console.Error("(GSreopen) Failed to get GS freeze size");
-			return false;
+			if (g_pgs_renderer->Freeze(&fd, true) != 0)
+			{
+				Console.Error("(GSreopen) Failed to get GS freeze size");
+				return false;
+			}
+		}
+		else
+#endif
+		{
+			if (g_gs_renderer->Freeze(&fd, true) != 0)
+			{
+				Console.Error("(GSreopen) Failed to get GS freeze size");
+				return false;
+			}
 		}
 
 		fd_data = std::make_unique<u8[]>(fd.size);
 		fd.data = fd_data.get();
-		if (g_gs_renderer->Freeze(&fd, false) != 0)
+
+#ifdef HAVE_PARALLEL_GS
+		if (g_pgs_renderer)
 		{
-			Console.Error("(GSreopen) Failed to freeze GS");
-			return false;
+			if (g_pgs_renderer->Freeze(&fd, false) != 0)
+			{
+				Console.Error("(GSreopen) Failed to freeze GS");
+				return false;
+			}
+		}
+		else
+#endif
+		{
+			if (g_gs_renderer->Freeze(&fd, false) != 0)
+			{
+				Console.Error("(GSreopen) Failed to freeze GS");
+				return false;
+			}
 		}
 
 		CloseGSRenderer();
@@ -291,9 +384,10 @@ bool GSreopen(bool recreate_device, bool recreate_renderer, GSRendererType new_r
 	if (recreate_device)
 	{
 		// We need a new render window when changing APIs.
-		const bool recreate_window = (g_gs_device->GetRenderAPI() != GetAPIForRenderer(GSConfig.Renderer));
-		const GSVSyncMode vsync_mode = g_gs_device->GetVSyncMode();
-		const bool allow_present_throttle = g_gs_device->IsPresentThrottleAllowed();
+		const bool recreate_window = !g_gs_device || (g_gs_device->GetRenderAPI() != GetAPIForRenderer(GSConfig.Renderer));
+		// TODO: Pass these through.
+		const GSVSyncMode vsync_mode = g_gs_device ? g_gs_device->GetVSyncMode() : GSVSyncMode::FIFO;
+		const bool allow_present_throttle = !g_gs_device || g_gs_device->IsPresentThrottleAllowed();
 		CloseGSDevice(false);
 
 		if (!OpenGSDevice(new_renderer, false, recreate_window, vsync_mode, allow_present_throttle))
@@ -324,14 +418,27 @@ bool GSreopen(bool recreate_device, bool recreate_renderer, GSRendererType new_r
 			return false;
 		}
 
-		if (g_gs_renderer->Defrost(&fd) != 0)
+#ifdef HAVE_PARALLEL_GS
+		if (g_pgs_renderer)
 		{
-			Console.Error("(GSreopen) Failed to defrost");
-			return false;
+			if (g_pgs_renderer->Defrost(&fd) != 0)
+			{
+				Console.Error("(GSreopen) Failed to defrost");
+				return false;
+			}
+		}
+		else
+#endif
+		{
+			if (g_gs_renderer->Defrost(&fd) != 0)
+			{
+				Console.Error("(GSreopen) Failed to defrost");
+				return false;
+			}
 		}
 	}
 
-	if (!capture_filename.empty())
+	if (g_gs_renderer && !capture_filename.empty())
 		g_gs_renderer->BeginCapture(std::move(capture_filename), capture_size);
 
 	return true;
@@ -377,6 +484,14 @@ void GSclose()
 
 void GSreset(bool hardware_reset)
 {
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		g_pgs_renderer->Reset(hardware_reset);
+#endif
+
+	if (!g_gs_renderer)
+		return;
+
 	g_gs_renderer->Reset(hardware_reset);
 
 	// Restart video capture if it's been started.
@@ -393,56 +508,138 @@ void GSreset(bool hardware_reset)
 
 void GSgifSoftReset(u32 mask)
 {
-	g_gs_renderer->SoftReset(mask);
+	if (g_gs_renderer)
+		g_gs_renderer->SoftReset(mask);
 }
 
 void GSwriteCSR(u32 csr)
 {
-	g_gs_renderer->WriteCSR(csr);
+	// TODO: Do we need to care about CSR in parallel-GS?
+	if (g_gs_renderer)
+		g_gs_renderer->WriteCSR(csr);
 }
 
 void GSInitAndReadFIFO(u8* mem, u32 size)
 {
-	GL_PERF("Init and read FIFO %u qwc", size);
-	g_gs_renderer->InitReadFIFO(mem, size);
-	g_gs_renderer->ReadFIFO(mem, size);
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		g_pgs_renderer->ReadFIFO(mem, size);
+#endif
+
+	if (g_gs_renderer)
+	{
+		GL_PERF("Init and read FIFO %u qwc", size);
+		g_gs_renderer->InitReadFIFO(mem, size);
+		g_gs_renderer->ReadFIFO(mem, size);
+	}
 }
 
 void GSReadLocalMemoryUnsync(u8* mem, u32 qwc, u64 BITBLITBUF, u64 TRXPOS, u64 TRXREG)
 {
-	g_gs_renderer->ReadLocalMemoryUnsync(mem, qwc, GIFRegBITBLTBUF{BITBLITBUF}, GIFRegTRXPOS{TRXPOS}, GIFRegTRXREG{TRXREG});
+	// TODO: What is this?
+	if (g_gs_renderer)
+		g_gs_renderer->ReadLocalMemoryUnsync(mem, qwc, GIFRegBITBLTBUF{BITBLITBUF}, GIFRegTRXPOS{TRXPOS}, GIFRegTRXREG{TRXREG});
 }
 
 void GSgifTransfer(const u8* mem, u32 size)
 {
-	g_gs_renderer->Transfer<3>(mem, size);
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		g_pgs_renderer->Transfer(mem, size);
+#endif
+
+	if (g_gs_renderer)
+		g_gs_renderer->Transfer<3>(mem, size);
+
+	if (g_gs_stream)
+	{
+		auto *f = g_gs_stream.get();
+		const uint8_t type = 0;
+		const uint8_t path = 3;
+		fwrite(&type, sizeof(type), 1, f);
+		fwrite(&path, sizeof(path), 1, f);
+		size *= 16;
+		fwrite(&size, sizeof(size), 1, f);
+		fwrite(mem, size, 1, f);
+	}
 }
 
 void GSgifTransfer1(u8* mem, u32 addr)
 {
-	g_gs_renderer->Transfer<0>(const_cast<u8*>(mem) + addr, (0x4000 - addr) / 16);
+	// TODO: These seem to be completely unused.
+	if (g_gs_renderer)
+		g_gs_renderer->Transfer<0>(const_cast<u8*>(mem) + addr, (0x4000 - addr) / 16);
 }
 
 void GSgifTransfer2(u8* mem, u32 size)
 {
-	g_gs_renderer->Transfer<1>(const_cast<u8*>(mem), size);
+	// TODO: These seem to be completely unused.
+	if (g_gs_renderer)
+		g_gs_renderer->Transfer<1>(const_cast<u8*>(mem), size);
 }
 
 void GSgifTransfer3(u8* mem, u32 size)
 {
-	g_gs_renderer->Transfer<2>(const_cast<u8*>(mem), size);
+	// TODO: These seem to be completely unused.
+	if (g_gs_renderer)
+		g_gs_renderer->Transfer<2>(const_cast<u8*>(mem), size);
 }
 
 void GSvsync(u32 field, bool registers_written)
 {
+	if (g_gs_stream)
+	{
+		auto *f = g_gs_stream.get();
+
+		const uint8_t priv_type = 3;
+		fwrite(&priv_type, sizeof(priv_type), 1, f);
+
+#ifdef HAVE_PARALLEL_GS
+		if (g_pgs_renderer)
+			fwrite(g_pgs_renderer->GetRegsMem(), sizeof(GSPrivRegSet), 1, f);
+		else
+#endif
+		{
+			fwrite(g_gs_renderer->GetRegsMem(), sizeof(GSPrivRegSet), 1, f);
+		}
+
+		const uint8_t type = 1;
+		fwrite(&type, sizeof(type), 1, f);
+		const uint8_t u8_field = field;
+		fwrite(&u8_field, sizeof(u8_field), 1, f);
+	}
+
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		g_pgs_renderer->VSync(field, registers_written);
+#endif
+
 	// Do not move the flush into the VSync() method. It's here because EE transfers
 	// get cleared in HW VSync, and may be needed for a buffered draw (FFX FMVs).
-	g_gs_renderer->Flush(GSState::VSYNC);
-	g_gs_renderer->VSync(field, registers_written, g_gs_renderer->IsIdleFrame());
+	if (g_gs_renderer)
+	{
+		g_gs_renderer->Flush(GSState::VSYNC);
+		g_gs_renderer->VSync(field, registers_written, g_gs_renderer->IsIdleFrame());
+	}
 }
 
 int GSfreeze(FreezeAction mode, freezeData* data)
 {
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+	{
+		if (mode == FreezeAction::Save)
+			return g_pgs_renderer->Freeze(data, false);
+		else if (mode == FreezeAction::Size)
+			return g_pgs_renderer->Freeze(data, true);
+		else // if (mode == FreezeAction::Load)
+			return g_pgs_renderer->Defrost(data);
+	}
+#endif
+
+	if (!g_gs_renderer)
+		return -1;
+
 	if (mode == FreezeAction::Save)
 	{
 		return g_gs_renderer->Freeze(data, false);
@@ -469,6 +666,10 @@ int GSfreeze(FreezeAction mode, freezeData* data)
 
 void GSQueueSnapshot(const std::string& path, u32 gsdump_frames)
 {
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		g_pgs_renderer->QueueSnapshot(GSGetBaseSnapshotFilename(), gsdump_frames);
+#endif
 	if (g_gs_renderer)
 		g_gs_renderer->QueueSnapshot(path, gsdump_frames);
 }
@@ -495,11 +696,15 @@ void GSEndCapture()
 
 void GSPresentCurrentFrame()
 {
-	g_gs_renderer->PresentCurrentFrame();
+	if (g_gs_renderer)
+		g_gs_renderer->PresentCurrentFrame();
 }
 
 void GSThrottlePresentation()
 {
+	if (!g_gs_device)
+		return;
+
 	if (g_gs_device->GetVSyncMode() == GSVSyncMode::FIFO)
 	{
 		// Let vsync take care of throttling.
@@ -520,25 +725,49 @@ void GSGameChanged()
 
 bool GSHasDisplayWindow()
 {
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		return g_pgs_renderer->GetWindowInfo().type != WindowInfo::Type::Surfaceless;
+#else
 	pxAssert(g_gs_device);
-	return (g_gs_device->GetWindowInfo().type != WindowInfo::Type::Surfaceless);
+#endif
+
+	if (g_gs_device)
+		return (g_gs_device->GetWindowInfo().type != WindowInfo::Type::Surfaceless);
+	else
+		return false;
 }
 
 void GSResizeDisplayWindow(int width, int height, float scale)
 {
-	g_gs_device->ResizeWindow(width, height, scale);
-	ImGuiManager::WindowResized();
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		g_pgs_renderer->ResizeWindow(width, height, scale);
+#endif
+	if (g_gs_device)
+	{
+		g_gs_device->ResizeWindow(width, height, scale);
+		ImGuiManager::WindowResized();
+	}
 }
 
 void GSUpdateDisplayWindow()
 {
-	if (!g_gs_device->UpdateWindow())
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+	{
+		g_pgs_renderer->UpdateWindow();
+	}
+#endif
+
+	if (g_gs_device && !g_gs_device->UpdateWindow())
 	{
 		Host::ReportErrorAsync("Error", TRANSLATE_SV("GS", "Failed to change window after update. The log may contain more information."));
 		return;
 	}
 
-	ImGuiManager::WindowResized();
+	if (g_gs_device)
+		ImGuiManager::WindowResized();
 }
 
 void GSSetVSyncMode(GSVSyncMode mode, bool allow_present_throttle)
@@ -550,7 +779,12 @@ void GSSetVSyncMode(GSVSyncMode mode, bool allow_present_throttle)
 	}};
 	Console.WriteLnFmt(Color_StrongCyan, "Setting vsync mode: {}{}", modes[static_cast<size_t>(mode)],
 		allow_present_throttle ? " (throttle allowed)" : "");
-	g_gs_device->SetVSyncMode(mode, allow_present_throttle);
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		g_pgs_renderer->SetVSyncMode(mode, allow_present_throttle);
+#endif
+	if (g_gs_device)
+		g_gs_device->SetVSyncMode(mode, allow_present_throttle);
 }
 
 bool GSWantsExclusiveFullscreen()
@@ -599,6 +833,19 @@ std::vector<GSAdapterInfo> GSGetAdapterInfo(GSRendererType renderer)
 		break;
 #endif
 
+#ifdef HAVE_PARALLEL_GS
+		case GSRendererType::ParallelGS:
+		{
+			// Dummy info.
+			GSAdapterInfo adapter = {};
+			adapter.name = "default";
+			adapter.fullscreen_modes = { "fullscreen" };
+			adapter.max_texture_size = 4096;
+			adapter.max_upscale_multiplier = 4;
+			return { adapter };
+		}
+#endif
+
 #ifdef __APPLE__
 		case GSRendererType::Metal:
 		{
@@ -622,13 +869,29 @@ u32 GSGetMaxUpscaleMultiplier(u32 max_texture_size)
 
 GSVideoMode GSgetDisplayMode()
 {
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		return GSVideoMode{};
+#endif
+
 	GSRenderer* gs = g_gs_renderer.get();
 
-	return gs->GetVideoMode();
+	if (gs)
+		return gs->GetVideoMode();
+	else
+		return GSVideoMode{};
 }
 
 void GSgetInternalResolution(int* width, int* height)
 {
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+	{
+		g_pgs_renderer->GetInternalResolution(width, height);
+		return;
+	}
+#endif
+
 	GSRenderer* gs = g_gs_renderer.get();
 	if (!gs)
 	{
@@ -749,8 +1012,11 @@ void GSUpdateConfig(const Pcsx2Config::GSOptions& new_config)
 {
 	Pcsx2Config::GSOptions old_config(std::move(GSConfig));
 	GSConfig = new_config;
-	if (!g_gs_renderer)
-		return;
+
+#ifdef HAVE_PARALLEL_GS
+	if (g_pgs_renderer)
+		g_pgs_renderer->UpdateConfig();
+#endif
 
 	// Handle OSD scale changes by pushing a window resize through.
 	if (new_config.OsdScale != old_config.OsdScale)
@@ -764,6 +1030,9 @@ void GSUpdateConfig(const Pcsx2Config::GSOptions& new_config)
 		return;
 	}
 
+	if (!g_gs_renderer)
+		return;
+
 	// Ensure upscale multiplier is in range.
 	GSClampUpscaleMultiplier(GSConfig);
 
diff --git a/pcsx2/GS/GS.h b/pcsx2/GS/GS.h
index f2882c3a7..433bdfb62 100644
--- a/pcsx2/GS/GS.h
+++ b/pcsx2/GS/GS.h
@@ -20,6 +20,7 @@ enum class RenderAPI
 	Metal,
 	D3D12,
 	Vulkan,
+	Granite,
 	OpenGL
 };
 
@@ -110,6 +111,8 @@ bool GSSaveSnapshotToMemory(u32 window_width, u32 window_height, bool apply_aspe
 	u32* width, u32* height, std::vector<u32>* pixels);
 void GSJoinSnapshotThreads();
 
+float GetCurrentAspectRatioFloat(bool is_progressive);
+
 namespace Host
 {
 	/// Called when the GS is creating a render device.
diff --git a/pcsx2/GS/GSState.cpp b/pcsx2/GS/GSState.cpp
index 83068f15d..045201926 100644
--- a/pcsx2/GS/GSState.cpp
+++ b/pcsx2/GS/GSState.cpp
@@ -32,7 +32,7 @@ static __fi bool IsFirstProvokingVertex()
 	return (GSIsHardwareRenderer() && !g_gs_device->Features().provoking_vertex_last);
 }
 
-constexpr int GSState::GetSaveStateSize()
+int GSState::GetSaveStateSize()
 {
 	int size = 0;
 
diff --git a/pcsx2/GS/GSState.h b/pcsx2/GS/GSState.h
index 94f9a5442..5128a0043 100644
--- a/pcsx2/GS/GSState.h
+++ b/pcsx2/GS/GSState.h
@@ -21,7 +21,7 @@ public:
 	GSState();
 	virtual ~GSState();
 
-	static constexpr int GetSaveStateSize();
+	static int GetSaveStateSize();
 
 private:
 	// RESTRICT prevents multiple loads of the same part of the register when accessing its bitfields (the compiler is happy to know that memory writes in-between will not go there)
diff --git a/pcsx2/GS/GSUtil.cpp b/pcsx2/GS/GSUtil.cpp
index 63ae1db03..fdea62b2d 100644
--- a/pcsx2/GS/GSUtil.cpp
+++ b/pcsx2/GS/GSUtil.cpp
@@ -204,7 +204,9 @@ GSRendererType GSUtil::GetPreferredRenderer()
 	static GSRendererType preferred_renderer = GSRendererType::Auto;
 	if (preferred_renderer == GSRendererType::Auto)
 	{
-#if defined(__APPLE__)
+#if defined(HAVE_PARALLEL_GS)
+		preferred_renderer = GSRendererType::ParallelGS;
+#elif defined(__APPLE__)
 		// Mac: Prefer Metal hardware.
 		preferred_renderer = GSRendererType::Metal;
 #elif defined(_WIN32) && defined(_M_ARM64)
diff --git a/pcsx2/GS/Renderers/Common/GSRenderer.cpp b/pcsx2/GS/Renderers/Common/GSRenderer.cpp
index e564e0e6d..e29148065 100644
--- a/pcsx2/GS/Renderers/Common/GSRenderer.cpp
+++ b/pcsx2/GS/Renderers/Common/GSRenderer.cpp
@@ -275,7 +275,7 @@ float GSRenderer::GetModXYOffset()
 	return 0.0f;
 }
 
-static float GetCurrentAspectRatioFloat(bool is_progressive)
+float GetCurrentAspectRatioFloat(bool is_progressive)
 {
 	static constexpr std::array<float, static_cast<size_t>(AspectRatioType::MaxCount) + 1> ars = {{4.0f / 3.0f, 4.0f / 3.0f, 4.0f / 3.0f, 16.0f / 9.0f, 10.0f / 7.0f, 3.0f / 2.0f}};
 	return ars[static_cast<u32>(GSConfig.AspectRatio) + (3u * (is_progressive && GSConfig.AspectRatio == AspectRatioType::RAuto4_3_3_2))];
diff --git a/pcsx2/GS/Renderers/Vulkan/VKLoader.cpp b/pcsx2/GS/Renderers/Vulkan/VKLoader.cpp
index e386e6fe5..c7d538135 100644
--- a/pcsx2/GS/Renderers/Vulkan/VKLoader.cpp
+++ b/pcsx2/GS/Renderers/Vulkan/VKLoader.cpp
@@ -16,6 +16,8 @@
 
 extern "C" {
 
+#ifndef HAVE_PARALLEL_GS
+// Crude hack, but this conflicts with volk.
 #define VULKAN_MODULE_ENTRY_POINT(name, required) PFN_##name name;
 #define VULKAN_INSTANCE_ENTRY_POINT(name, required) PFN_##name name;
 #define VULKAN_DEVICE_ENTRY_POINT(name, required) PFN_##name name;
@@ -23,6 +25,7 @@ extern "C" {
 #undef VULKAN_DEVICE_ENTRY_POINT
 #undef VULKAN_INSTANCE_ENTRY_POINT
 #undef VULKAN_MODULE_ENTRY_POINT
+#endif
 }
 
 void Vulkan::ResetVulkanLibraryFunctionPointers()
@@ -79,7 +82,10 @@ bool Vulkan::LoadVulkanLibrary(Error* error)
 
 	if (required_functions_missing)
 	{
+#ifndef HAVE_PARALLEL_GS
+		// FIXME: parallel-gs share volk global pointers.
 		ResetVulkanLibraryFunctionPointers();
+#endif
 		s_vulkan_library.Close();
 		return false;
 	}
@@ -89,7 +95,10 @@ bool Vulkan::LoadVulkanLibrary(Error* error)
 
 void Vulkan::UnloadVulkanLibrary()
 {
+#ifndef HAVE_PARALLEL_GS
+	// FIXME: parallel-gs share volk global pointers.
 	ResetVulkanLibraryFunctionPointers();
+#endif
 	s_vulkan_library.Close();
 }
 
@@ -97,8 +106,13 @@ bool Vulkan::LoadVulkanInstanceFunctions(VkInstance instance)
 {
 	bool required_functions_missing = false;
 	auto LoadFunction = [&required_functions_missing, instance](PFN_vkVoidFunction* func_ptr, const char* name, bool is_required) {
-		*func_ptr = vkGetInstanceProcAddr(instance, name);
-		if (!(*func_ptr) && is_required)
+		auto proc = vkGetInstanceProcAddr(instance, name);
+		// Only override the global pointer if the pointer is non-null. This avoids a problem where GetAdapters()
+		// tries to load KHR_surface functions but fails since VK_KHR_surface is not enabled.
+		// Temporary hack for parallel-gs interoperability since they share volk implementation.
+		if (proc)
+			*func_ptr = proc;
+		if (!proc && is_required)
 		{
 			std::fprintf(stderr, "Vulkan: Failed to load required instance function %s\n", name);
 			required_functions_missing = true;
diff --git a/pcsx2/GS/Renderers/Vulkan/VKLoader.h b/pcsx2/GS/Renderers/Vulkan/VKLoader.h
index 736723fca..cfba3a7c9 100644
--- a/pcsx2/GS/Renderers/Vulkan/VKLoader.h
+++ b/pcsx2/GS/Renderers/Vulkan/VKLoader.h
@@ -7,24 +7,7 @@ class Error;
 
 #define VK_NO_PROTOTYPES
 
-#ifdef _WIN32
-#define VK_USE_PLATFORM_WIN32_KHR
-
-// vulkan.h pulls in windows.h on Windows, so we need to include our replacement header first
-#include "common/RedtapeWindows.h"
-#endif
-
-#if defined(X11_API)
-#define VK_USE_PLATFORM_XLIB_KHR
-#endif
-
-#if defined(WAYLAND_API)
-#define VK_USE_PLATFORM_WAYLAND_KHR
-#endif
-
-#if defined(__APPLE__)
-#define VK_USE_PLATFORM_METAL_EXT
-#endif
+#include "VKLoaderPlatformDefines.h"
 
 #include "vulkan/vulkan.h"
 
diff --git a/pcsx2/GS/Renderers/Vulkan/VKLoaderPlatformDefines.h b/pcsx2/GS/Renderers/Vulkan/VKLoaderPlatformDefines.h
new file mode 100644
index 000000000..d3447f6f7
--- /dev/null
+++ b/pcsx2/GS/Renderers/Vulkan/VKLoaderPlatformDefines.h
@@ -0,0 +1,23 @@
+// SPDX-FileCopyrightText: 2002-2024 PCSX2 Dev Team
+// SPDX-License-Identifier: LGPL-3.0+
+#pragma once
+
+#ifdef _WIN32
+#define VK_USE_PLATFORM_WIN32_KHR
+
+// vulkan.h pulls in windows.h on Windows, so we need to include our replacement header first
+#include "common/RedtapeWindows.h"
+#endif
+
+#if defined(X11_API)
+#define VK_USE_PLATFORM_XLIB_KHR
+#endif
+
+#if defined(WAYLAND_API)
+#define VK_USE_PLATFORM_WAYLAND_KHR
+#endif
+
+#if defined(__APPLE__)
+#define VK_USE_PLATFORM_METAL_EXT
+#endif
+
diff --git a/pcsx2/GS/Renderers/parallel-gs/GSRendererPGS.cpp b/pcsx2/GS/Renderers/parallel-gs/GSRendererPGS.cpp
new file mode 100644
index 000000000..4ac2c4bd7
--- /dev/null
+++ b/pcsx2/GS/Renderers/parallel-gs/GSRendererPGS.cpp
@@ -0,0 +1,845 @@
+// SPDX-FileCopyrightText: 2024 Hans-Kristian Arntzen
+// SPDX-License-Identifier: LGPL-3.0+
+
+#include "GSRendererPGS.h"
+#include "GS/GSState.h"
+#include "GS.h"
+#include "math.hpp"
+#include "muglm/muglm_impl.hpp"
+#include "shaders/slangmosh.hpp"
+#include "PerformanceMetrics.h"
+#include "VMManager.h"
+
+// Workaround because msbuild is broken when mixing C and C++ it seems ...
+#ifdef _MSC_VER
+extern "C" {
+#include "volk.c"
+}
+#endif
+
+using namespace Vulkan;
+using namespace ParallelGS;
+using namespace Granite;
+
+static void FsrEasuCon(
+	float *con0,
+	float *con1,
+	float *con2,
+	float *con3,
+	float inputViewportInPixelsX,
+	float inputViewportInPixelsY,
+	float inputSizeInPixelsX,
+	float inputSizeInPixelsY,
+	float outputSizeInPixelsX,
+	float outputSizeInPixelsY)
+{
+	// Output integer position to a pixel position in viewport.
+	con0[0] = inputViewportInPixelsX / outputSizeInPixelsX;
+	con0[1] = inputViewportInPixelsY / outputSizeInPixelsY;
+	con0[2] = 0.5f * inputViewportInPixelsX / outputSizeInPixelsX - 0.5f;
+	con0[3] = 0.5f * inputViewportInPixelsY / outputSizeInPixelsY - 0.5f;
+	con1[0] = 1.0f / inputSizeInPixelsX;
+	con1[1] = 1.0f / inputSizeInPixelsY;
+	con1[2] = 1.0f / inputSizeInPixelsX;
+	con1[3] = -1.0f / inputSizeInPixelsY;
+	con2[0] = -1.0f / inputSizeInPixelsX;
+	con2[1] = 2.0f / inputSizeInPixelsY;
+	con2[2] = 1.0f / inputSizeInPixelsX;
+	con2[3] = 2.0f / inputSizeInPixelsY;
+	con3[0] = 0.0f / inputSizeInPixelsX;
+	con3[1] = 4.0f / inputSizeInPixelsY;
+	con3[2] = con3[3] = 0.0f;
+}
+
+static void FsrRcasCon(float *con, float sharpness)
+{
+	sharpness = muglm::exp2(-sharpness);
+	uint32_t half = floatToHalf(sharpness);
+	con[0] = sharpness;
+	uint32_t halves = half | (half << 16);
+	memcpy(&con[1], &halves, sizeof(halves));
+	con[2] = 0.0f;
+	con[3] = 0.0f;
+}
+
+void GSRendererPGS::render_fsr(CommandBuffer &cmd, const ImageView &view)
+{
+	cmd.image_barrier(*fsr_render_target,
+		VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,
+		VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, 0,
+		VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT);
+
+	RenderPassInfo rp = {};
+	rp.num_color_attachments = 1;
+	rp.color_attachments[0] = &fsr_render_target->get_view();
+	rp.store_attachments = 1u << 0;
+
+	cmd.begin_render_pass(rp);
+	{
+		struct Constants
+		{
+			float params[4][4];
+		} constants;
+
+
+		auto width = float(view.get_image().get_width());
+		auto height = float(view.get_image().get_height());
+		auto *params = cmd.allocate_typed_constant_data<Constants>(1, 0, 1);
+		FsrEasuCon(constants.params[0], constants.params[1], constants.params[2], constants.params[3],
+			width, height, width, height, cmd.get_viewport().width, cmd.get_viewport().height);
+		*params = constants;
+
+		struct Push
+		{
+			float width, height;
+		} push;
+
+		push.width = cmd.get_viewport().width;
+		push.height = cmd.get_viewport().height;
+		cmd.push_constants(&push, 0, sizeof(push));
+
+		const vec2 vertex_data[] = { vec2(-1.0f, -1.0f), vec2(-1.0f, 3.0f), vec2(3.0f, -1.0f) };
+		memcpy(cmd.allocate_vertex_data(0, sizeof(vertex_data), sizeof(vec2)), vertex_data, sizeof(vertex_data));
+		cmd.set_vertex_attrib(0, 0, VK_FORMAT_R32G32_SFLOAT, 0);
+
+		cmd.set_texture(0, 0, view, StockSampler::NearestClamp);
+
+		cmd.set_program(upscale_program);
+		cmd.set_opaque_state();
+		cmd.set_depth_test(false, false);
+		cmd.draw(3);
+	}
+	cmd.end_render_pass();
+
+	cmd.image_barrier(*fsr_render_target,
+		VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
+		VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,
+		VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, VK_ACCESS_2_SHADER_SAMPLED_READ_BIT);
+}
+
+void GSRendererPGS::render_rcas(CommandBuffer &cmd, const ImageView &view,
+                                float offset_x, float offset_y,
+                                float width, float height)
+{
+	struct Constants
+	{
+		float params[4];
+		int32_t range[4];
+	} constants;
+
+	FsrRcasCon(constants.params, 0.5f);
+	constants.range[0] = 0;
+	constants.range[1] = 0;
+	constants.range[2] = int(view.get_view_width()) - 1;
+	constants.range[3] = int(view.get_view_height()) - 1;
+	auto *params = cmd.allocate_typed_constant_data<Constants>(1, 0, 1);
+	*params = constants;
+
+	const vec2 vertex_data[] = { vec2(-1.0f, -1.0f), vec2(-1.0f, 3.0f), vec2(3.0f, -1.0f) };
+	memcpy(cmd.allocate_vertex_data(0, sizeof(vertex_data), sizeof(vec2)), vertex_data, sizeof(vertex_data));
+	cmd.set_vertex_attrib(0, 0, VK_FORMAT_R32G32_SFLOAT, 0);
+	cmd.set_srgb_texture(0, 0, view);
+	cmd.set_sampler(0, 0, Vulkan::StockSampler::NearestClamp);
+	cmd.set_opaque_state();
+	cmd.set_depth_test(false, false);
+	cmd.set_program(sharpen_program);
+
+	struct Push
+	{
+		float width, height;
+	} push;
+
+	push.width = width;
+	push.height = height;
+	cmd.push_constants(&push, 0, sizeof(push));
+
+	cmd.set_viewport({ offset_x, offset_y, width, height, 0.0f, 1.0f });
+	cmd.draw(3);
+}
+
+void GSRendererPGS::render_blit(CommandBuffer &cmd, const ImageView &view,
+                                float offset_x, float offset_y,
+                                float width, float height)
+{
+	cmd.set_srgb_texture(0, 0, view);
+	cmd.set_sampler(0, 0, GSConfig.LinearPresent != GSPostBilinearMode::Off ?
+	                      Vulkan::StockSampler::LinearClamp : Vulkan::StockSampler::NearestClamp);
+	cmd.set_opaque_state();
+	cmd.set_depth_test(false, false);
+	cmd.set_program(blit_program);
+
+	cmd.set_viewport({ offset_x, offset_y, width, height, 0.0f, 1.0f });
+	cmd.draw(3);
+}
+
+GSRendererPGS::GSRendererPGS(u8 *basemem)
+	: priv(reinterpret_cast<PrivRegisterState *>(basemem))
+{
+	wsi.set_backbuffer_format(BackbufferFormat::sRGB);
+}
+
+u8 *GSRendererPGS::GetRegsMem()
+{
+	return reinterpret_cast<u8 *>(priv);
+}
+
+struct ParsedSuperSampling
+{
+	SuperSampling super_sampling;
+	bool ordered;
+};
+
+static ParsedSuperSampling parse_super_sampling_options(u8 super_sampling)
+{
+	ParsedSuperSampling parsed = {};
+
+	if (super_sampling > 5)
+		super_sampling = 5;
+
+	parsed.ordered = super_sampling == 3;
+
+	if (super_sampling >= 3)
+		super_sampling--;
+	parsed.super_sampling = SuperSampling(1u << super_sampling);
+
+	return parsed;
+}
+
+bool GSRendererPGS::Init()
+{
+	// Always force the reload, since the other backends may clobber the volk pointers.
+	if (!Context::init_loader(nullptr, true))
+		return false;
+
+	wsi.set_platform(this);
+	wsi.set_frame_duplication_aware(true);
+	bool ret = wsi.init_simple(1, {});
+	if (!ret)
+		return false;
+
+	// We will cycle through many memory contexts per frame most likely.
+	wsi.get_device().init_frame_contexts(12);
+
+	ResourceLayout layout;
+	Shaders<> suite(wsi.get_device(), layout, 0);
+	upscale_program = wsi.get_device().request_program(suite.upscale_vert, suite.upscale_frag);
+	sharpen_program = wsi.get_device().request_program(suite.sharpen_vert, suite.sharpen_frag);
+	blit_program = wsi.get_device().request_program(suite.quad, suite.blit);
+
+	GSOptions opts = {};
+	opts.vram_size = GSLocalMemory::m_vmsize;
+
+	auto parsed = parse_super_sampling_options(GSConfig.PGSSuperSampling);
+	opts.super_sampling = parsed.super_sampling;
+	opts.ordered_super_sampling = parsed.ordered;
+
+	opts.dynamic_super_sampling = true;
+	opts.super_sampled_textures = GSConfig.PGSSuperSampleTextures != 0;
+	if (!iface.init(&wsi.get_device(), opts))
+		return false;
+
+	current_super_sampling = opts.super_sampling;
+	current_ordered_super_sampling = opts.ordered_super_sampling;
+	current_super_sample_textures = opts.super_sampled_textures;
+
+	Hacks hacks;
+	hacks.disable_mipmaps = GSConfig.PGSDisableMipmaps != 0;
+	hacks.unsynced_readbacks = GSConfig.PGSDisableReadbackSync != 0;
+	hacks.backbuffer_promotion = GSConfig.PGSSharpBackbuffer != 0;
+	hacks.allow_blend_demote = GSConfig.PGSBlendDemotion != 0;
+	iface.set_hacks(hacks);
+
+	return true;
+}
+
+void GSRendererPGS::Reset(bool /*hardware_reset*/)
+{
+	iface.reset_context_state();
+}
+
+void GSRendererPGS::UpdateConfig()
+{
+	auto parsed = parse_super_sampling_options(GSConfig.PGSSuperSampling);
+
+	if (parsed.super_sampling != current_super_sampling || parsed.ordered != current_ordered_super_sampling ||
+	    current_super_sample_textures != bool(GSConfig.PGSSuperSampleTextures))
+	{
+		iface.set_super_sampling_rate(parsed.super_sampling, parsed.ordered, GSConfig.PGSSuperSampleTextures != 0);
+		current_super_sampling = parsed.super_sampling;
+		current_ordered_super_sampling = parsed.ordered;
+		current_super_sample_textures = GSConfig.PGSSuperSampleTextures != 0;
+	}
+
+	Hacks hacks;
+	hacks.disable_mipmaps = GSConfig.PGSDisableMipmaps != 0;
+	hacks.unsynced_readbacks = GSConfig.PGSDisableReadbackSync != 0;
+	hacks.backbuffer_promotion = GSConfig.PGSSharpBackbuffer != 0;
+	hacks.allow_blend_demote = GSConfig.PGSBlendDemotion != 0;
+	iface.set_hacks(hacks);
+}
+
+int GSRendererPGS::GetSaveStateSize()
+{
+	return GSState::GetSaveStateSize();
+}
+
+static void write_data(u8*& dst, const void* src, size_t size)
+{
+	memcpy(dst, src, size);
+	dst += size;
+}
+
+template <typename T>
+static void write_reg(u8*& data, T t)
+{
+	write_data(data, &t, sizeof(t));
+}
+
+static void read_data(const u8*& src, void* dst, size_t size)
+{
+	memcpy(dst, src, size);
+	src += size;
+}
+
+template <typename T>
+static void read_reg(const u8*& src, T &t)
+{
+	read_data(src, &t, sizeof(t));
+}
+
+int GSRendererPGS::Freeze(freezeData* data, bool sizeonly)
+{
+	if (sizeonly)
+	{
+		data->size = GetSaveStateSize();
+		return 0;
+	}
+
+	if (!data->data || data->size < GetSaveStateSize())
+		return -1;
+
+	const void *vram = iface.map_vram_read(0, GSLocalMemory::m_vmsize);
+	auto &regs = iface.get_register_state();
+
+	u8 *ptr = data->data;
+
+	write_reg(ptr, GSState::STATE_VERSION);
+	write_reg(ptr, regs.prim);
+	write_reg(ptr, regs.prmodecont);
+	write_reg(ptr, regs.texclut);
+	write_reg(ptr, regs.scanmsk);
+	write_reg(ptr, regs.texa);
+	write_reg(ptr, regs.fogcol);
+	write_reg(ptr, regs.dimx);
+	write_reg(ptr, regs.dthe);
+	write_reg(ptr, regs.colclamp);
+	write_reg(ptr, regs.pabe);
+	write_reg(ptr, regs.bitbltbuf);
+	write_reg(ptr, regs.trxdir);
+	write_reg(ptr, regs.trxpos);
+	write_reg(ptr, regs.trxreg);
+	write_reg(ptr, regs.trxreg); // Dummy value
+
+	for (const auto &ctx : regs.ctx)
+	{
+		write_reg(ptr, ctx.xyoffset);
+		write_reg(ptr, ctx.tex0);
+		write_reg(ptr, ctx.tex1);
+		write_reg(ptr, ctx.clamp);
+		write_reg(ptr, ctx.miptbl_1_3);
+		write_reg(ptr, ctx.miptbl_4_6);
+		write_reg(ptr, ctx.scissor);
+		write_reg(ptr, ctx.alpha);
+		write_reg(ptr, ctx.test);
+		write_reg(ptr, ctx.fba);
+		write_reg(ptr, ctx.frame);
+		write_reg(ptr, ctx.zbuf);
+	}
+
+	write_reg(ptr, regs.rgbaq);
+	write_reg(ptr, regs.st);
+	write_reg(ptr, regs.uv.words[0]);
+	write_reg(ptr, regs.fog.words[0]);
+	// XYZ register, fill with dummy.
+	write_reg(ptr, Reg64<XYZBits>{0});
+
+	write_reg(ptr, UINT32_MAX); // Dummy GIFReg
+	write_reg(ptr, UINT32_MAX);
+
+	// Dummy transfer X/Y
+	write_reg(ptr, uint32_t(0));
+	write_reg(ptr, uint32_t(0));
+
+	write_data(ptr, vram, GSLocalMemory::m_vmsize);
+
+	// 4 GIF paths
+	for (int i = 0; i < 4; i++)
+	{
+		auto gif_path = iface.get_gif_path(i);
+		gif_path.tag.NLOOP -= gif_path.loop;
+		write_data(ptr, &gif_path.tag, sizeof(gif_path.tag));
+		write_reg(ptr, gif_path.reg);
+	}
+
+	// internal_Q
+	write_reg(ptr, regs.internal_q);
+	return 0;
+}
+
+int GSRendererPGS::Defrost(freezeData* data)
+{
+	if (!data || !data->data || data->size == 0)
+		return -1;
+
+	if (data->size < GetSaveStateSize())
+		return -1;
+
+	const u8* ptr = data->data;
+	auto &regs = iface.get_register_state();
+
+	u32 version;
+	read_reg(ptr, version);
+
+	if (version != GSState::STATE_VERSION)
+	{
+		Console.Error("GS: Savestate version is incompatible.  Load aborted.");
+		return -1;
+	}
+
+	read_reg(ptr, regs.prim);
+	read_reg(ptr, regs.prmodecont);
+	read_reg(ptr, regs.texclut);
+	read_reg(ptr, regs.scanmsk);
+	read_reg(ptr, regs.texa);
+	read_reg(ptr, regs.fogcol);
+	read_reg(ptr, regs.dimx);
+	read_reg(ptr, regs.dthe);
+	read_reg(ptr, regs.colclamp);
+	read_reg(ptr, regs.pabe);
+	read_reg(ptr, regs.bitbltbuf);
+	read_reg(ptr, regs.trxdir);
+	read_reg(ptr, regs.trxpos);
+	read_reg(ptr, regs.trxreg);
+	// Dummy value
+	ptr += sizeof(uint64_t);
+
+	for (auto &ctx : regs.ctx)
+	{
+		read_reg(ptr, ctx.xyoffset);
+		read_reg(ptr, ctx.tex0);
+		read_reg(ptr, ctx.tex1);
+		read_reg(ptr, ctx.clamp);
+		read_reg(ptr, ctx.miptbl_1_3);
+		read_reg(ptr, ctx.miptbl_4_6);
+		read_reg(ptr, ctx.scissor);
+		read_reg(ptr, ctx.alpha);
+		read_reg(ptr, ctx.test);
+		read_reg(ptr, ctx.fba);
+		read_reg(ptr, ctx.frame);
+		read_reg(ptr, ctx.zbuf);
+	}
+
+	read_reg(ptr, regs.rgbaq);
+	read_reg(ptr, regs.st);
+	read_reg(ptr, regs.uv.words[0]);
+	read_reg(ptr, regs.fog.words[0]);
+	// XYZ register, fill with dummy.
+	ptr += sizeof(uint64_t);
+
+	// Dummy GIFReg
+	ptr += 2 * sizeof(uint32_t);
+
+	// Dummy transfer X/Y
+	ptr += 2 * sizeof(uint32_t);
+
+	void *vram = iface.map_vram_write(0, GSLocalMemory::m_vmsize);
+	read_data(ptr, vram, GSLocalMemory::m_vmsize);
+	iface.end_vram_write(0, GSLocalMemory::m_vmsize);
+
+	// 4 GIF paths
+	for (int i = 0; i < 4; i++)
+	{
+		auto gif_path = iface.get_gif_path(i);
+		gif_path.tag.NLOOP -= gif_path.loop;
+		read_data(ptr, &gif_path.tag, sizeof(gif_path.tag));
+		gif_path.loop = 0;
+		read_reg(ptr, gif_path.reg);
+	}
+
+	// internal_Q
+	read_reg(ptr, iface.get_register_state().internal_q);
+
+	iface.clobber_register_state();
+	return 0;
+}
+
+void GSRendererPGS::VSync(u32 field, bool registers_written)
+{
+	if (dump)
+	{
+		if (dump->VSync(field, dump_frames == 0, reinterpret_cast<GSPrivRegSet *>(priv)))
+			dump.reset();
+		else if (dump_frames != 0)
+			dump_frames--;
+	}
+
+	iface.flush();
+	iface.get_priv_register_state() = *priv;
+
+	VSyncInfo info = {};
+
+	info.phase = field;
+
+	// Apparently this is needed for some games. It's set by game-fixes.
+	// I assume this problem exists at a higher level than whatever GS controls, so we'll just
+	// apply this hack too.
+	if (GSConfig.InterlaceMode != GSInterlaceMode::Automatic)
+		info.phase ^= (static_cast<int>(GSConfig.InterlaceMode) - 2) & 1;
+
+	info.anti_blur = GSConfig.PCRTCAntiBlur;
+	info.force_progressive = true;
+	info.overscan = GSConfig.PCRTCOverscan;
+	info.crtc_offsets = GSConfig.PCRTCOffsets;
+	info.dst_access = VK_ACCESS_2_SHADER_SAMPLED_READ_BIT;
+	info.dst_stage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;
+	info.dst_layout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
+	// The scaling blur is technically a blur ...
+	info.adapt_to_internal_horizontal_resolution = GSConfig.PCRTCAntiBlur;
+	info.raw_circuit_scanout = true;
+	info.high_resolution_scanout = GSConfig.PGSHighResScanout != 0;
+
+	auto stats = iface.consume_flush_stats();
+	bool frame_is_duped = !registers_written && stats.num_render_passes == 0 && stats.num_copies == 0;
+
+	// Don't waste GPU time scanning out the same thing twice.
+	if (!frame_is_duped || !vsync.image || !iface.vsync_can_skip(info))
+		vsync = iface.vsync(info);
+
+	// Experimental heuristic. If running on an iGPU / APU, we're quite wary about draining the GPU for work
+	// in GPU bound scenarios. This should keep the GPU better fed at the cost of a little more latency.
+	if (wsi.get_device().get_gpu_properties().deviceType == VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU &&
+	    frame_is_duped && !GSConfig.SkipDuplicateFrames)
+	{
+		wsi.set_next_present_is_duplicated();
+	}
+
+	if (GSConfig.SkipDuplicateFrames && has_presented_in_current_swapchain && frame_is_duped)
+	{
+		PerformanceMetrics::Update(false, false, true);
+		return;
+	}
+
+	if (vsync.image)
+	{
+		last_internal_width = vsync.internal_width;
+		last_internal_height = vsync.internal_height;
+		if (vsync.high_resolution_scanout)
+		{
+			last_internal_width *= 2;
+			last_internal_height *= 2;
+		}
+	}
+
+	if (!has_wsi_begin_frame)
+		has_wsi_begin_frame = wsi.begin_frame();
+
+	if (!has_wsi_begin_frame)
+		return;
+
+	auto &dev = wsi.get_device();
+
+	float vp_offset_x = 0.0f;
+	float vp_offset_y = 0.0f;
+	float vp_width = 0.0f;
+	float vp_height = 0.0f;
+
+	if (GSConfig.LinearPresent != GSPostBilinearMode::BilinearSharp || !vsync.image)
+		fsr_render_target.reset();
+
+	bool fsr_render_is_valid = frame_is_duped && bool(fsr_render_target);
+
+	if (vsync.image)
+	{
+		uint32_t fsr_width = dev.get_swapchain_view().get_view_width();
+		uint32_t fsr_height = dev.get_swapchain_view().get_view_height();
+		uint32_t new_width = fsr_width;
+		uint32_t new_height = fsr_height;
+
+		float display_aspect = float(fsr_width) / float(fsr_height);
+		float game_aspect = GetCurrentAspectRatioFloat(priv->smode1.CMOD == 0);
+
+		float horizontal_scanout_ratio = float(vsync.internal_width) / float(vsync.mode_width);
+		float vertical_scanout_ratio = float(vsync.internal_height) / float(vsync.mode_height);
+		game_aspect *= horizontal_scanout_ratio / vertical_scanout_ratio;
+
+		if (display_aspect > game_aspect)
+			new_width = uint32_t(std::round(float(fsr_height) * game_aspect));
+		else
+			new_height = uint32_t(std::round(float(fsr_width) / game_aspect));
+
+		// This won't preserve the aspect ratio necessarily, but eh.
+		if (GSConfig.IntegerScaling)
+		{
+			new_width -= new_width % vsync.image->get_width();
+			new_height -= new_height % vsync.image->get_height();
+			if (new_width == 0)
+				new_width = fsr_width;
+			if (new_height == 0)
+				new_height = fsr_height;
+		}
+
+		vp_offset_x = std::round(0.5f * float(fsr_width - new_width));
+		fsr_width = new_width;
+		vp_offset_y = std::round(0.5f * float(fsr_height - new_height));
+		fsr_height = new_height;
+
+		// Safeguard against ridiculous situations.
+		if (!fsr_width)
+			fsr_width = 1;
+		if (!fsr_height)
+			fsr_height = 1;
+
+		vp_width = float(fsr_width);
+		vp_height = float(fsr_height);
+
+		if (GSConfig.LinearPresent == GSPostBilinearMode::BilinearSharp)
+		{
+			if (!fsr_render_target || fsr_render_target->get_width() != fsr_width || fsr_render_target->get_height() != fsr_height)
+			{
+				auto fsr_info = ImageCreateInfo::render_target(fsr_width, fsr_height, VK_FORMAT_R8G8B8A8_UNORM);
+				fsr_info.initial_layout = VK_IMAGE_LAYOUT_UNDEFINED;
+				fsr_info.usage |= VK_IMAGE_USAGE_SAMPLED_BIT;
+				fsr_info.misc |= IMAGE_MISC_MUTABLE_SRGB_BIT;
+				fsr_render_target = dev.create_image(fsr_info);
+				fsr_render_is_valid = false;
+			}
+		}
+	}
+
+	auto cmd = dev.request_command_buffer();
+	// No need to do the upscaling twice when duping frames.
+	if (vsync.image && fsr_render_target && !fsr_render_is_valid)
+		render_fsr(*cmd, vsync.image->get_view());
+	cmd->begin_render_pass(dev.get_swapchain_render_pass(SwapchainRenderPass::ColorOnly));
+	if (vsync.image)
+	{
+		// The RCAS pass is basically free.
+		if (fsr_render_target)
+			render_rcas(*cmd, fsr_render_target->get_view(), vp_offset_x, vp_offset_y, vp_width, vp_height);
+		else
+			render_blit(*cmd, vsync.image->get_view(), vp_offset_x, vp_offset_y, vp_width, vp_height);
+	}
+	cmd->end_render_pass();
+	dev.submit(cmd);
+
+	wsi.end_frame();
+	has_wsi_begin_frame = false;
+	// For pacing purposes.
+	has_wsi_begin_frame = wsi.begin_frame();
+	has_presented_in_current_swapchain = true;
+
+	PerformanceMetrics::Update(registers_written, stats.num_render_passes != 0, false);
+}
+
+void GSRendererPGS::Transfer(const u8* mem, u32 size)
+{
+	size *= 16;
+	iface.gif_transfer(3, mem, size);
+	if (dump)
+		dump->Transfer(3, mem, size);
+}
+
+void GSRendererPGS::ReadFIFO(u8 *mem, u32 size)
+{
+	iface.read_transfer_fifo(mem, size);
+	if (dump)
+		dump->ReadFIFO(size);
+}
+
+void GSRendererPGS::GetInternalResolution(int *width, int *height)
+{
+	*width = int(last_internal_width);
+	*height = int(last_internal_height);
+}
+
+bool GSRendererPGS::UpdateWindow()
+{
+	iface.flush();
+
+	std::optional<WindowInfo> window = Host::AcquireRenderWindow(true);
+	if (window.has_value())
+	{
+		window_info = window.value();
+		wsi.deinit_surface_and_swapchain();
+		return wsi.init_surface_swapchain();
+	}
+	else
+		return false;
+}
+
+void GSRendererPGS::ResizeWindow(int width, int height, float /*scale*/)
+{
+	resize = true;
+	window_info.surface_width = width;
+	window_info.surface_height = height;
+	// TODO: No idea what to do about scale.
+}
+
+const WindowInfo &GSRendererPGS::GetWindowInfo() const
+{
+	return window_info;
+}
+
+void GSRendererPGS::SetVSyncMode(GSVSyncMode mode, bool /*allow_present_throttle*/)
+{
+	if (mode == GSVSyncMode::FIFO)
+		wsi.set_present_mode(PresentMode::SyncToVBlank);
+	else if (mode == GSVSyncMode::Mailbox)
+		wsi.set_present_mode(PresentMode::UnlockedNoTearing);
+	else
+		wsi.set_present_mode(PresentMode::UnlockedMaybeTear);
+	// Unknown what allow_present_throttle means.
+}
+
+VkSurfaceKHR GSRendererPGS::create_surface(VkInstance instance, VkPhysicalDevice gpu)
+{
+	if (window_info.type == WindowInfo::Type::Surfaceless)
+	{
+		std::optional<WindowInfo> window = Host::AcquireRenderWindow(true);
+		if (window.has_value())
+			window_info = window.value();
+	}
+
+	if (window_info.type == WindowInfo::Type::Surfaceless)
+		return VK_NULL_HANDLE;
+
+#if defined(X11_API)
+	if (window_info.type == WindowInfo::Type::X11)
+	{
+		VkXlibSurfaceCreateInfoKHR info = { VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR };
+		info.dpy = static_cast<Display *>(window_info.display_connection);
+		info.window = reinterpret_cast<Window>(window_info.window_handle);
+		VkSurfaceKHR surface;
+		if (vkCreateXlibSurfaceKHR(instance, &info, nullptr, &surface) == VK_SUCCESS)
+			return surface;
+	}
+#endif
+#if defined(WAYLAND_API)
+	if (window_info.type == WindowInfo::Type::Wayland)
+	{
+		VkWaylandSurfaceCreateInfoKHR info = { VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR };
+		info.display = static_cast<wl_display *>(window_info.display_connection);
+		info.surface = static_cast<wl_surface *>(window_info.window_handle);
+		VkSurfaceKHR surface;
+		if (vkCreateWaylandSurfaceKHR(instance, &info, nullptr, &surface) == VK_SUCCESS)
+			return surface;
+	}
+#endif
+#if defined(_WIN32)
+	if (window_info.type == WindowInfo::Type::Win32)
+	{
+		VkWin32SurfaceCreateInfoKHR info = { VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR };
+		info.hwnd = static_cast<HWND>(window_info.window_handle);
+		VkSurfaceKHR surface;
+		if (vkCreateWin32SurfaceKHR(instance, &info, nullptr, &surface) == VK_SUCCESS)
+			return surface;
+	}
+#endif
+
+	return VK_NULL_HANDLE;
+}
+
+void GSRendererPGS::destroy_surface(VkInstance instance, VkSurfaceKHR surface)
+{
+	WSIPlatform::destroy_surface(instance, surface);
+}
+
+std::vector<const char *> GSRendererPGS::get_instance_extensions()
+{
+	return {
+		VK_KHR_SURFACE_EXTENSION_NAME,
+#if defined(X11_API)
+		VK_KHR_XLIB_SURFACE_EXTENSION_NAME,
+#endif
+#if defined(WAYLAND_API)
+		VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME,
+#endif
+#if defined(_WIN32)
+		VK_KHR_WIN32_SURFACE_EXTENSION_NAME,
+#endif
+	};
+}
+
+std::vector<const char *> GSRendererPGS::get_device_extensions()
+{
+	return { VK_KHR_SWAPCHAIN_EXTENSION_NAME };
+}
+
+bool GSRendererPGS::alive(WSI &)
+{
+	return true;
+}
+
+uint32_t GSRendererPGS::get_surface_width()
+{
+	return window_info.surface_width;
+}
+
+uint32_t GSRendererPGS::get_surface_height()
+{
+	return window_info.surface_height;
+}
+
+void GSRendererPGS::poll_input()
+{
+	// Dummy, we don't care about input here.
+}
+
+void GSRendererPGS::poll_input_async(Granite::InputTrackerHandler *)
+{
+	// Dummy, we don't care about input here.
+}
+
+void GSRendererPGS::event_swapchain_destroyed()
+{
+	WSIPlatform::event_swapchain_destroyed();
+	has_wsi_begin_frame = false;
+	has_presented_in_current_swapchain = false;
+}
+
+void GSRendererPGS::QueueSnapshot(const std::string &path, u32 gsdump_frames)
+{
+	freezeData fd = {0, nullptr};
+	Freeze(&fd, true);
+	fd.data = new u8[fd.size];
+	Freeze(&fd, false);
+
+	if (GSConfig.GSDumpCompression == GSDumpCompressionMethod::Uncompressed)
+	{
+		dump = GSDumpBase::CreateUncompressedDump(path, VMManager::GetDiscSerial(),
+		                                          VMManager::GetDiscCRC(), 0, 0,
+		                                          nullptr, fd, reinterpret_cast<GSPrivRegSet *>(priv));
+	}
+	else if (GSConfig.GSDumpCompression == GSDumpCompressionMethod::LZMA)
+	{
+		dump = GSDumpBase::CreateXzDump(path, VMManager::GetDiscSerial(),
+		                                VMManager::GetDiscCRC(), 0, 0,
+		                                nullptr, fd, reinterpret_cast<GSPrivRegSet *>(priv));
+	}
+	else
+	{
+		dump = GSDumpBase::CreateZstDump(path, VMManager::GetDiscSerial(),
+		                                 VMManager::GetDiscCRC(), 0, 0,
+		                                 nullptr, fd, reinterpret_cast<GSPrivRegSet *>(priv));
+	}
+
+	dump_frames = gsdump_frames;
+	delete[] fd.data;
+}
+
+const VkApplicationInfo *GSRendererPGS::get_application_info()
+{
+	static const VkApplicationInfo app = { VK_STRUCTURE_TYPE_APPLICATION_INFO, nullptr,
+	                                       "pcsx2", 0, "Granite", 0, VK_API_VERSION_1_3 };
+	return &app;
+}
diff --git a/pcsx2/GS/Renderers/parallel-gs/GSRendererPGS.h b/pcsx2/GS/Renderers/parallel-gs/GSRendererPGS.h
new file mode 100644
index 000000000..f2ff289d9
--- /dev/null
+++ b/pcsx2/GS/Renderers/parallel-gs/GSRendererPGS.h
@@ -0,0 +1,88 @@
+// SPDX-FileCopyrightText: 2024 Hans-Kristian Arntzen
+// SPDX-License-Identifier: LGPL-3.0+
+
+#pragma once
+
+#include "../Vulkan/VKLoaderPlatformDefines.h"
+#include "SaveState.h"
+#include "GS/GSDump.h"
+#include "Config.h"
+#include "common/WindowInfo.h"
+#include "gs_interface.hpp"
+#include "device.hpp"
+#include "context.hpp"
+#include "wsi.hpp"
+
+class GSRendererPGS final : private Vulkan::WSIPlatform
+{
+public:
+	explicit GSRendererPGS(u8 *basemem);
+
+	bool Init();
+	bool UpdateWindow();
+	void ResizeWindow(int width, int height, float scale);
+	const WindowInfo &GetWindowInfo() const;
+	void SetVSyncMode(GSVSyncMode mode, bool allow_present_throttle);
+	void Reset(bool hardware_reset);
+
+	void Transfer(const u8 *mem, u32 size);
+
+	void VSync(u32 field, bool registers_written);
+	inline ParallelGS::GSInterface &get_interface() { return iface; };
+	void ReadFIFO(u8 *mem, u32 size);
+
+	void UpdateConfig();
+
+	void GetInternalResolution(int *width, int *height);
+
+	int Freeze(freezeData *data, bool sizeonly);
+	int Defrost(freezeData *data);
+
+	u8 *GetRegsMem();
+
+	void QueueSnapshot(const std::string &path, u32 gsdump_frames);
+
+private:
+	VkSurfaceKHR create_surface(VkInstance instance, VkPhysicalDevice gpu) override;
+	void destroy_surface(VkInstance instance, VkSurfaceKHR surface) override;
+	std::vector<const char *> get_instance_extensions() override;
+	std::vector<const char *> get_device_extensions() override;
+	bool alive(Vulkan::WSI &wsi) override;
+	uint32_t get_surface_width() override;
+	uint32_t get_surface_height() override;
+	void poll_input() override;
+	void poll_input_async(Granite::InputTrackerHandler *) override;
+
+	ParallelGS::PrivRegisterState *priv;
+	Vulkan::WSI wsi;
+	ParallelGS::GSInterface iface;
+	WindowInfo window_info = {};
+	bool has_wsi_begin_frame = false;
+
+	Vulkan::Program *upscale_program = nullptr;
+	Vulkan::Program *sharpen_program = nullptr;
+	Vulkan::Program *blit_program = nullptr;
+	void render_fsr(Vulkan::CommandBuffer &cmd, const Vulkan::ImageView &view);
+	void render_rcas(Vulkan::CommandBuffer &cmd, const Vulkan::ImageView &view,
+	                 float offset_x, float offset_y,
+	                 float width, float height);
+	void render_blit(Vulkan::CommandBuffer &cmd, const Vulkan::ImageView &view,
+	                 float offset_x, float offset_y,
+	                 float width, float height);
+	void event_swapchain_destroyed() override;
+	Vulkan::ImageHandle fsr_render_target;
+	ParallelGS::ScanoutResult vsync;
+
+	ParallelGS::SuperSampling current_super_sampling = ParallelGS::SuperSampling::X1;
+	bool current_ordered_super_sampling = false;
+	bool current_super_sample_textures = false;
+	bool has_presented_in_current_swapchain = false;
+	uint32_t last_internal_width = 0;
+	uint32_t last_internal_height = 0;
+
+	static int GetSaveStateSize();
+	const VkApplicationInfo* get_application_info() override;
+
+	std::unique_ptr<GSDumpBase> dump;
+	uint32_t dump_frames = 0;
+};
diff --git a/pcsx2/ImGui/ImGuiFullscreen.cpp b/pcsx2/ImGui/ImGuiFullscreen.cpp
index 8d9a8a07e..d20b14963 100644
--- a/pcsx2/ImGui/ImGuiFullscreen.cpp
+++ b/pcsx2/ImGui/ImGuiFullscreen.cpp
@@ -586,6 +586,8 @@ ImGuiFullscreen::FocusResetType ImGuiFullscreen::GetQueuedFocusResetType()
 
 void ImGuiFullscreen::ForceKeyNavEnabled()
 {
+	if (!ImGui::GetCurrentContext())
+		return;
 	ImGuiContext& g = *ImGui::GetCurrentContext();
 	g.ActiveIdSource = (g.ActiveIdSource == ImGuiInputSource_Mouse) ? ImGuiInputSource_Keyboard : g.ActiveIdSource;
 	g.NavInputSource = (g.NavInputSource == ImGuiInputSource_Mouse) ? ImGuiInputSource_Keyboard : g.ActiveIdSource;
diff --git a/pcsx2/Pcsx2Config.cpp b/pcsx2/Pcsx2Config.cpp
index be60b540f..dcac84b63 100644
--- a/pcsx2/Pcsx2Config.cpp
+++ b/pcsx2/Pcsx2Config.cpp
@@ -683,6 +683,7 @@ const char* Pcsx2Config::GSOptions::GetRendererName(GSRendererType type)
 		case GSRendererType::VK:    return "Vulkan";
 		case GSRendererType::SW:    return "Software";
 		case GSRendererType::Null:  return "Null";
+		case GSRendererType::ParallelGS: return "paraLLEl";
 		default:                    return "";
 			// clang-format on
 	}
@@ -860,7 +861,14 @@ bool Pcsx2Config::GSOptions::OptionsAreEqual(const GSOptions& right) const
 		OpEqu(Adapter) &&
 
 		OpEqu(HWDumpDirectory) &&
-		OpEqu(SWDumpDirectory));
+		OpEqu(SWDumpDirectory)) &&
+		OpEqu(PGSSuperSampling) &&
+		OpEqu(PGSHighResScanout) &&
+		OpEqu(PGSSuperSampleTextures) &&
+		OpEqu(PGSDisableMipmaps) &&
+		OpEqu(PGSDisableReadbackSync) &&
+		OpEqu(PGSSharpBackbuffer) &&
+		OpEqu(PGSBlendDemotion);
 }
 
 bool Pcsx2Config::GSOptions::operator!=(const GSOptions& right) const
@@ -942,6 +950,13 @@ void Pcsx2Config::GSOptions::LoadSave(SettingsWrapper& wrap)
 	SettingsWrapBitBool(HWSpinCPUForReadbacks);
 	SettingsWrapBitBoolEx(GPUPaletteConversion, "paltex");
 	SettingsWrapBitBoolEx(AutoFlushSW, "autoflush_sw");
+	SettingsWrapIntEnumEx(PGSSuperSampling, "pgsSuperSampling");
+	SettingsWrapBitBoolEx(PGSHighResScanout, "pgsHighResScanout");
+	SettingsWrapBitBoolEx(PGSSuperSampleTextures, "pgsSuperSampleTextures");
+	SettingsWrapBitBoolEx(PGSDisableMipmaps, "pgsDisableMipmaps");
+	SettingsWrapBitBoolEx(PGSDisableReadbackSync, "pgsDisableReadbackSync");
+	SettingsWrapBitBoolEx(PGSSharpBackbuffer, "pgsSharpBackbuffer");
+	SettingsWrapBitBoolEx(PGSBlendDemotion, "pgsBlendDemotion");
 	SettingsWrapBitBoolEx(PreloadFrameWithGSData, "preload_frame_with_gs_data");
 	SettingsWrapBitBoolEx(Mipmap, "mipmap");
 	SettingsWrapBitBoolEx(ManualUserHacks, "UserHacks");
diff --git a/pcsx2/pcsx2.vcxproj b/pcsx2/pcsx2.vcxproj
index 41ff04385..b8816342c 100644
--- a/pcsx2/pcsx2.vcxproj
+++ b/pcsx2/pcsx2.vcxproj
@@ -53,6 +53,15 @@
       <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)3rdparty\d3d12memalloc\include</AdditionalIncludeDirectories>
       <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)3rdparty\lzma\include</AdditionalIncludeDirectories>
       <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)3rdparty\freesurround\include</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)pcsx2\GS\parallel-gs\gs</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)pcsx2\GS\parallel-gs\Granite\vulkan</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)pcsx2\GS\parallel-gs\Granite\util</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)pcsx2\GS\parallel-gs\Granite\math</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)pcsx2\GS\parallel-gs\Granite\filesystem</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)pcsx2\GS\parallel-gs\Granite\application\global</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)pcsx2\GS\parallel-gs\Granite\third_party\volk</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)pcsx2\GS\parallel-gs\Granite\third_party\renderdoc</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(SolutionDir)pcsx2\GS\parallel-gs\Granite\third_party\stb\stb</AdditionalIncludeDirectories>
       <AdditionalIncludeDirectories Condition="'$(Platform)'=='x64'">%(AdditionalIncludeDirectories);$(SolutionDir)3rdparty\xbyak</AdditionalIncludeDirectories>
       <AdditionalIncludeDirectories Condition="'$(Platform)'=='x64'">%(AdditionalIncludeDirectories);$(SolutionDir)3rdparty\zydis\include;$(SolutionDir)3rdparty\zydis\dependencies\zycore\include</AdditionalIncludeDirectories>
       <AdditionalIncludeDirectories Condition="'$(Platform)'=='ARM64'">%(AdditionalIncludeDirectories);$(SolutionDir)3rdparty\vixl\include</AdditionalIncludeDirectories>
@@ -61,7 +70,7 @@
       <PrecompiledHeader>Use</PrecompiledHeader>
       <PrecompiledHeaderFile>PrecompiledHeader.h</PrecompiledHeaderFile>
       <ForcedIncludeFiles>PrecompiledHeader.h;%(ForcedIncludeFiles)</ForcedIncludeFiles>
-      <PreprocessorDefinitions>C4_NO_DEBUG_BREAK;ST_NO_EXCEPTION_HANDLING;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <PreprocessorDefinitions>HAVE_PARALLEL_GS;C4_NO_DEBUG_BREAK;ST_NO_EXCEPTION_HANDLING;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <PreprocessorDefinitions Condition="'$(Platform)'!='ARM64'">ENABLE_RAINTEGRATION;ENABLE_OPENGL;ENABLE_VULKAN;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <PreprocessorDefinitions Condition="'$(Platform)'=='x64'">XBYAK_NO_EXCEPTION;ZYCORE_STATIC_DEFINE;ZYDIS_STATIC_DEFINE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <PreprocessorDefinitions Condition="'$(Platform)'=='ARM64'">VIXL_INCLUDE_TARGET_AARCH64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
@@ -259,6 +268,47 @@
     <ClCompile Include="Gif_Logger.cpp" />
     <ClCompile Include="Gif_Unit.cpp" />
     <ClCompile Include="GSDumpReplayer.cpp" />
+    <ClCompile Include="GS\Renderers\parallel-gs\GSRendererPGS.cpp" />
+    <ClCompile Include="GS\parallel-gs\gs\gs_interface.cpp" />
+    <ClCompile Include="GS\parallel-gs\gs\gs_renderer.cpp" />
+    <ClCompile Include="GS\parallel-gs\gs\gs_util.cpp" />
+    <ClCompile Include="GS\parallel-gs\gs\page_tracker.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\buffer.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\buffer_pool.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\command_buffer.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\command_pool.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\context.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\cookie.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\descriptor_set.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\device.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\event_manager.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\fence.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\fence_manager.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\image.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\indirect_layout.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\memory_allocator.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\pipeline_event.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\query_pool.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\render_pass.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\renderdoc_capture.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\sampler.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\semaphore.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\semaphore_manager.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\shader.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\wsi.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\pipeline_cache.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\texture\memory_mapped_texture.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\texture\texture_files.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\vulkan\texture\texture_format.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\util\aligned_alloc.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\util\arena_allocator.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\util\logging.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\util\timer.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\util\environment.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\util\timeline_trace_file.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\util\thread_id.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\util\thread_name.cpp" />
+    <ClCompile Include="GS\parallel-gs\Granite\util\thread_priority.cpp" />
     <ClCompile Include="GS\Renderers\DX11\D3D.cpp" />
     <ClCompile Include="GS\Renderers\DX12\GSDevice12.cpp" />
     <ClCompile Include="GS\Renderers\DX12\GSTexture12.cpp" />
-- 
2.47.1

