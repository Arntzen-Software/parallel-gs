#version 450

// SPDX-FileCopyrightText: 2024 Arntzen Software AS
// SPDX-FileContributor: Hans-Kristian Arntzen
// SPDX-FileContributor: Runar Heyer
// SPDX-License-Identifier: LGPL-3.0+

#extension GL_EXT_shader_16bit_storage : require
layout(local_size_x = 256) in;
layout(constant_id = 0) const uint VRAM_MASK = 4 * 1024 * 1024 - 1;

#include "swizzle_utils.h"
#include "data_structures.h"

layout(std430, set = 0, binding = 0) readonly buffer VRAM32
{
	uint data[];
} vram32;

layout(std430, set = 0, binding = 0) readonly buffer VRAM16
{
	uint16_t data[];
} vram16;

layout(std140, set = 0, binding = 1) uniform CLUTDesc
{
	CLUTDescriptor data[1024];
} cluts;

layout(std430, set = 0, binding = BINDING_CLUT) buffer CLUT16
{
	uint16_t data[];
} clut16;

layout(push_constant) uniform Registers
{
	uint clut_count;
	uint read_index;
} registers;

shared uint tmp_clut[512];

const uint CLUT_SIZE_16 = CLUT_SIZE / 2;

uint wrap_clut(uint index)
{
	return index & (CLUT_SIZE_16 - 1);
}

void main()
{
	// Copy from previous instance to allow a CLUT entry to be partially overwritten and used later
	uint read_index = registers.read_index * CLUT_SIZE_16;
	tmp_clut[gl_LocalInvocationIndex] = uint(clut16.data[read_index]);
	tmp_clut[gl_LocalInvocationIndex + 256u] = uint(clut16.data[read_index + 256u]);
	barrier();

	for (uint i = 0; i < registers.clut_count; i++)
	{
		CLUTDescriptor clut = cluts.data[i];

		bool active_lane;
		if (clut.tex_format == PSMT4 || clut.tex_format == PSMT4HH || clut.tex_format == PSMT4HL)
			active_lane = gl_LocalInvocationIndex < 16;
		else
			active_lane = true;

		// CSM1: Linear coordinate is converted to 2D coordinate. This samples VRAM using clut.format.
		// CSM2: Linear coordinate is converted to 2D offset + ivec2(linear_coordinate, 0).

		uvec2 coord;
		if (clut.csm != 0)
		{
			coord.x = gl_LocalInvocationIndex + bitfieldExtract(clut.co_uv, 0, 16) * 16;
			coord.y = bitfieldExtract(clut.co_uv, 16, 16);
		}
		else
		{
			coord.x = bitfieldExtract(gl_LocalInvocationIndex, 0, 3);
			coord.y = bitfieldExtract(gl_LocalInvocationIndex, 3, 1);
			coord.x = bitfieldInsert(coord.x, bitfieldExtract(gl_LocalInvocationIndex, 4, 1), 3, 1);
			coord.y = bitfieldInsert(coord.y, bitfieldExtract(gl_LocalInvocationIndex, 5, 3), 1, 3);
		}

		if (active_lane)
		{
			if (clut.format == PSMCT32)
			{
				uint vram_addr = swizzle_PS2(coord.x, coord.y, clut.base_pointer, clut.cbw, clut.format, VRAM_MASK);
				uint vram_data = vram32.data[vram_addr];
				tmp_clut[wrap_clut(gl_LocalInvocationIndex + clut.csa * 16)] = bitfieldExtract(vram_data, 0, 16);
				tmp_clut[wrap_clut(gl_LocalInvocationIndex + clut.csa * 16 + 256u)] = bitfieldExtract(vram_data, 16, 16);
			}
			else
			{
				uint vram_addr = swizzle_PS2(coord.x, coord.y, clut.base_pointer, clut.cbw, clut.format, VRAM_MASK);
				uint lo_16 = uint(vram16.data[vram_addr]);
				tmp_clut[wrap_clut(gl_LocalInvocationIndex + clut.csa * 16)] = lo_16;
			}
		}

		// Flush current CLUT state.
		barrier();
		clut16.data[gl_LocalInvocationIndex + clut.instance * CLUT_SIZE_16] =
			uint16_t(tmp_clut[gl_LocalInvocationIndex]);
		clut16.data[gl_LocalInvocationIndex + clut.instance * CLUT_SIZE_16 + 256u] =
			uint16_t(tmp_clut[gl_LocalInvocationIndex + 256u]);
		barrier();
	}
}